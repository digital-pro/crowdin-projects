<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real ImageNet Classifier for Vocab Images</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
        }
        .controls { 
            background: #e3f2fd; 
            padding: 20px; 
            border-radius: 8px; 
            margin-bottom: 20px; 
        }
        .image-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
            gap: 20px; 
            margin: 20px 0; 
        }
        .image-item { 
            border: 1px solid #ddd; 
            border-radius: 8px; 
            padding: 15px; 
            background: #f9f9f9; 
        }
        .image-container { 
            position: relative; 
            margin-bottom: 15px; 
        }
        .vocab-image { 
            width: 100%; 
            height: 200px; 
            object-fit: contain; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
        }
        .grid-overlay { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
        }
        .grid-cell { 
            position: absolute; 
            border: 2px solid rgba(255, 0, 0, 0.7); 
            background: rgba(255, 255, 255, 0.1); 
            cursor: pointer; 
            pointer-events: all; 
        }
        .grid-cell:hover { 
            background: rgba(255, 255, 0, 0.3); 
        }
        .grid-cell.analyzing { 
            background: rgba(0, 255, 0, 0.3); 
        }
        .results { 
            margin-top: 10px; 
        }
        .prediction { 
            margin: 5px 0; 
            padding: 8px; 
            background: #f0f0f0; 
            border-radius: 4px; 
            font-size: 0.9em; 
        }
        .prediction.vocab-match { 
            background: #d4edda; 
            border-left: 4px solid #28a745; 
        }
        .progress { 
            background: #e9ecef; 
            border-radius: 4px; 
            height: 20px; 
            margin: 10px 0; 
        }
        .progress-bar { 
            background: #007bff; 
            height: 100%; 
            border-radius: 4px; 
            transition: width 0.3s; 
        }
        .stats { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
            gap: 15px; 
            margin: 20px 0; 
        }
        .stat-card { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 8px; 
            text-align: center; 
        }
        .stat-number { 
            font-size: 2em; 
            font-weight: bold; 
            color: #007bff; 
        }
        .loading { 
            text-align: center; 
            padding: 20px; 
        }
        .error { 
            background: #f8d7da; 
            color: #721c24; 
            padding: 15px; 
            border-radius: 4px; 
            margin: 10px 0; 
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Real ImageNet Classifier for Vocab Images</h1>
        
        <div class="controls">
            <h3>üöÄ Real Computer Vision Analysis</h3>
            <p>This tool uses a real MobileNet ImageNet classifier to analyze vocabulary test images. Click on grid cells to classify individual quadrants.</p>
            <button id="loadModel" onclick="loadModel()">Load ImageNet Model</button>
            <button id="analyzeAll" onclick="analyzeAllImages()" disabled>Analyze All Images</button>
            <button id="downloadResults" onclick="downloadResults()" disabled>Download Results</button>
            <div id="modelStatus">Click "Load Model" to start</div>
        </div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat-card">
                <div class="stat-number" id="totalImages">0</div>
                <div>Images Loaded</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalClassifications">0</div>
                <div>Classifications</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="vocabMatches">0</div>
                <div>Vocab Matches</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="avgConfidence">0%</div>
                <div>Avg Confidence</div>
            </div>
        </div>

        <div class="progress" id="progressContainer" style="display: none;">
            <div class="progress-bar" id="progressBar"></div>
        </div>

        <div id="imageGrid" class="image-grid"></div>
        
        <div id="loading" class="loading">
            <p>Ready to load ImageNet model...</p>
        </div>
    </div>

    <script>
        // Vocabulary list from vocab_list.txt
        const VOCAB_LIST = [
            'acorn', 'aloe', 'antenna', 'artichoke', 'bamboo', 'barrel', 'blender', 'blower', 'bouquet', 'buffet',
            'bulldozer', 'cake', 'caramel', 'carousel', 'carrot', 'cassette', 'cheese', 'cloak', 'clothespin', 'coaster',
            'cork', 'cornbread', 'corset', 'dumpling', 'elbow', 'fan', 'foam', 'footbath', 'fruitcake', 'gutter',
            'hamster', 'hedgehog', 'hoe', 'hopscotch', 'kimono', 'latch', 'locker', 'lollipop', 'map', 'marshmallow',
            'net', 'oil', 'omelet', 'pie', 'pistachio', 'pitcher', 'potato', 'prism', 'puddle', 'pump',
            'rice', 'saddle', 'sandbag', 'scaffolding', 'scoop', 'seagull', 'ship', 'shower', 'silverware', 'sink',
            'ski', 'sloth', 'snail', 'sorbet', 'spatula', 'sprinkler', 'squash', 'squirrel', 'stew', 'rubber band',
            'stump', 'sunflower', 'swordfish', 'tapestry', 'teabag', 'telescope', 'thermos', 'treasure', 'trumpet', 'tulip',
            'turbine', 'turkey', 'turtle', 'typewriter', 'watermelon', 'waterwheel', 'ant', 'ball', 'bear', 'duck',
            'fork', 'kitten', 'knee', 'milkshake', 'skin', 'wall', 'wheel', 'farm', 'juggling', 'dressing',
            'roof', 'peeking', 'ruler', 'tunnel', 'envelope', 'diamond', 'calendar', 'panda', 'arrow', 'picking',
            'dripping', 'knight', 'delivering', 'dentist', 'claw', 'uniform', 'furry', 'cormorant', 'fetch', 'arcade',
            'artifact', 'aversion', 'beret', 'applaud', 'timid', 'camp', 'tumble', 'concentric', 'confectionery', 'couturier',
            'degression', 'divan', 'wetland', 'baywindow', 'aesthete', 'ecstatic', 'rickety', 'gourmet', 'gesticulate', 'facade',
            'slope', 'habit', 'intersection', 'irrigation', 'kazoo', 'chat', 'colony', 'preserve', 'awning', 'mammalogy',
            'metronome', 'paleontologist', 'percussion', 'posterior', 'precarious', 'arbor', 'resuscitation', 'rosette', 'saffron', 'mischievous',
            'skimmer', 'sedentary', 'suede', 'turnstile', 'triad', 'dredging', 'urban', 'steam', 'vertebra', 'bandage'
        ];

        let model = null;
        let results = [];
        let currentImageIndex = 0;
        let totalClassifications = 0;
        let vocabMatches = 0;
        let confidenceSum = 0;

        // GitHub API configuration
        const GITHUB_API_BASE = 'https://api.github.com/repos/levante-framework/core-tasks/contents/golden-runs/vocab';
        const BRANCH = 'more-tasks-tested';

        async function loadModel() {
            try {
                document.getElementById('modelStatus').textContent = 'Loading MobileNet model...';
                document.getElementById('loadModel').disabled = true;
                
                model = await mobilenet.load();
                
                document.getElementById('modelStatus').textContent = '‚úÖ Model loaded! Loading images...';
                document.getElementById('analyzeAll').disabled = false;
                
                await loadVocabImages();
                
            } catch (error) {
                console.error('Error loading model:', error);
                document.getElementById('modelStatus').innerHTML = `‚ùå Error loading model: ${error.message}`;
            }
        }

        async function loadVocabImages() {
            try {
                const response = await fetch(`${GITHUB_API_BASE}?ref=${BRANCH}`);
                const files = await response.json();
                
                const imageFiles = files.filter(file => 
                    file.type === 'file' && 
                    /\.(png|jpg|jpeg|gif|webp)$/i.test(file.name) &&
                    file.name !== 'vocab-002.png' // Exclude as it has no objects
                ).slice(0, 20); // Limit to first 20 for demo

                document.getElementById('totalImages').textContent = imageFiles.length;
                document.getElementById('stats').style.display = 'grid';
                
                const imageGrid = document.getElementById('imageGrid');
                imageGrid.innerHTML = '';

                imageFiles.forEach((file, index) => {
                    const imageItem = createImageItem(file, index);
                    imageGrid.appendChild(imageItem);
                });

                document.getElementById('loading').style.display = 'none';
                document.getElementById('modelStatus').textContent = `‚úÖ Ready! ${imageFiles.length} images loaded.`;
                
            } catch (error) {
                console.error('Error loading images:', error);
                document.getElementById('loading').innerHTML = `<div class="error">Error loading images: ${error.message}</div>`;
            }
        }

        function createImageItem(file, index) {
            const div = document.createElement('div');
            div.className = 'image-item';
            div.innerHTML = `
                <div class="image-container">
                    <img src="${file.download_url}" alt="${file.name}" class="vocab-image" crossorigin="anonymous">
                    <div class="grid-overlay">
                        <div class="grid-cell" data-position="top-left" style="top: 0; left: 0; width: 50%; height: 50%;" onclick="classifyGridCell(${index}, 'top-left')"></div>
                        <div class="grid-cell" data-position="top-right" style="top: 0; right: 0; width: 50%; height: 50%;" onclick="classifyGridCell(${index}, 'top-right')"></div>
                        <div class="grid-cell" data-position="bottom-left" style="bottom: 0; left: 0; width: 50%; height: 50%;" onclick="classifyGridCell(${index}, 'bottom-left')"></div>
                        <div class="grid-cell" data-position="bottom-right" style="bottom: 0; right: 0; width: 50%; height: 50%;" onclick="classifyGridCell(${index}, 'bottom-right')"></div>
                    </div>
                </div>
                <h4>${file.name}</h4>
                <div class="results" id="results-${index}"></div>
            `;
            
            div.dataset.fileUrl = file.download_url;
            div.dataset.fileName = file.name;
            
            return div;
        }

        async function classifyGridCell(imageIndex, position) {
            if (!model) {
                alert('Please load the model first!');
                return;
            }

            const imageItem = document.querySelectorAll('.image-item')[imageIndex];
            const img = imageItem.querySelector('.vocab-image');
            const gridCell = imageItem.querySelector(`[data-position="${position}"]`);
            
            gridCell.classList.add('analyzing');
            
            try {
                // Create a canvas to extract the specific grid cell
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size to match the grid cell (half of image)
                canvas.width = img.naturalWidth / 2;
                canvas.height = img.naturalHeight / 2;
                
                // Calculate source coordinates based on position
                let sx = 0, sy = 0;
                if (position.includes('right')) sx = img.naturalWidth / 2;
                if (position.includes('bottom')) sy = img.naturalHeight / 2;
                
                // Draw the specific quadrant
                ctx.drawImage(img, sx, sy, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
                
                // Classify the grid cell
                const predictions = await model.classify(canvas);
                
                // Check for vocabulary matches
                const vocabPredictions = predictions.map(pred => {
                    const vocabMatch = findVocabMatch(pred.className);
                    return {
                        ...pred,
                        vocabMatch: vocabMatch,
                        isVocabMatch: !!vocabMatch
                    };
                });

                // Update statistics
                totalClassifications++;
                if (vocabPredictions.some(p => p.isVocabMatch)) {
                    vocabMatches++;
                }
                confidenceSum += predictions[0].probability;
                
                updateStats();
                displayResults(imageIndex, position, vocabPredictions);
                
            } catch (error) {
                console.error('Classification error:', error);
                const resultsDiv = document.getElementById(`results-${imageIndex}`);
                resultsDiv.innerHTML += `<div class="error">Error classifying ${position}: ${error.message}</div>`;
            } finally {
                gridCell.classList.remove('analyzing');
            }
        }

        function findVocabMatch(className) {
            const lowerClassName = className.toLowerCase();
            
            // Direct match
            const directMatch = VOCAB_LIST.find(vocab => 
                vocab.toLowerCase() === lowerClassName ||
                lowerClassName.includes(vocab.toLowerCase()) ||
                vocab.toLowerCase().includes(lowerClassName)
            );
            
            if (directMatch) return directMatch;
            
            // Partial word matches
            const words = lowerClassName.split(/[\s,_-]+/);
            for (const word of words) {
                const match = VOCAB_LIST.find(vocab => 
                    vocab.toLowerCase() === word ||
                    vocab.toLowerCase().includes(word) ||
                    word.includes(vocab.toLowerCase())
                );
                if (match) return match;
            }
            
            return null;
        }

        function displayResults(imageIndex, position, predictions) {
            const resultsDiv = document.getElementById(`results-${imageIndex}`);
            
            const positionDiv = document.createElement('div');
            positionDiv.innerHTML = `
                <strong>${position}:</strong>
                ${predictions.map((pred, i) => `
                    <div class="prediction ${pred.isVocabMatch ? 'vocab-match' : ''}">
                        ${i + 1}. ${pred.className} (${(pred.probability * 100).toFixed(1)}%)
                        ${pred.isVocabMatch ? `<strong> ‚Üí VOCAB: ${pred.vocabMatch}</strong>` : ''}
                    </div>
                `).join('')}
            `;
            
            resultsDiv.appendChild(positionDiv);
            
            // Store results for download
            results.push({
                imageIndex,
                fileName: document.querySelectorAll('.image-item')[imageIndex].dataset.fileName,
                position,
                predictions: predictions.map(p => ({
                    className: p.className,
                    probability: p.probability,
                    vocabMatch: p.vocabMatch,
                    isVocabMatch: p.isVocabMatch
                }))
            });
        }

        function updateStats() {
            document.getElementById('totalClassifications').textContent = totalClassifications;
            document.getElementById('vocabMatches').textContent = vocabMatches;
            document.getElementById('avgConfidence').textContent = 
                totalClassifications > 0 ? `${((confidenceSum / totalClassifications) * 100).toFixed(1)}%` : '0%';
            
            if (totalClassifications > 0) {
                document.getElementById('downloadResults').disabled = false;
            }
        }

        async function analyzeAllImages() {
            const imageItems = document.querySelectorAll('.image-item');
            const totalCells = imageItems.length * 4;
            let currentCell = 0;
            
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('analyzeAll').disabled = true;
            
            for (let i = 0; i < imageItems.length; i++) {
                const positions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
                
                for (const position of positions) {
                    await classifyGridCell(i, position);
                    currentCell++;
                    
                    const progress = (currentCell / totalCells) * 100;
                    document.getElementById('progressBar').style.width = `${progress}%`;
                    
                    // Small delay to prevent overwhelming the browser
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('analyzeAll').disabled = false;
            alert(`Analysis complete! Found ${vocabMatches} vocabulary matches out of ${totalClassifications} classifications.`);
        }

        function downloadResults() {
            const data = {
                metadata: {
                    timestamp: new Date().toISOString(),
                    totalImages: document.querySelectorAll('.image-item').length,
                    totalClassifications: totalClassifications,
                    vocabMatches: vocabMatches,
                    matchRate: totalClassifications > 0 ? (vocabMatches / totalClassifications) * 100 : 0,
                    avgConfidence: totalClassifications > 0 ? (confidenceSum / totalClassifications) * 100 : 0,
                    model: 'MobileNet ImageNet',
                    vocabularyList: VOCAB_LIST
                },
                results: results
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `real-imagenet-vocab-analysis-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html> 