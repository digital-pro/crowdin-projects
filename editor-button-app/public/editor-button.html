<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Levante Audio Test</title>
    <script src="https://cdn.crowdin.com/apps/dist/iframe.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 5px;
            background: #f8f9fa;
            color: #333;
            font-size: 12px;
            line-height: 1.3;
            min-height: 150px;
            height: auto;
            overflow-y: auto;
        }
        
        .container {
            background: white;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 120px;
            height: auto;
        }
        
        h1 {
            margin: 0 0 6px 0;
            font-size: 14px;
            color: #2c5aa0;
            font-weight: 600;
        }
        
        .button-group {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: background-color 0.2s;
            flex: 1;
            min-width: 90px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .audio-section {
            margin-top: 8px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fafafa;
        }
        
        .dropdowns-row {
            display: flex;
            gap: 12px;
            margin-bottom: 8px;
            align-items: end;
        }
        
        .dropdown-group {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .dropdown-group label {
            font-size: 10px;
            margin-bottom: 2px;
            color: #666;
            font-weight: 500;
        }
        
        .dropdown-group select {
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 11px;
            background: white;
        }
        
        .audio-buttons {
            display: flex;
            gap: 4px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }
        
        .audio-btn {
            font-size: 10px;
            padding: 4px 8px;
            min-width: 70px;
            flex: 1;
        }
        
        .form-row {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        label {
            font-weight: 500;
            font-size: 10px;
            color: #495057;
            white-space: nowrap;
        }
        
        select {
            flex: 1;
            padding: 3px 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 10px;
            min-width: 80px;
        }
        
        .status {
            margin-top: 6px;
            padding: 4px 6px;
            background: #e9ecef;
            border-radius: 3px;
            font-size: 10px;
            word-wrap: break-word;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 4px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Modal Styles - Compact */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 12px;
            border-radius: 6px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal h2 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #2c5aa0;
        }
        
        .modal label {
            display: block;
            margin: 6px 0 3px 0;
            font-size: 11px;
        }
        
        .modal input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 11px;
            box-sizing: border-box;
        }
        
        .modal-buttons {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        
        .close:hover {
            color: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="button-group">
            <div class="audio-section">
                <div class="audio-buttons">
                    <button id="playAudioBtn" class="audio-btn">
                        üéµ Play Current Audio
                    </button>
                    <button id="generateAudioBtn" class="audio-btn">
                        üé§ Generate New Audio
                    </button>
                    <button id="refreshBtn" class="audio-btn" style="background: #007bff;">
                        üîÑ Refresh Context
                    </button>
                </div>
                <div id="audioGeneration" style="display: none;">
                    <div class="audio-section">
                        <div class="dropdowns-row">
                            <div class="dropdown-group">
                                <select id="serviceSelect" onchange="onServiceChange()">
                                    <option value="">Select Service</option>
                                    <option value="PlayHT">PlayHT</option>
                                    <option value="ElevenLabs">ElevenLabs</option>
                                </select>
                            </div>
                            <div class="dropdown-group">
                                <select id="voiceSelect" onchange="onVoiceChange()">
                                    <option value="">Select Voice</option>
                                </select>
                            </div>
                        </div>
                        <div class="audio-buttons">
                            <button id="generateBtn" onclick="generateAudio()" class="audio-btn" disabled>Generate</button>
                            <button onclick="hideAudioGeneration()" class="audio-btn">Close</button>
                            <button onclick="showCredentialsModal()" class="audio-btn">API Settings</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
    </div>

    <!-- Credentials Modal -->
    <div id="credentialsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üîë API Credentials</h2>
                <span class="close" onclick="closeCredentialsModal()">&times;</span>
            </div>
            <div class="credentials-form">
                <div class="credential-group">
                    <label for="playhtApiKey">PlayHT API Key:</label>
                    <input type="text" id="playhtApiKey" placeholder="Enter PlayHT API Key">
                    
                    <label for="playhtUserId">PlayHT User ID:</label>
                    <input type="text" id="playhtUserId" placeholder="Enter PlayHT User ID">
                    
                    <label for="elevenlabsApiKey">ElevenLabs API Key:</label>
                    <input type="text" id="elevenlabsApiKey" placeholder="Enter ElevenLabs API Key">
                </div>
                <div class="credentials-buttons">
                    <button onclick="saveCredentials()" class="btn btn-primary">
                        üíæ Save Credentials
                    </button>
                    <button onclick="recoverCredentials()" class="btn btn-success">
                        üîÑ Recover Credentials
                    </button>
                    <button onclick="clearCredentials()" class="btn btn-secondary">
                        üóëÔ∏è Clear All
                    </button>
                </div>
                <div class="credential-status" id="credentialStatus">
                    <p><strong>Current Status:</strong></p>
                    <div class="status-grid">
                        <div class="status-item">
                            <span class="status-label">PlayHT API Key:</span>
                            <span id="playhtKeyStatus" class="status-indicator">‚ùå Not Set</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">PlayHT User ID:</span>
                            <span id="playhtUserStatus" class="status-indicator">‚ùå Not Set</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">ElevenLabs API Key:</span>
                            <span id="elevenlabsKeyStatus" class="status-indicator">‚ùå Not Set</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced context detection using Crowdin AP API
        function getCrowdinContext() {
            const urlParams = new URLSearchParams(window.location.search);
            const context = {};
            
            // Standard Crowdin parameters from URL
            const crowdinParams = [
                'projectId', 'fileId', 'stringId', 'languageId', 'userId', 'mode',
                'stringKey', 'identifier', 'key', 'sourceString', 'targetString',
                'context', 'maxLength', 'isPlural', 'pluralForm', 'origin', 'client_id', 'clientId', 'jwtToken'
            ];
            
            crowdinParams.forEach(param => {
                const value = urlParams.get(param);
                if (value) {
                    context[param] = value;
                }
            });
            
            // Use Crowdin AP API if available (proper way to access context)
            if (typeof AP !== 'undefined') {
                console.log('üéØ Crowdin AP API is available, requesting context...');
                
                // Request current string context
                if (AP.editor && AP.editor.getCurrentString) {
                    AP.editor.getCurrentString(function(stringData) {
                        console.log('üéØ AP.editor.getCurrentString result:', stringData);
                        if (stringData) {
                            receivedContext = { ...receivedContext, ...stringData };
                        }
                    });
                }
                
                // Request general context
                if (AP.context && AP.context.getContext) {
                    AP.context.getContext(function(contextData) {
                        console.log('üéØ AP.context.getContext result:', contextData);
                        if (contextData) {
                            receivedContext = { ...receivedContext, ...contextData };
                        }
                    });
                }
                
                // Request current translation
                if (AP.editor && AP.editor.getCurrentTranslation) {
                    AP.editor.getCurrentTranslation(function(translationData) {
                        console.log('üéØ AP.editor.getCurrentTranslation result:', translationData);
                        if (translationData) {
                            receivedContext = { ...receivedContext, ...translationData };
                        }
                    });
                }
            } else {
                console.log('üéØ Crowdin AP API not available, using fallback methods...');
                
                // Fallback: Try to get context from parent window if in iframe (without accessing cross-origin properties)
                if (window.parent && window.parent !== window) {
                    try {
                        // Request context from parent via postMessage (safe cross-origin method)
                        window.parent.postMessage({
                            type: 'request-context',
                            source: 'crowdin-app'
                        }, '*');
                    } catch (e) {
                        console.log('Cannot send postMessage to parent');
                    }
                }
            }
            
            return context;
        }
        

        
        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
            
            if (type !== 'loading') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        }
        

        
        // Function to actively request context from Crowdin
        function requestCrowdinContext() {
            if (window.parent && window.parent !== window) {
                // Try multiple message types that Crowdin might respond to
                const messages = [
                    { type: 'get-context' },
                    { type: 'request-context' },
                    { type: 'app-ready' },
                    { type: 'get-editor-context' },
                    { type: 'get-string-context' },
                    { action: 'getContext' },
                    { action: 'getCurrentString' }
                ];
                
                messages.forEach(message => {
                    try {
                        window.parent.postMessage(message, '*');
                    } catch (e) {
                        console.log('Failed to send message:', message);
                    }
                });
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Crowdin context detection
            initializeContext();
        });
        
        // Store received context data
        let receivedContext = {};
        
        // Enhanced message handler for Crowdin context
        function enhancedMessageHandler(event) {
            // Only process messages from Crowdin origins
            if (!event.origin || !event.origin.includes('crowdin.com')) {
                return;
            }
            
            // Throttle message processing to prevent overload
            if (window.lastMessageTime && Date.now() - window.lastMessageTime < 50) {
                return;
            }
            window.lastMessageTime = Date.now();
            
            console.log('üì® Received message from Crowdin:', JSON.stringify({
                origin: event.origin,
                type: event.data?.type,
                data: event.data
            }, null, 2));
            
            // Handle different types of messages from Crowdin
            if (event.data) {
                console.log('üîç Checking event data:', {
                    type: event.data.type,
                    etyp: event.data.etyp,
                    hasEvnt: !!event.data.evnt
                });
                
                // Handle string.selected and string.change events directly
                if (event.data.type === 'evt') {
                    if (event.data.etyp === 'string.selected' && event.data.evnt && event.data.evnt.length > 0) {
                        console.log('üéØ PROCESSING string.selected event');
                        const stringInfo = event.data.evnt[0];
                        const stringData = stringInfo.string;
                        const translations = stringInfo.translations;
                        
                        receivedContext.stringId = stringData.id;
                        receivedContext.stringKey = stringData.text;
                        receivedContext.sourceString = stringData.text;
                        receivedContext.targetString = stringData.text;
                        receivedContext.identifier = stringData.identifier;
                        receivedContext.fileId = stringData.file?.id;
                        
                        // Use translation if available and not empty
                        if (translations && typeof translations === 'object') {
                            let foundTranslation = false;
                            for (const [langCode, translationArray] of Object.entries(translations)) {
                                if (translationArray && Array.isArray(translationArray) && translationArray.length > 0) {
                                    const translation = translationArray[0];
                                    if (translation && translation.text) {
                                        receivedContext.targetString = translation.text;
                                        receivedContext.targetLanguageId = langCode;
                                        console.log(`üéØ Using ${langCode} translation: ${translation.text}`);
                                        foundTranslation = true;
                                        break;
                                    }
                                }
                            }
                            if (!foundTranslation) {
                                console.log('üéØ No translations found, using source text:', stringData.text);
                                receivedContext.targetLanguageId = 'en'; // Default to English if no translation
                            }
                        } else {
                            console.log('üéØ No translations object, using source text:', stringData.text);
                            receivedContext.targetLanguageId = 'en'; // Default to English if no translations
                        }
                        
                        console.log('üéØ STORED CONTEXT:', receivedContext);
                    }
                    
                    if (event.data.etyp === 'string.change') {
                        console.log('üéØ PROCESSING string.change event');
                        const stringData = event.data.evnt;
                        console.log('üéØ String change data:', stringData);
                        
                        if (stringData) {
                            // Store basic info, but DON'T overwrite targetString if we have a translation
                            const hadTranslation = receivedContext.targetString && 
                                                   receivedContext.targetString !== receivedContext.sourceString;
                            
                            receivedContext.stringId = stringData.id;
                            receivedContext.stringKey = stringData.text;
                            receivedContext.sourceString = stringData.text;
                            receivedContext.identifier = stringData.identifier;
                            receivedContext.fileId = stringData.file?.id;
                            
                            // Only update targetString if we didn't have a translation before
                            if (!hadTranslation) {
                                receivedContext.targetString = stringData.text;
                                console.log('üéØ Updated targetString to source (no previous translation)');
                            } else {
                                console.log('üéØ Preserved existing translation in targetString:', receivedContext.targetString);
                            }
                            
                            console.log('üéØ STORED CONTEXT from string.change:', receivedContext);
                        }
                    }
                }
                
                // Direct context updates
                if (event.data.type === 'crowdin-context' || event.data.type === 'context') {
                    console.log('üéØ Received context update:', event.data.context);
                    receivedContext = { ...receivedContext, ...event.data.context };
                }
                
                // String data in various forms
                if (event.data.stringId || event.data.stringKey || event.data.sourceString || event.data.targetString) {
                    console.log('üéØ Received string data:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // Editor context updates
                if (event.data.type === 'app-context' || event.data.type === 'editor-context') {
                    console.log('üéØ Received editor context:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // Current string updates (when user selects different strings)
                if (event.data.type === 'current-string' || event.data.type === 'string-selected') {
                    console.log('üéØ Received current string update:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // Any other data that might contain useful context
                if (event.data.projectId || event.data.fileId || event.data.languageId) {
                    console.log('üéØ Received project context:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                console.log('üéØ Updated receivedContext:', receivedContext);
            }
        }
        
        // Listen for messages from parent window (if in iframe)
        window.addEventListener('message', enhancedMessageHandler);
        
        // Enhanced context getter that includes received messages
        function getEnhancedCrowdinContext() {
            const urlContext = getCrowdinContext();
            return { ...urlContext, ...receivedContext };
        }
        
        // Function to manually refresh context from Crowdin
        function refreshContext() {
            console.log('üîÑ Manually refreshing context...');
            receivedContext = {}; // Clear existing context
            
            // Try to get context using AP API if available
            if (typeof AP !== 'undefined') {
                console.log('üéØ Using AP API to refresh context...');
                
                if (AP.editor && AP.editor.getCurrentString) {
                    AP.editor.getCurrentString(function(stringData) {
                        console.log('üéØ Refresh: AP.editor.getCurrentString result:', stringData);
                        if (stringData) {
                            receivedContext = { ...receivedContext, ...stringData };
                        }
                    });
                }
                
                if (AP.context && AP.context.getContext) {
                    AP.context.getContext(function(contextData) {
                        console.log('üéØ Refresh: AP.context.getContext result:', contextData);
                        if (contextData) {
                            receivedContext = { ...receivedContext, ...contextData };
                        }
                    });
                }
                
                if (AP.editor && AP.editor.getCurrentTranslation) {
                    AP.editor.getCurrentTranslation(function(translationData) {
                        console.log('üéØ Refresh: AP.editor.getCurrentTranslation result:', translationData);
                        if (translationData) {
                            receivedContext = { ...receivedContext, ...translationData };
                        }
                    });
                }
            } else {
                console.log('üéØ AP API not available, using fallback methods...');
                requestCrowdinContext();
            }
            
            // Show updated context after a short delay
            setTimeout(() => {
                const context = getEnhancedCrowdinContext();
                console.log('üîÑ Context after refresh:', context);
                showStatus('Context refreshed. Check console for details.', 'success');
            }, 1000);
        }
        
        // Initialize context on page load
        function initializeContext() {
            console.log('üöÄ Initializing Crowdin context...');
            
            // Wait a bit for AP API to load if it's going to
            setTimeout(() => {
                if (typeof AP !== 'undefined') {
                    console.log('‚úÖ AP API is available, requesting initial context...');
                    refreshContext();
                } else {
                    console.log('‚ö†Ô∏è AP API not available, using fallback methods...');
                    requestCrowdinContext();
                }
            }, 500);
            
            // Try again after a longer delay in case AP loads slowly
            setTimeout(() => {
                if (typeof AP !== 'undefined' && Object.keys(receivedContext).length === 0) {
                    console.log('üîÑ Second attempt to get context with AP API...');
                    refreshContext();
                }
            }, 2000);
        }

        // Enhanced function to detect the target language from Crowdin context
        function detectTargetLanguage(context) {
            console.log('üåç LANGUAGE DETECTION DEBUG:', JSON.stringify(context, null, 2));
            
            // First try direct language IDs from context
            let detectedLanguage = context.targetLanguageId || context.sourceLanguageId || context.languageId;
            console.log('üåç Direct language from context:', detectedLanguage);
            
            // If no direct language, try URL detection
            if (!detectedLanguage) {
                console.log('üåç No direct language found, trying URL detection...');
                
                // Try current window URL parameters first
                const urlParams = new URLSearchParams(window.location.search);
                const urlLang = urlParams.get('language') || urlParams.get('lang') || urlParams.get('target_language');
                if (urlLang) {
                    console.log('üåç Found language in current URL:', urlLang);
                    detectedLanguage = urlLang;
                }
                
                // Try to detect from parent window location
                if (!detectedLanguage) {
                    try {
                        if (window.parent && window.parent.location) {
                            const parentUrl = window.parent.location.href;
                            console.log('üåç Analyzing parent URL for language:', parentUrl);
                            
                            // Multiple patterns to match different Crowdin URL formats
                            const patterns = [
                                /\/enus-([a-z]{2})(?:[-_][A-Z]{2})?(?:\/|#|$)/,  // enus-fr format
                                /\/([a-z]{2})(?:[-_][A-Z]{2})?-enus(?:\/|#|$)/,  // fr-enus format  
                                /editor\/[^\/]+\/\d+\/enus-([a-z]{2})(?:[-_][A-Z]{2})?/,  // editor/project/83/enus-frca
                                /\/([a-z]{2})(?:[-_][A-Z]{2})?(?:\/|#|$)/,       // generic /fr/ format
                                /target_language=([a-z]{2})/,                    // URL parameter
                                /lang=([a-z]{2})/                               // URL parameter
                            ];
                            
                            for (const pattern of patterns) {
                                const match = parentUrl.match(pattern);
                                if (match && match[1] && match[1] !== 'en') {
                                    console.log('üåç ‚úÖ Detected language from parent URL pattern:', match[1]);
                                    detectedLanguage = match[1];
                                    break;
                                }
                            }
                        }
                    } catch (e) {
                        console.log('üåç Could not access parent URL due to cross-origin restrictions');
                    }
                }
            }
            
            // Map language codes (from audio-previewer logic)
            function mapLanguageCode(languageId) {
                if (!languageId) return null;
                
                const langId = String(languageId).toLowerCase().trim();
                console.log('üåç Mapping language code:', langId);
                
                const languageMappings = {
                    'en': 'en', 'en-us': 'en', 'english': 'en',
                    'es': 'es', 'es-co': 'es', 'spanish': 'es', 'espa√±ol': 'es',
                    'fr': 'fr', 'fr-ca': 'fr', 'french': 'fr', 'fran√ßais': 'fr', 'frca': 'fr',
                    'pt': 'pt', 'pt-br': 'pt', 'portuguese': 'pt', 'portugu√™s': 'pt',
                    'de': 'de', 'de-de': 'de', 'german': 'de', 'deutsch': 'de',
                    'nl': 'nl', 'nl-nl': 'nl', 'nl-be': 'nl', 'dutch': 'nl', 'nederlands': 'nl',
                    'it': 'it', 'it-it': 'it', 'italian': 'it', 'italiano': 'it'
                };
                
                const mapped = languageMappings[langId];
                console.log('üåç Language mapping result:', langId, '->', mapped);
                return mapped || null;
            }
            
            const mappedLanguage = mapLanguageCode(detectedLanguage);
            console.log('üåç Final language detection result:', {
                original: detectedLanguage,
                mapped: mappedLanguage,
                fallback: mappedLanguage || 'en'
            });
            
            return mappedLanguage || 'en'; // Default to English if nothing detected
        }

        // Audio Generation Functionality
        class AudioManager {
            constructor() {
                this.apiConfig = {
                    playht: {
                        apiUrl: 'https://api.play.ht/api/v2/tts/stream',
                        voicesUrl: 'https://api.play.ht/api/v2/voices',
                        apiKey: null,
                        userId: null
                    },
                    elevenlabs: {
                        apiUrl: 'https://api.elevenlabs.io/v1/text-to-speech',
                        voicesUrl: 'https://api.elevenlabs.io/v1/voices',
                        apiKey: null
                    }
                };
                
                this.voiceCache = {};
                this.currentService = null;
                this.currentVoice = null;
                
                // Load credentials using the same method as dashboard.js
                this.loadCredentials();
            }

            loadCredentials() {
                console.log('üîÑ Loading credentials from storage...');
                
                // Load with backup recovery (same as dashboard.js)
                let playhtApiKey = localStorage.getItem('PLAY_DOT_HT_API_KEY') || '';
                let playhtUserId = localStorage.getItem('PLAY_DOT_HT_USER_ID') || '';
                let elevenlabsApiKey = localStorage.getItem('ELEVENLABS_API_KEY') || '';

                // Backup credential recovery - try alternative storage keys
                if (!playhtApiKey) {
                    playhtApiKey = localStorage.getItem('playht_api_key') ||
                                   localStorage.getItem('PLAYHT_API_KEY') ||
                                   sessionStorage.getItem('PLAY_DOT_HT_API_KEY') || '';
                }

                if (!playhtUserId) {
                    playhtUserId = localStorage.getItem('playht_user_id') ||
                                   localStorage.getItem('PLAYHT_USER_ID') ||
                                   sessionStorage.getItem('PLAY_DOT_HT_USER_ID') || '';
                }

                if (!elevenlabsApiKey) {
                    elevenlabsApiKey = localStorage.getItem('elevenlabs_api_key') ||
                                       localStorage.getItem('ELEVENLABS_KEY') ||
                                       sessionStorage.getItem('ELEVENLABS_API_KEY') || '';
                }

                console.log('üîç Credential loading results:', {
                    playhtApiKey: playhtApiKey ? `${playhtApiKey.substring(0, 8)}...` : 'Missing',
                    playhtUserId: playhtUserId ? `${playhtUserId.substring(0, 8)}...` : 'Missing',
                    elevenlabsApiKey: elevenlabsApiKey ? `${elevenlabsApiKey.substring(0, 8)}...` : 'Missing'
                });

                // Update the API config - THIS WAS THE MISSING PART!
                this.apiConfig.playht.apiKey = playhtApiKey;
                this.apiConfig.playht.userId = playhtUserId;
                this.apiConfig.elevenlabs.apiKey = elevenlabsApiKey;

                console.log('‚úÖ API config updated:', {
                    playhtConfigured: !!(this.apiConfig.playht.apiKey && this.apiConfig.playht.userId),
                    elevenlabsConfigured: !!this.apiConfig.elevenlabs.apiKey
                });
            }

            async loadVoices(service, languageCode = 'en') {
                const cacheKey = `${service}_${languageCode}`;
                if (this.voiceCache[cacheKey]) {
                    return this.voiceCache[cacheKey];
                }

                try {
                    let voices = [];
                    if (service === 'PlayHT') {
                        voices = await this.loadPlayHTVoices(languageCode);
                    } else if (service === 'ElevenLabs') {
                        voices = await this.loadElevenLabsVoices(languageCode);
                    }
                    
                    this.voiceCache[cacheKey] = voices;
                    return voices;
                } catch (error) {
                    console.error(`Error loading ${service} voices:`, error);
                    return [];
                }
            }

            async loadPlayHTVoices(languageCode = 'en') {
                console.log('üé§ Loading PlayHT voices from CSV for language:', languageCode);
                
                try {
                    // Load voices from CSV file instead of API
                    const response = await fetch('/preloaded_voices/comprehensive_female_voices_v1.csv');
                    
                    if (!response.ok) {
                        throw new Error(`Failed to load CSV: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log(' PlayHT CSV loaded, first 500 chars:', csvText.substring(0, 500));
                    
                    // Parse CSV properly - handle quoted values and commas within quotes
                    const lines = csvText.split('\n');
                    const headers = this.parseCSVLine(lines[0]);
                    console.log('üìã CSV Headers:', headers);
                    
                    const voices = [];
                    let playhtCount = 0;
                    let totalLines = 0;
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        totalLines++;
                        const values = this.parseCSVLine(line);
                        
                        // Create voice object
                        const voice = {};
                        headers.forEach((header, index) => {
                            voice[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        
                        // Debug first few lines
                        if (i <= 5) {
                            console.log(`üìù Line ${i}:`, voice.service, '|', voice.name);
                        }
                        
                        // Only include PlayHT voices (check first column)
                        if (voice.service === 'PlayHT') {
                            playhtCount++;
                            voices.push({
                                id: voice.id,
                                name: voice.name,
                                language: voice.language,
                                language_code: voice.language_code,
                                gender: voice.gender,
                                age: voice.age,
                                accent: voice.accent,
                                style: voice.style,
                                description: voice.description
                            });
                        }
                    }
                    
                    console.log(`üìä PlayHT CSV parsing results: ${totalLines} total lines, ${playhtCount} PlayHT voices found`);
                    console.log(`üìä PlayHT Total voices from CSV: ${voices.length}`);
                    
                    // Filter by language if specified
                    let filteredVoices = voices;
                    if (languageCode && languageCode !== 'en') {
                        filteredVoices = voices.filter(voice => {
                            const voiceLang = voice.language_code || voice.language || '';
                            return voiceLang.toLowerCase().includes(languageCode.toLowerCase());
                        });
                    }
                    
                    console.log(`üéØ PlayHT Filtered voices for "${languageCode}": ${filteredVoices.length}`);
                    
                    // Log first few voices for debugging
                    if (filteredVoices.length > 0) {
                        console.log('üéµ First 3 PlayHT voices from CSV:', filteredVoices.slice(0, 3));
                    } else {
                        console.warn('‚ö†Ô∏è No PlayHT voices found after filtering');
                    }
                    
                    return filteredVoices;
                    
                } catch (error) {
                    console.error('Error loading PlayHT voices from CSV:', error);
                    return [];
                }
            }

            // Helper method to properly parse CSV lines with quoted values
            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                result.push(current); // Add the last field
                return result;
            }

            async loadElevenLabsVoices(languageCode = 'en') {
                console.log('üéôÔ∏è Loading ElevenLabs Voice Library for language:', languageCode);
                
                if (!this.apiConfig.elevenlabs.apiKey) {
                    console.log('  ‚ùå ElevenLabs API key missing, cannot load personal voice library');
                    return [];
                }
                
                console.log('‚úÖ ElevenLabs API key found, loading your personal voice library...');
                
                try {
                    const response = await fetch('/api/elevenlabs-voices-proxy', {
                        method: 'GET',
                        headers: {
                            'xi-api-key': this.apiConfig.elevenlabs.apiKey
                        }
                    });
                    
                    console.log('üì° ElevenLabs API response status:', response.status);
                    
                    if (!response.ok) {
                        throw new Error(`ElevenLabs API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const allVoices = data.voices || [];
                    
                    // Only show your personal voice library - exclude all public/premade voices
                    const voiceLibrary = allVoices.filter(voice => {
                        const category = voice.category || '';
                        // Only include voices from your personal library
                        const isPersonalLibrary = category === 'cloned' || 
                                                category === 'professional' || 
                                                category === 'generated' ||
                                                category === 'instant';
                        return isPersonalLibrary;
                    });
                    
                    const publicCount = allVoices.length - voiceLibrary.length;
                    console.log(`üéØ ElevenLabs Voice Library: ${voiceLibrary.length} personal voices loaded, ${publicCount} public voices excluded`);
                    
                    if (voiceLibrary.length > 0) {
                        console.log('üéµ Using your personal ElevenLabs voice library');
                        return voiceLibrary.map(voice => ({
                            id: voice.voice_id,
                            name: voice.name,
                            category: voice.category,
                            language: 'English',
                            language_code: 'en',
                            description: voice.description || ''
                        }));
                    } else {
                        console.log('‚ö†Ô∏è No personal voices found in your ElevenLabs voice library');
                        return [];
                    }
                    
                } catch (error) {
                    console.error('üö® ElevenLabs Voice Library loading failed:', error);
                    return [];
                }
            }

            async loadElevenLabsVoicesFromCSV(languageCode = 'en') {
                console.log('üéôÔ∏è Loading ElevenLabs voices from CSV for language:', languageCode);
                
                try {
                    const response = await fetch('/preloaded_voices/comprehensive_female_voices_v1.csv');
                    
                    if (!response.ok) {
                        throw new Error(`Failed to load CSV: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log('üì¶ ElevenLabs CSV loaded, parsing...');
                    
                    // Parse CSV
                    const lines = csvText.split('\n');
                    const headers = lines[0].split(',');
                    const voices = [];
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        const values = line.split(',');
                        const voice = {};
                        
                        headers.forEach((header, index) => {
                            voice[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        
                        // Only include ElevenLabs voices, and only professional/generated (no premade)
                        if (voice.service === 'ElevenLabs' && voice.category !== 'premade') {
                            voices.push({
                                voice_id: voice.id,
                                name: voice.name,
                                language: voice.language,
                                language_code: voice.language_code,
                                gender: voice.gender,
                                age: voice.age,
                                accent: voice.accent,
                                category: voice.category,
                                description: voice.description
                            });
                        }
                    }
                    
                    console.log(`üìä ElevenLabs Total voices from CSV: ${voices.length}`);
                    
                    // Filter by language if specified
                    let filteredVoices = voices;
                    if (languageCode && languageCode !== 'en') {
                        filteredVoices = voices.filter(voice => {
                            const voiceLang = voice.language_code || voice.language || '';
                            return voiceLang.toLowerCase().includes(languageCode.toLowerCase());
                        });
                    }
                    
                    console.log(`üéØ ElevenLabs Filtered voices for "${languageCode}": ${filteredVoices.length}`);
                    
                    // Log first few voices for debugging
                    if (filteredVoices.length > 0) {
                        console.log('üéµ First 3 ElevenLabs voices from CSV:', filteredVoices.slice(0, 3));
                    }
                    
                    return filteredVoices;
                    
                } catch (error) {
                    console.error('Error loading ElevenLabs voices from CSV:', error);
                    return [];
                }
            }

            async generateAudio(service, voiceId, text) {
                console.log(`üé§ Generating audio with ${service}, voice: ${voiceId}, text: "${text.substring(0, 50)}..."`);
                
                if (service === 'PlayHT') {
                    return await this.generatePlayHTAudio(voiceId, text);
                } else if (service === 'ElevenLabs') {
                    return await this.generateElevenLabsAudio(voiceId, text);
                } else {
                    throw new Error(`Unsupported service: ${service}`);
                }
            }

            async generatePlayHTAudio(voiceId, text) {
                console.log(`üé§ Generating audio with PlayHT, voice: ${voiceId}, text: "${text.substring(0, 50)}..."`);
                showStatus('Generating PlayHT audio...', 'info');
                
                const requestData = {
                    text: text,
                    voice: voiceId,
                    voice_engine: 'Play3.0-mini',
                    output_format: 'mp3',
                    sample_rate: 22050
                };

                const response = await fetch('/api/playht-proxy', {
                    method: 'POST',
                    headers: {
                        'Authorization': this.apiConfig.playht.apiKey,
                        'X-USER-ID': this.apiConfig.playht.userId,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`PlayHT API error: ${response.status}`);
                }

                const audioData = await response.arrayBuffer();
                showStatus('Playing PlayHT audio...', 'success');
                await this.playAudioData(audioData);
                showStatus('PlayHT audio completed!', 'success');
                return audioData;
            }

            async generateElevenLabsAudio(voiceId, text) {
                console.log(`üé§ Generating audio with ElevenLabs, voice: ${voiceId}, text: "${text.substring(0, 50)}..."`);
                showStatus('Generating ElevenLabs audio...', 'info');
                
                const requestData = {
                    text: text,
                    model_id: 'eleven_multilingual_v2',
                    voice_settings: {
                        stability: 0.65,
                        similarity_boost: 0.5,
                        style: 0.0,
                        use_speaker_boost: true
                    }
                };

                const response = await fetch(`/api/elevenlabs-proxy/${voiceId}`, {
                    method: 'POST',
                    headers: {
                        'xi-api-key': this.apiConfig.elevenlabs.apiKey,
                        'Content-Type': 'application/json',
                        'Accept': 'audio/mpeg'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`ElevenLabs API error: ${response.status}`);
                }

                const audioData = await response.arrayBuffer();
                showStatus('Playing ElevenLabs audio...', 'success');
                await this.playAudioData(audioData);
                showStatus('ElevenLabs audio completed!', 'success');
                return audioData;
            }

            async playAudioData(audioData) {
                const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                
                return new Promise((resolve, reject) => {
                    audio.addEventListener('ended', () => {
                        URL.revokeObjectURL(audioUrl);
                        resolve();
                    });
                    audio.addEventListener('error', (e) => {
                        URL.revokeObjectURL(audioUrl);
                        reject(e);
                    });
                    audio.play().catch(reject);
                });
            }
        }

        // Initialize audio manager
        const audioManager = new AudioManager();

        // Voice Dropdown Helper Function
        function populateVoiceDropdown(voices, serviceName) {
            const voiceSelect = document.getElementById('voiceSelect');
            voiceSelect.innerHTML = '<option value="">Select Voice</option>';
            
            console.log(`üìã Populating ${serviceName} dropdown with ${voices.length} voices`);
            
            voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = voice.name || 'Unnamed Voice';
                voiceSelect.appendChild(option);
            });
            
            console.log(`‚úÖ ${serviceName} dropdown populated successfully`);
        }
        
        function showAudioGeneration() {
            console.log('üé§ Show audio generation called');
            document.getElementById('audioGeneration').style.display = 'block';
        }

        function hideAudioGeneration() {
            console.log('üé§ Hide audio generation called');
            document.getElementById('audioGeneration').style.display = 'none';
        }

        async function onServiceChange() {
            const serviceSelect = document.getElementById('serviceSelect');
            const voiceSelect = document.getElementById('voiceSelect');
            const generateBtn = document.getElementById('generateBtn');
            
            // Clear voice dropdown
            voiceSelect.innerHTML = '<option value="">Select Voice</option>';
            if (generateBtn) generateBtn.disabled = true;
            
            const selectedService = serviceSelect.value;
            console.log('üîÑ Service changed to:', selectedService);
            
            if (!selectedService) {
                audioManager.currentService = null;
                return;
            }
            
            // Set the current service in audioManager
            audioManager.currentService = selectedService;
            
            // Load voices for the selected service
            showStatus('Loading voices...', 'info');
            try {
                let voices = [];
                if (selectedService === 'PlayHT') {
                    voices = await audioManager.loadPlayHTVoices();
                } else if (selectedService === 'ElevenLabs') {
                    voices = await audioManager.loadElevenLabsVoices();
                }
                
                populateVoiceDropdown(voices, selectedService);
                showStatus(`Loaded ${voices.length} ${selectedService} voices`, 'success');
            } catch (error) {
                console.error(`Error loading ${selectedService} voices:`, error);
                showStatus(`Failed to load ${selectedService} voices`, 'error');
            }
        }

        function onVoiceChange() {
            const voiceSelect = document.getElementById('voiceSelect');
            const generateBtn = document.getElementById('generateBtn');
            
            audioManager.currentVoice = voiceSelect.value;
            if (generateBtn) generateBtn.disabled = !voiceSelect.value;
            
            console.log('üéµ Voice changed:', voiceSelect.value, 'Generate button enabled:', !!voiceSelect.value);
        }

        async function generateAudio() {
            const selectedService = document.getElementById('serviceSelect').value;
            const selectedVoice = document.getElementById('voiceSelect').value;
            
            if (!selectedService || !selectedVoice) {
                showStatus('Please select both service and voice', 'error');
                return;
            }

            // Get the current context with detailed debugging
            console.log('üé§ === GENERATE AUDIO DEBUG ===');
            console.log('üé§ receivedContext:', JSON.stringify(receivedContext, null, 2));
            
            // Use receivedContext directly - don't call getEnhancedCrowdinContext() as it overwrites the translation
            let textToGenerate;
            if (receivedContext && receivedContext.targetString && receivedContext.targetString.trim()) {
                textToGenerate = receivedContext.targetString;
                console.log('üé§ ‚úÖ Using TRANSLATED text from receivedContext:', textToGenerate);
            } else if (receivedContext && receivedContext.sourceString && receivedContext.sourceString.trim()) {
                textToGenerate = receivedContext.sourceString;
                console.log('üé§ ‚ö†Ô∏è Using SOURCE text from receivedContext (no translation):', textToGenerate);
            } else {
                textToGenerate = 'Test audio generation for the selected string.';
                console.log('üé§ ‚ùå Using fallback text (no context available):', textToGenerate);
            }

            if (!textToGenerate || textToGenerate.trim() === '') {
                showStatus('No text available for audio generation', 'error');
                return;
            }

            console.log('üé§ Final text to generate:', JSON.stringify(textToGenerate));
            console.log('üé§ Text length:', textToGenerate.length);

            showStatus('Generating audio...', 'info');

            try {
                if (selectedService === 'PlayHT') {
                    await audioManager.generatePlayHTAudio(selectedVoice, textToGenerate);
                } else if (selectedService === 'ElevenLabs') {
                    await audioManager.generateElevenLabsAudio(selectedVoice, textToGenerate);
                }
            } catch (error) {
                console.error('üö® Audio generation failed:', error);
                showStatus(`Audio generation failed: ${error.message}`, 'error');
            }
        }

        async function playCurrentAudio() {
            try {
                showStatus('Looking for existing audio...', 'loading');
                
                // Get current Crowdin context with detailed debugging
                const context = getEnhancedCrowdinContext();
                console.log('üéµ FULL CONTEXT DEBUG:', JSON.stringify(context, null, 2));
                console.log('üéµ Context keys:', Object.keys(context));
                
                // Try multiple ways to get the string text with detailed logging
                console.log('üéµ STRING EXTRACTION DEBUG:');
                console.log('  - context.targetString:', context.targetString);
                console.log('  - context.sourceString:', context.sourceString);
                console.log('  - context.stringKey:', context.stringKey);
                console.log('  - context.key:', context.key);
                console.log('  - context.identifier:', context.identifier);
                console.log('  - context.text:', context.text);
                
                // Use identifier as primary source for filename, fallback to text for display
                const stringKey = context.identifier || context.targetString || context.sourceString || context.stringKey || context.key || context.text;
                const displayText = context.targetString || context.sourceString || context.stringKey || context.key || context.text || context.identifier;
                
                // Use enhanced language detection
                const languageCode = detectTargetLanguage(context);
                
                console.log('üéµ SELECTED VALUES:');
                console.log('  - stringKey (for filename):', JSON.stringify(stringKey));
                console.log('  - displayText (for reference):', JSON.stringify(displayText));
                console.log('  - languageCode (detected):', JSON.stringify(languageCode));
                console.log('  - stringKey type:', typeof stringKey);
                console.log('  - stringKey length:', stringKey ? stringKey.length : 'null');
                
                if (!stringKey) {
                    console.log('üéµ No string found in context. Full context:', context);
                    showStatus('No text found to play audio for. Try selecting a string in the editor first.', 'error');
                    return;
                }
                
                console.log('üéµ Looking for audio:', { stringKey, displayText, languageCode });
                
                // Enhanced label detection (from audio-previewer logic)
                let labelName = 'general'; // Default fallback
                
                // Try to detect label from various context sources
                if (context.labels && context.labels.length > 0) {
                    labelName = context.labels[0];
                } else if (context.identifier) {
                    // Extract label from string identifier patterns
                    const labelPatterns = [
                        /^([^_]+)_/,  // prefix_something
                        /([a-z]+)[-_]/i,  // label-something or label_something
                    ];
                    
                    for (const pattern of labelPatterns) {
                        const match = context.identifier.match(pattern);
                        if (match) {
                            const extractedLabel = match[1].toLowerCase();
                            
                            // Map common variations to standard directory names (from audio-previewer)
                            const labelMappings = {
                                'egma': 'egma-math',
                                'math': 'egma-math',
                                'matrix': 'matrix-reasoning',
                                'mental': 'mental-rotation',
                                'same': 'same-different-selection',
                                'theory': 'theory-of-mind',
                                'tom': 'theory-of-mind',
                                'trog': 'trog',
                                'vocab': 'vocab',
                                'vocabulary': 'vocab',
                                'survey': 'survey',
                                'general': 'general'
                            };
                            
                            // Check for exact match first
                            if (labelMappings[extractedLabel]) {
                                labelName = labelMappings[extractedLabel];
                                console.log('üéµ Found exact label mapping:', extractedLabel, '->', labelName);
                                break;
                            }
                            
                            // Check for partial matches
                            for (const [key, value] of Object.entries(labelMappings)) {
                                if (extractedLabel.includes(key) || key.includes(extractedLabel)) {
                                    labelName = value;
                                    console.log('üéµ Found partial label mapping:', extractedLabel, '->', labelName);
                                    break;
                                }
                            }
                            
                            // If no mapping found but we have a clean name, use it directly
                            if (labelName === 'general' && extractedLabel && extractedLabel !== 'general') {
                                labelName = extractedLabel;
                                console.log('üéµ Using direct label name:', labelName);
                            }
                            break;
                        }
                    }
                }
                
                console.log('üéµ Final label name selected:', labelName);
                
                // Clean up the string key for URL (from audio-previewer logic)
                console.log('üéµ STRING CLEANING DEBUG:');
                console.log('  - Original stringKey:', JSON.stringify(stringKey));
                console.log('  - Is identifier?:', stringKey === context.identifier);
                
                let cleanStringKey;
                if (stringKey === context.identifier) {
                    // If using identifier, it's probably already clean (like "ToM-scene-16-q4-reference")
                    // Just convert to lowercase and replace underscores with hyphens for consistency
                    cleanStringKey = stringKey.toLowerCase().replace(/_/g, '-');
                    console.log('  - Using identifier format (minimal cleaning)');
                } else {
                    // If using text content, apply full cleaning
                    cleanStringKey = stringKey
                        .toLowerCase()
                        .replace(/[^a-z0-9]+/g, '-')
                        .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens
                    console.log('  - Using text content (full cleaning)');
                }
                
                console.log('  - After cleaning processing:', cleanStringKey);
                console.log('  - Final cleanStringKey:', JSON.stringify(cleanStringKey));
                console.log('  - cleanStringKey length:', cleanStringKey.length);
                
                // Build multiple URL patterns to try (exact logic from audio-previewer)
                const baseUrl = 'https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files';
                const urlPatterns = [];
                
                // Helper function to get language variants (from audio-previewer)
                function getLanguageVariants(lang) {
                    const variants = {
                        'es': ['es', 'es-CO'], // Spanish: try both generic and Colombian
                        'en': ['en', 'en-US'],
                        'fr': ['fr', 'fr-CA'], // French: try both generic and Canadian
                        'pt': ['pt', 'pt-BR'],
                        'de': ['de', 'de-DE'], // German: try both generic and German-Germany
                        'nl': ['nl', 'nl-NL', 'nl-BE'] // Dutch: try generic, Netherlands, and Belgium
                    };
                    return variants[lang] || [lang];
                }
                
                const languageVariants = getLanguageVariants(languageCode);
                console.log('üéµ Will try language variants:', languageVariants);
                
                // Try each language variant
                for (const langVariant of languageVariants) {
                    // Primary patterns with detected label (highest priority)
                    if (labelName && labelName !== 'general') {
                        urlPatterns.push(`${baseUrl}/${labelName}/${langVariant}/shared/${cleanStringKey}.mp3`);
                        urlPatterns.push(`${baseUrl}/${labelName}/${langVariant}/shared/${stringKey.toLowerCase().replace(/\s+/g, '-')}.mp3`);
                        urlPatterns.push(`${baseUrl}/${labelName}/${langVariant}/shared/${stringKey.toLowerCase().replace(/[^a-z0-9]+/g, '_')}.mp3`);
                    }
                    
                    // Fallback patterns with 'general' (lower priority)
                    urlPatterns.push(`${baseUrl}/general/${langVariant}/shared/${cleanStringKey}.mp3`);
                    urlPatterns.push(`${baseUrl}/general/${langVariant}/shared/${stringKey.toLowerCase().replace(/\s+/g, '-')}.mp3`);
                    
                    // Try without label subdirectory (even lower priority)
                    urlPatterns.push(`${baseUrl}/${langVariant}/shared/${cleanStringKey}.mp3`);
                    
                    // Last resort patterns
                    if (labelName && labelName !== 'general') {
                        urlPatterns.push(`${baseUrl}/${labelName}/${langVariant}/shared/${stringKey}.mp3`);
                    }
                    urlPatterns.push(`${baseUrl}/general/${langVariant}/shared/${stringKey}.mp3`);
                }
                
                console.log('üéµ Will try audio URLs:', urlPatterns);
                console.log('üéµ URL components:', { labelName, languageCode, cleanStringKey, originalStringKey: stringKey });
                
                // Try each URL pattern until one works (from audio-previewer logic)
                for (let i = 0; i < urlPatterns.length; i++) {
                    const audioUrl = urlPatterns[i];
                    console.log(`üéµ Trying URL ${i + 1}/${urlPatterns.length}:`, audioUrl);
                    
                    try {
                        const audio = new Audio(audioUrl);
                        
                        // Test if the audio file can be loaded
                        await new Promise((resolve, reject) => {
                            const timeout = setTimeout(() => reject(new Error('Timeout')), 5000);
                            
                            audio.addEventListener('loadeddata', () => {
                                clearTimeout(timeout);
                                resolve();
                            });
                            
                            audio.addEventListener('error', () => {
                                clearTimeout(timeout);
                                reject(new Error('Audio load failed'));
                            });
                            
                            audio.load();
                        });
                        
                        console.log('‚úÖ Found audio file:', audioUrl);
                        
                        // Play the audio
                        await new Promise((resolve, reject) => {
                            audio.addEventListener('ended', resolve);
                            audio.addEventListener('error', reject);
                            audio.play().catch(reject);
                        });
                        
                        showStatus('Audio playback complete', 'success');
                        return; // Success, exit the function
                        
                    } catch (error) {
                        console.log(`‚ùå URL ${i + 1} failed:`, error.message);
                        continue; // Try the next URL
                    }
                }
                
                // If we get here, no audio files were found
                showStatus('No existing audio file found for this text', 'error');
                console.log('‚ùå No audio files found for:', { stringKey, languageCode, labelName, cleanStringKey });
                
            } catch (error) {
                console.error('Error in playCurrentAudio:', error);
                showStatus(`Error playing audio: ${error.message}`, 'error');
            }
        }

        // Credential Management Functions (based on levante_translations/dashboard.js)
        function saveCredentials() {
            const credentials = {
                playhtApiKey: document.getElementById('playhtApiKey').value,
                playhtUserId: document.getElementById('playhtUserId').value,
                elevenlabsApiKey: document.getElementById('elevenlabsApiKey').value
            };

            // Save to localStorage with multiple backup keys (same as dashboard.js)
            localStorage.setItem('PLAY_DOT_HT_API_KEY', credentials.playhtApiKey);
            localStorage.setItem('playht_api_key', credentials.playhtApiKey);
            localStorage.setItem('PLAYHT_API_KEY', credentials.playhtApiKey);
            localStorage.setItem('PLAY_DOT_HT_USER_ID', credentials.playhtUserId);
            localStorage.setItem('playht_user_id', credentials.playhtUserId);
            localStorage.setItem('PLAYHT_USER_ID', credentials.playhtUserId);
            localStorage.setItem('ELEVENLABS_API_KEY', credentials.elevenlabsApiKey);
            localStorage.setItem('elevenlabs_api_key', credentials.elevenlabsApiKey);
            localStorage.setItem('ELEVEN_LABS_API_KEY', credentials.elevenlabsApiKey);

            // Also save to sessionStorage as backup
            sessionStorage.setItem('PLAY_DOT_HT_API_KEY', credentials.playhtApiKey);
            sessionStorage.setItem('PLAY_DOT_HT_USER_ID', credentials.playhtUserId);
            sessionStorage.setItem('ELEVENLABS_API_KEY', credentials.elevenlabsApiKey);

            // Update the audio manager's API config
            audioManager.apiConfig.playht.apiKey = credentials.playhtApiKey;
            audioManager.apiConfig.playht.userId = credentials.playhtUserId;
            audioManager.apiConfig.elevenlabs.apiKey = credentials.elevenlabsApiKey;

            updateCredentialStatus();
            showStatus('Credentials saved successfully with backup storage!', 'success');
            
            // Close the modal
            document.getElementById('credentialsModal').style.display = 'none';
        }

        function loadCredentials() {
            // Reload credentials in AudioManager first
            audioManager.loadCredentials();

            // Update form fields with the loaded credentials
            document.getElementById('playhtApiKey').value = audioManager.apiConfig.playht.apiKey || '';
            document.getElementById('playhtUserId').value = audioManager.apiConfig.playht.userId || '';
            document.getElementById('elevenlabsApiKey').value = audioManager.apiConfig.elevenlabs.apiKey || '';

            updateCredentialStatus();
        }

        function recoverCredentials() {
            // Try to recover from all possible storage locations
            const sources = [
                { name: 'localStorage', storage: localStorage },
                { name: 'sessionStorage', storage: sessionStorage }
            ];

            const keys = [
                { api: 'playht_key', variants: ['PLAY_DOT_HT_API_KEY', 'playht_api_key', 'PLAYHT_API_KEY'] },
                { api: 'playht_user', variants: ['PLAY_DOT_HT_USER_ID', 'playht_user_id', 'PLAYHT_USER_ID'] },
                { api: 'elevenlabs', variants: ['ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY'] }
            ];

            let recovered = { playht_key: '', playht_user: '', elevenlabs: '' };
            let recoveryCount = 0;

            sources.forEach(source => {
                keys.forEach(keyGroup => {
                    if (!recovered[keyGroup.api]) {
                        keyGroup.variants.forEach(variant => {
                            const value = source.storage.getItem(variant);
                            if (value && value.length > 10) {
                                recovered[keyGroup.api] = value;
                                recoveryCount++;
                            }
                        });
                    }
                });
            });

            if (recoveryCount > 0) {
                document.getElementById('playhtApiKey').value = recovered.playht_key;
                document.getElementById('playhtUserId').value = recovered.playht_user;
                document.getElementById('elevenlabsApiKey').value = recovered.elevenlabs;
                
                updateCredentialStatus();
                showStatus(`Recovered ${recoveryCount} credential(s) from backup storage!`, 'success');
            } else {
                showStatus('No backup credentials found in storage.', 'error');
            }
        }

        function clearCredentials() {
            if (confirm('Are you sure you want to clear all stored credentials?')) {
                // Clear from all storage locations
                const keys = [
                    'PLAY_DOT_HT_API_KEY', 'playht_api_key', 'PLAYHT_API_KEY',
                    'PLAY_DOT_HT_USER_ID', 'playht_user_id', 'PLAYHT_USER_ID',
                    'ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY'
                ];

                keys.forEach(key => {
                    localStorage.removeItem(key);
                    sessionStorage.removeItem(key);
                });

                // Clear form fields
                document.getElementById('playhtApiKey').value = '';
                document.getElementById('playhtUserId').value = '';
                document.getElementById('elevenlabsApiKey').value = '';

                // Clear audio manager config
                audioManager.apiConfig.playht.apiKey = null;
                audioManager.apiConfig.playht.userId = null;
                audioManager.apiConfig.elevenlabs.apiKey = null;

                updateCredentialStatus();
                showStatus('All credentials cleared successfully.', 'success');
            }
        }

        function updateCredentialStatus() {
            const playhtKey = audioManager.apiConfig.playht.apiKey;
            const playhtUser = audioManager.apiConfig.playht.userId;
            const elevenlabsKey = audioManager.apiConfig.elevenlabs.apiKey;

            document.getElementById('playhtKeyStatus').textContent = 
                playhtKey && playhtKey.length > 10 ? '‚úÖ Present' : '‚ùå Not Set';
            document.getElementById('playhtKeyStatus').className = 
                playhtKey && playhtKey.length > 10 ? 'status-indicator present' : 'status-indicator missing';

            document.getElementById('playhtUserStatus').textContent = 
                playhtUser && playhtUser.length > 10 ? '‚úÖ Present' : '‚ùå Not Set';
            document.getElementById('playhtUserStatus').className = 
                playhtUser && playhtUser.length > 10 ? 'status-indicator present' : 'status-indicator missing';

            document.getElementById('elevenlabsKeyStatus').textContent = 
                elevenlabsKey && elevenlabsKey.length > 10 ? '‚úÖ Present' : '‚ùå Not Set';
            document.getElementById('elevenlabsKeyStatus').className = 
                elevenlabsKey && elevenlabsKey.length > 10 ? 'status-indicator present' : 'status-indicator missing';
        }

        function showCredentialsModal() {
            console.log('üîß MODAL: showCredentialsModal() called');
            console.trace('üîß MODAL: Call stack for showCredentialsModal');
            loadCredentials(); // Load current credentials
            document.getElementById('credentialsModal').style.display = 'block';
        }

        function closeCredentialsModal() {
            console.log('üîß MODAL: closeCredentialsModal() called');
            document.getElementById('credentialsModal').style.display = 'none';
        }

        // Manual credential testing function (call from browser console)
        window.testCredentials = function() {
            console.log('=== MANUAL CREDENTIAL TEST ===');
            
            // Test all possible credential keys
            const allKeys = [
                'PLAY_DOT_HT_API_KEY', 'playht_api_key', 'PLAYHT_API_KEY',
                'PLAY_DOT_HT_USER_ID', 'playht_user_id', 'PLAYHT_USER_ID',
                'ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY'
            ];
            
            console.log('Testing localStorage:');
            allKeys.forEach(key => {
                const value = localStorage.getItem(key);
                console.log(`  ${key}: ${value ? `Present (${value.length} chars)` : 'Missing'}`);
            });
            
            console.log('Testing sessionStorage:');
            allKeys.forEach(key => {
                const value = sessionStorage.getItem(key);
                console.log(`  ${key}: ${value ? `Present (${value.length} chars)` : 'Missing'}`);
            });
            
            // Show current domain/origin
            console.log('Current domain:', window.location.origin);
            console.log('Current hostname:', window.location.hostname);
            
            // Force reload credentials
            audioManager.loadCredentials();
            console.log('AudioManager credentials after reload:', {
                playht: audioManager.apiConfig.playht.apiKey ? `Present (${audioManager.apiConfig.playht.apiKey.length} chars)` : 'Missing',
                playhtUser: audioManager.apiConfig.playht.userId ? `Present (${audioManager.apiConfig.playht.userId.length} chars)` : 'Missing',
                elevenlabs: audioManager.apiConfig.elevenlabs.apiKey ? `Present (${audioManager.apiConfig.elevenlabs.apiKey.length} chars)` : 'Missing'
            });
            console.log('=== END MANUAL TEST ===');
        };

        // Manual debug function for testing context extraction
        window.debugContext = function() {
            console.log('=== CONTEXT DEBUG ===');
            console.log('üìã receivedContext:', JSON.stringify(receivedContext, null, 2));
            console.log('üìã getEnhancedCrowdinContext():', JSON.stringify(getEnhancedCrowdinContext(), null, 2));
            console.log('üìã URL params:', Object.fromEntries(new URLSearchParams(window.location.search)));
            
            // Test the playCurrentAudio logic manually
            const context = getEnhancedCrowdinContext();
            const stringKey = context.targetString || context.sourceString || context.stringKey || context.key || context.identifier;
            const languageCode = context.targetLanguageId || context.sourceLanguageId || context.languageId || 'en';
            
            console.log('üìã Extracted for audio:', { stringKey, languageCode });
            console.log('=== END DEBUG ===');
        };
        
        // Simple debug function for testing context
        window.checkContext = function() {
            console.log('=== CONTEXT CHECK ===');
            console.log('receivedContext:', receivedContext);
            const enhanced = getEnhancedCrowdinContext();
            console.log('getEnhancedCrowdinContext():', enhanced);
            const stringKey = enhanced.targetString || enhanced.sourceString || enhanced.stringKey;
            console.log('Extracted text for audio:', stringKey);
            console.log('=== END CHECK ===');
        };
        
        console.log('üí° To debug context manually, run: debugContext()');
        console.log('üöÄ App loaded at:', new Date().toISOString());

        // Initialize credentials and context on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ DOM Content Loaded - Initializing app...');
            
            // Initialize Crowdin context detection
            initializeContext();
            
            // Force reload credentials from storage
            audioManager.loadCredentials();
            loadCredentials();
            updateCredentialStatus();
            
            // Log current credentials for debugging
            console.log('Initialized credentials:', {
                playht: audioManager.apiConfig.playht.apiKey ? 'Present' : 'Missing',
                playhtUser: audioManager.apiConfig.playht.userId ? 'Present' : 'Missing', 
                elevenlabs: audioManager.apiConfig.elevenlabs.apiKey ? 'Present' : 'Missing'
            });
            
            // Add click event listeners with debugging
            const playBtn = document.getElementById('playAudioBtn');
            const generateBtn = document.getElementById('generateAudioBtn');
            const refreshBtn = document.getElementById('refreshBtn');
            
            if (playBtn) {
                playBtn.addEventListener('click', function() {
                    console.log('üéµ Play button clicked!');
                    playCurrentAudio();
                });
                console.log('‚úÖ Play button event listener added');
            } else {
                console.error('‚ùå Play button not found!');
            }
            
            if (generateBtn) {
                generateBtn.addEventListener('click', function() {
                    console.log('üé§ Generate button clicked!');
                    showAudioGeneration();
                });
                console.log('‚úÖ Generate button event listener added');
            } else {
                console.error('‚ùå Generate button not found!');
            }
            
            if (refreshBtn) {
                refreshBtn.addEventListener('click', function() {
                    console.log('üîÑ Refresh button clicked!');
                    refreshContext();
                });
                console.log('‚úÖ Refresh button event listener added');
            } else {
                console.error('‚ùå Refresh button not found!');
            }
            
            // Show instruction for manual testing
            console.log('üí° To manually test credentials, run: testCredentials()');
            console.log('üéØ App initialization complete!');
            
            // Let Crowdin handle iframe sizing automatically
        });

        // Debug function to check and force close modal
        window.debugModal = function() {
            const modal = document.getElementById('credentialsModal');
            const audioGen = document.getElementById('audioGeneration');
            const status = document.getElementById('status');
            
            console.log('üîß MODAL DEBUG:', {
                modal_display: modal ? modal.style.display : 'not found',
                audioGen_display: audioGen ? audioGen.style.display : 'not found',
                status_display: status ? status.style.display : 'not found',
                modal_visible: modal ? getComputedStyle(modal).display : 'not found'
            });
            
            return {
                modal: modal ? modal.style.display : 'not found',
                audioGen: audioGen ? audioGen.style.display : 'not found',
                status: status ? status.style.display : 'not found'
            };
        };
        
        // Force close all overlays
        window.forceCloseAll = function() {
            console.log('üîß FORCE CLOSING all overlays...');
            const modal = document.getElementById('credentialsModal');
            const audioGen = document.getElementById('audioGeneration');
            const status = document.getElementById('status');
            
            if (modal) {
                modal.style.display = 'none';
                console.log('üîß Closed credentials modal');
            }
            if (audioGen) {
                audioGen.style.display = 'none';
                console.log('üîß Closed audio generation');
            }
            if (status) {
                status.style.display = 'none';
                console.log('üîß Closed status');
            }
            
            console.log('üîß All overlays closed');
        };
    </script>
</body>
</html> 