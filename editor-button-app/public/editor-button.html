<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Levante Audio Test</title>
    <script src="https://cdn.crowdin.com/apps/dist/iframe.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 5px;
            background: #f8f9fa;
            color: #333;
            font-size: 12px;
            line-height: 1.3;
            min-height: 150px;
            height: auto;
            overflow-y: auto;
        }
        
        .container {
            background: white;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 120px;
            height: auto;
        }
        
        h1 {
            margin: 0 0 6px 0;
            font-size: 14px;
            color: #2c5aa0;
            font-weight: 600;
        }
        
        .button-group {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: background-color 0.2s;
            flex: 1;
            min-width: 90px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .audio-section {
            margin-top: 8px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fafafa;
        }
        
        .dropdowns-row {
            display: flex;
            gap: 12px;
            margin-bottom: 8px;
            align-items: end;
        }
        
        .dropdown-group {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        

        
        .dropdown-group label {
            font-size: 10px;
            margin-bottom: 2px;
            color: #666;
            font-weight: 500;
        }
        
        .dropdown-group select {
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 11px;
            background: white;
        }
        
        .audio-buttons {
            display: flex;
            gap: 4px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }
        
        .audio-btn {
            font-size: 10px;
            padding: 4px 8px;
            min-width: 70px;
            flex: 1;
        }
        
        .form-row {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        label {
            font-weight: 500;
            font-size: 10px;
            color: #495057;
            white-space: nowrap;
        }
        
        select {
            flex: 1;
            padding: 3px 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 10px;
            min-width: 80px;
        }
        
        .status {
            margin-top: 6px;
            padding: 4px 6px;
            background: #e9ecef;
            border-radius: 3px;
            font-size: 10px;
            word-wrap: break-word;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 4px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Modal Styles - Compact */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 12px;
            border-radius: 6px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal h2 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #2c5aa0;
        }
        
        .modal label {
            display: block;
            margin: 6px 0 3px 0;
            font-size: 11px;
        }
        
        .modal input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 11px;
            box-sizing: border-box;
        }
        
        .modal-buttons {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        
        .close:hover {
            color: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="button-group">
            <div class="audio-section">
                <div class="audio-buttons">
                    <button id="playAudioBtn" class="audio-btn">
                        üéµ Play Current Audio
            </button>
                    <button id="previewBtn" class="audio-btn" style="background: #28a745;">
                        üéß Preview Translation
            </button>
                    <button id="configBtn" class="audio-btn" style="background: #6c757d;" onclick="showCredentialsModal()">
                        ‚öôÔ∏è API Settings
            </button>
                    <button id="generateAudioBtn" class="audio-btn" style="display: none;">
                        üé§ Generate New Audio
            </button>
                    <button id="refreshBtn" class="audio-btn" style="display: none;">
                        üîÑ Refresh Context
            </button>
                </div>
                <div id="autoPlayContainer" style="margin-top: 8px; padding: 6px; background: #f8f9fa; border-radius: 4px;">
                    <label style="color: #555; font-size: 12px; display: flex; align-items: center; gap: 6px;">
                        <input type="checkbox" id="autoPlayCheckbox"> 
                        <span>üéµ Auto-play on string selection</span>
                    </label>
                </div>
                <div id="audioGeneration" style="display: none;">
                    <div class="audio-section">
                        <div class="dropdowns-row">
                            <div class="dropdown-group">
                                <select id="serviceSelect" onchange="onServiceChange()">
                                    <option value="">Select Service</option>
                                    <option value="PlayHT">PlayHT</option>
                                    <option value="ElevenLabs">ElevenLabs</option>
                                </select>
                            </div>
                            <div class="dropdown-group">
                                <select id="voiceSelect" onchange="onVoiceChange()">
                                    <option value="">Select Voice</option>
                                </select>
                            </div>

                        </div>
                        <div class="audio-buttons">
                            <button id="generateBtn" onclick="generateAudio()" class="audio-btn" disabled>Generate</button>
                            <button onclick="hideAudioGeneration()" class="audio-btn">Close</button>
                            <button onclick="showCredentialsModal()" class="audio-btn">API Settings</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
    </div>

    <!-- Credentials Modal -->
    <div id="credentialsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üîë API Credentials</h2>
                <span class="close" onclick="closeCredentialsModal()">&times;</span>
            </div>
            <div class="credentials-form">
                <div class="credential-group">
                    <label for="playhtApiKey">PlayHT API Key:</label>
                    <input type="text" id="playhtApiKey" placeholder="Enter PlayHT API Key">
                    
                    <label for="playhtUserId">PlayHT User ID:</label>
                    <input type="text" id="playhtUserId" placeholder="Enter PlayHT User ID">
                    
                    <label for="elevenlabsApiKey">ElevenLabs API Key:</label>
                    <input type="text" id="elevenlabsApiKey" placeholder="Enter ElevenLabs API Key">
                </div>
                <div class="credentials-buttons">
                    <button onclick="saveCredentials()" class="btn btn-primary">
                        üíæ Save Credentials
                    </button>
                    <button onclick="recoverCredentials()" class="btn btn-success">
                        üîÑ Recover Credentials
                    </button>
                    <button onclick="clearCredentials()" class="btn btn-secondary">
                        üóëÔ∏è Clear All
                    </button>
                </div>
                <div class="credential-status" id="credentialStatus">
                    <p><strong>Current Status:</strong></p>
                    <div class="status-grid">
                        <div class="status-item">
                            <span class="status-label">PlayHT API Key:</span>
                            <span id="playhtKeyStatus" class="status-indicator">‚ùå Not Set</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">PlayHT User ID:</span>
                            <span id="playhtUserStatus" class="status-indicator">‚ùå Not Set</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">ElevenLabs API Key:</span>
                            <span id="elevenlabsKeyStatus" class="status-indicator">‚ùå Not Set</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced context detection using Crowdin AP API
        function getCrowdinContext() {
            const urlParams = new URLSearchParams(window.location.search);
            const context = {};
            
            // Standard Crowdin parameters from URL
            const crowdinParams = [
                'projectId', 'fileId', 'stringId', 'languageId', 'userId', 'mode',
                'stringKey', 'identifier', 'key', 'sourceString', 'targetString',
                'context', 'maxLength', 'isPlural', 'pluralForm', 'origin', 'client_id', 'clientId', 'jwtToken'
            ];
            
            crowdinParams.forEach(param => {
                const value = urlParams.get(param);
                if (value) {
                    context[param] = value;
                }
            });
            
            // Use Crowdin AP API if available (proper way to access context)
            if (typeof AP !== 'undefined') {
                console.log('üéØ Crowdin AP API is available, requesting context...');
                
                // PRIORITY METHOD: Get current language directly (most reliable for comfortable view)
                if (AP.context && AP.context.getCurrentLanguage) {
                    AP.context.getCurrentLanguage(function(languageData) {
                        console.log('üåç === CURRENT LANGUAGE API DEBUG ===');
                        console.log('üåç AP.context.getCurrentLanguage result:', languageData);
                        console.log('üåç Raw languageData object:', JSON.stringify(languageData, null, 2));
                        
                        if (languageData && languageData.id) {
                            receivedContext.targetLanguageId = languageData.id;
                            receivedContext.targetLanguageName = languageData.name;
                            receivedContext.languageCode = languageData.locale || languageData.id;
                            
                            console.log('üåç ‚úÖ DIRECT LANGUAGE DETECTION SUCCESS:');
                            console.log('  - Language ID:', languageData.id);
                            console.log('  - Language Name:', languageData.name);
                            console.log('  - Language Locale:', languageData.locale);
                            console.log('  - Full languageData:', languageData);
                            console.log('üåç === END CURRENT LANGUAGE API DEBUG ===');
                        } else {
                            console.log('üåç ‚ùå No valid language data received from getCurrentLanguage API');
                        }
                    });
                }
                
                // Request current string context
                if (AP.editor && AP.editor.getCurrentString) {
                    AP.editor.getCurrentString(function(stringData) {
                        console.log('üéØ AP.editor.getCurrentString result:', stringData);
                        if (stringData) {
                            receivedContext = { ...receivedContext, ...stringData };
                        }
                    });
                }
                
                // Request general context
                if (AP.context && AP.context.getContext) {
                    AP.context.getContext(function(contextData) {
                        console.log('üéØ === CONTEXT API DEBUG ===');
                        console.log('üéØ AP.context.getContext result:', contextData);
                        console.log('üéØ Raw context object:', JSON.stringify(contextData, null, 2));
                        
                        if (contextData) {
                            receivedContext = { ...receivedContext, ...contextData };
                            
                            // Extract language info from context if available
                            if (contextData.languageId) {
                                receivedContext.targetLanguageId = contextData.languageId;
                                receivedContext.languageCode = contextData.languageId;
                                console.log('üåç ‚úÖ LANGUAGE FROM CONTEXT:', contextData.languageId);
                            }
                            
                            // Check for other language-related fields
                            if (contextData.targetLanguageId) {
                                receivedContext.targetLanguageId = contextData.targetLanguageId;
                                receivedContext.languageCode = contextData.targetLanguageId;
                                console.log('üåç ‚úÖ TARGET LANGUAGE FROM CONTEXT:', contextData.targetLanguageId);
                            }
                            
                            if (contextData.language) {
                                console.log('üåç ‚úÖ LANGUAGE OBJECT FROM CONTEXT:', contextData.language);
                                if (contextData.language.id) {
                                    receivedContext.targetLanguageId = contextData.language.id;
                                    receivedContext.languageCode = contextData.language.id;
                                }
                            }
                        }
                        console.log('üéØ === END CONTEXT API DEBUG ===');
                    });
                }
                
                // Request current translation
                if (AP.editor && AP.editor.getCurrentTranslation) {
                    AP.editor.getCurrentTranslation(function(translationData) {
                        console.log('üéØ === TRANSLATION API DEBUG ===');
                        console.log('üéØ AP.editor.getCurrentTranslation result:', translationData);
                        console.log('üéØ Raw translation object:', JSON.stringify(translationData, null, 2));
                        
                        if (translationData) {
                            receivedContext = { ...receivedContext, ...translationData };
                            
                            // Extract language from translation data
                            if (translationData.languageId) {
                                receivedContext.targetLanguageId = translationData.languageId;
                                receivedContext.languageCode = translationData.languageId;
                                console.log('üåç ‚úÖ LANGUAGE FROM TRANSLATION:', translationData.languageId);
                            }
                            
                            if (translationData.targetLanguageId) {
                                receivedContext.targetLanguageId = translationData.targetLanguageId;
                                receivedContext.languageCode = translationData.targetLanguageId;
                                console.log('üåç ‚úÖ TARGET LANGUAGE FROM TRANSLATION:', translationData.targetLanguageId);
                            }
                        }
                        console.log('üéØ === END TRANSLATION API DEBUG ===');
                    });
                }
                
                // Try additional API methods for language detection
                if (AP.editor && AP.editor.getLanguage) {
                    AP.editor.getLanguage(function(langData) {
                        console.log('üéØ === EDITOR LANGUAGE API DEBUG ===');
                        console.log('üéØ AP.editor.getLanguage result:', langData);
                        console.log('üéØ Raw editor language object:', JSON.stringify(langData, null, 2));
                        
                        if (langData) {
                            if (langData.id) {
                                receivedContext.targetLanguageId = langData.id;
                                receivedContext.languageCode = langData.id;
                                console.log('üåç ‚úÖ LANGUAGE FROM EDITOR:', langData.id);
                            }
                        }
                        console.log('üéØ === END EDITOR LANGUAGE API DEBUG ===');
                    });
                }
                
                // Try to get project info which may contain language data
                if (AP.context && AP.context.getProject) {
                    AP.context.getProject(function(projectData) {
                        console.log('üéØ === PROJECT API DEBUG ===');
                        console.log('üéØ AP.context.getProject result:', projectData);
                        console.log('üéØ Raw project object:', JSON.stringify(projectData, null, 2));
                        
                        if (projectData) {
                            if (projectData.targetLanguages) {
                                console.log('üåç ‚úÖ TARGET LANGUAGES FROM PROJECT:', projectData.targetLanguages);
                            }
                            if (projectData.currentLanguage) {
                                receivedContext.targetLanguageId = projectData.currentLanguage;
                                receivedContext.languageCode = projectData.currentLanguage;
                                console.log('üåç ‚úÖ CURRENT LANGUAGE FROM PROJECT:', projectData.currentLanguage);
                            }
                        }
                        console.log('üéØ === END PROJECT API DEBUG ===');
                    });
                }
            } else {
                console.log('üéØ Crowdin AP API not available, using fallback methods...');
                
                // Fallback: Try to get context from parent window if in iframe (without accessing cross-origin properties)
                if (window.parent && window.parent !== window) {
                    try {
                        // Request context from parent via postMessage (safe cross-origin method)
                    window.parent.postMessage({
                        type: 'request-context',
                        source: 'crowdin-app'
                    }, '*');
                } catch (e) {
                    console.log('Cannot send postMessage to parent');
                }
            }
            }
            
            return context;
        }
        

        
        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
            
            if (type !== 'loading') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        }
        

        
        // Function to actively request context from Crowdin - ENHANCED for side-by-side mode
        function requestCrowdinContext() {
            console.log('üîÑ REQUESTING CONTEXT from Crowdin...');
            
            if (window.parent && window.parent !== window) {
                // Try multiple message types that Crowdin might respond to
                const messages = [
                    { type: 'get-context' },
                    { type: 'request-context' },
                    { type: 'app-ready' },
                    { type: 'get-editor-context' },
                    { type: 'get-string-context' },
                    { type: 'get-current-string' },
                    { type: 'request-current-string' },
                    { type: 'get-translation-context' },
                    { action: 'getContext' },
                    { action: 'getCurrentString' },
                    { action: 'getTranslationContext' },
                    { action: 'requestContext' },
                    // Try some side-by-side specific requests
                    { type: 'get-active-string' },
                    { type: 'request-active-string' },
                    { action: 'getActiveString' }
                ];
                
                console.log(`üîÑ Sending ${messages.length} context request messages...`);
                messages.forEach((message, index) => {
                    try {
                        window.parent.postMessage(message, '*');
                        console.log(`üì§ Sent message ${index + 1}:`, message);
                    } catch (e) {
                        console.log('Failed to send message:', message, e);
                    }
                });
                
                // Also try to trigger events that might cause Crowdin to send us data
                setTimeout(() => {
                    console.log('üîÑ Sending follow-up context requests...');
                    const followUpMessages = [
                        { type: 'ping' },
                        { type: 'ready' },
                        { type: 'request-state' }
                    ];
                    
                    followUpMessages.forEach(message => {
                        try {
                            window.parent.postMessage(message, '*');
                        } catch (e) {
                            console.log('Failed to send follow-up message:', message);
                        }
                    });
                }, 500);
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Crowdin context detection
            initializeContext();
        });
        
        // Store received context data
        let receivedContext = {};
        
        // Fetch string details from Crowdin API when identifier is missing
        async function fetchStringIdentifierFromAPI(stringId, projectId) {
            console.log('üîç Attempting to fetch string identifier from Crowdin API:', { stringId, projectId });
            
            if (!stringId) {
                console.warn('‚ö†Ô∏è No stringId provided for API fetch');
                return null;
            }
            
            try {
                // We'll need to implement a proxy endpoint for this since we can't make direct API calls from the browser
                // This is what the API call would look like:
                console.log('üìã API call needed: GET /api/v2/projects/{projectId}/strings/{stringId}');
                console.log('üìã With proper authentication headers');
                console.log('üìã Expected response: { "data": { "id": 123, "identifier": "welcome_message", "text": "..." } }');
                
                // For now, we'll log what we need to implement
                console.warn('‚ö†Ô∏è Crowdin API proxy not yet implemented');
                console.log('üí° To implement: Create /api/crowdin-proxy endpoint that makes authenticated requests to Crowdin API');
                
                // Try to make the actual API call to fetch string details
                try {
                    // First, we need to get the Crowdin API token from credentials
                    const credentials = JSON.parse(localStorage.getItem('crowdin_credentials') || '{}');
                    const crowdinToken = credentials.crowdinApiToken || credentials.crowdin_api_token;
                    
                    if (!crowdinToken) {
                        console.warn('‚ö†Ô∏è No Crowdin API token found in credentials');
                        return null;
                    }
                    
                    const response = await fetch(`/api/crowdin/projects/${projectId}/strings/${stringId}`, {
                        method: 'GET',
                    headers: {
                            'Authorization': `Bearer ${crowdinToken}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API call failed: ${response.status}`);
                    }
                
                const result = await response.json();
                    if (result.success && result.identifier) {
                        console.log('‚úÖ Successfully fetched identifier from Crowdin API:', result.identifier);
                        return result.identifier;
                    } else {
                        console.warn('‚ö†Ô∏è API call succeeded but no identifier found');
                        return null;
                    }
                } catch (apiError) {
                    console.warn('‚ö†Ô∏è API call failed, will use fallback:', apiError.message);
                    // Fall through to return null and use fallback
                }
                
                return null;
            } catch (error) {
                console.error('‚ùå Failed to fetch string identifier from API:', error);
                return null;
            }
        }

        // Simple webhook-style message handler for immediate audio playback
        async function enhancedMessageHandler(event) {
            // Only process messages from Crowdin origins
            if (!event.origin || !event.origin.includes('crowdin.com')) {
                return;
            }
            
            console.log('üì® Received message from Crowdin:', JSON.stringify({
                origin: event.origin,
                type: event.data?.type,
                etyp: event.data?.etyp
            }, null, 2));
            
            // WEBHOOK-STYLE: Auto-play when string.selected with translation
            if (event.data && event.data.type === 'evt' && event.data.etyp === 'string.selected' && 
                event.data.evnt && event.data.evnt.length > 0) {
                
                // Check if auto-play is enabled
                const autoPlayCheckbox = document.getElementById('autoPlayCheckbox');
                if (!autoPlayCheckbox || !autoPlayCheckbox.checked) {
                    console.log('üéµ WEBHOOK: Auto-play disabled, storing context for manual play');
                    // Fall through to normal context processing
                } else {
                    const stringInfo = event.data.evnt[0];
                    if (stringInfo.translations && Object.keys(stringInfo.translations).length > 0) {
                        console.log('üéµ WEBHOOK: Auto-playing audio for selected string with translations');
                    
                    // Find the first available translation
                    for (const [langCode, translationArray] of Object.entries(stringInfo.translations)) {
                        if (translationArray && Array.isArray(translationArray) && translationArray.length > 0) {
                            const translation = translationArray[0];
                            if (translation && translation.text) {
                                console.log(`üéµ WEBHOOK: Found ${langCode} translation, playing audio`);
                                
                                // Map language for GCP bucket
                                const gcpLangCode = mapLanguageCodeForGCP(langCode);
                                const itemId = stringInfo.string.identifier;
                                
                                if (itemId) {
                                    // Play immediately
                                    playExistingAudioFromGCP(itemId, gcpLangCode);
                                    return; // Exit early, don't process as normal context
                                }
                                break;
                            }
                        }
                    }
                }
                }
            }
            
            // Handle different types of messages from Crowdin for fallback context
            if (event.data) {
                console.log('üîç Checking event data:', {
                    type: event.data.type,
                    etyp: event.data.etyp,
                    hasEvnt: !!event.data.evnt
                });
                
                // Handle string.selected and string.change events directly
                if (event.data.type === 'evt') {
                    // Handle string selection (primary method)
                    if (event.data.etyp === 'string.selected' && event.data.evnt && event.data.evnt.length > 0) {
                        console.log('üéØ PROCESSING string.selected event');
                        const stringInfo = event.data.evnt[0];
                        const stringData = stringInfo.string;
                        const translations = stringInfo.translations;
                        
                        // Check if this is a different string (different ID)
                        const isDifferentString = receivedContext.stringId !== stringData.id;
                        
                        console.log('üîÑ String selection analysis:', {
                            oldStringId: receivedContext.stringId,
                            newStringId: stringData.id,
                            isDifferentString: isDifferentString,
                            oldIdentifier: receivedContext.identifier,
                            newIdentifier: stringData.identifier
                        });
                        
                        // If it's a different string, reset the context completely
                        if (isDifferentString) {
                            console.log('üÜï Different string selected, resetting context completely');
                            receivedContext = { origin: receivedContext.origin }; // Clear everything but preserve origin
                        }
                        
                        receivedContext.stringId = stringData.id;
                        receivedContext.stringKey = stringData.text;
                        receivedContext.sourceString = stringData.text;
                        receivedContext.targetString = stringData.text;
                        receivedContext.identifier = stringData.identifier;
                        receivedContext.fileId = stringData.file?.id;
                        
                        // Extract additional context that might contain project info
                        if (stringInfo.context) {
                            receivedContext.projectId = stringInfo.context.projectId;
                        }
                        
                        // Try to extract project ID from various sources
                        if (!receivedContext.projectId) {
                            // Try to get from URL if we're in an iframe
                            try {
                                const parentUrl = window.parent?.location?.href || window.location.href;
                                const projectIdMatch = parentUrl.match(/\/project\/(\d+)/);
                                if (projectIdMatch) {
                                    receivedContext.projectId = projectIdMatch[1];
                                    console.log('üîç Extracted project ID from URL:', receivedContext.projectId);
                        }
                    } catch (e) {
                                console.log('üîç Could not access parent URL for project ID extraction');
                            }
                            
                            // Try to get from AP API context if available
                            if (typeof AP !== 'undefined' && AP.context) {
                                AP.context.getContext(function(contextData) {
                                    if (contextData && contextData.projectId) {
                                        receivedContext.projectId = contextData.projectId;
                                        console.log('üîç Got project ID from AP context:', receivedContext.projectId);
                                    }
                                });
                            }
                        }
                        
                        console.log('üîç String data extracted:', {
                            id: stringData.id,
                            identifier: stringData.identifier,
                            text: stringData.text,
                            fileId: stringData.file?.id,
                            hasIdentifier: !!stringData.identifier
                        });
                        
                        // If identifier is missing but we have stringId, try to fetch it from API
                        if (!stringData.identifier && stringData.id) {
                            console.log('üîç Identifier missing in comfortable mode, logging for future API implementation');
                            console.log('üìã Would need to call Crowdin API to get identifier for string ID:', stringData.id);
                            
                            // For now, use the string ID as a fallback identifier
                            receivedContext.identifier = `string_${stringData.id}`;
                            console.log('üîß Using fallback identifier:', receivedContext.identifier);
                            
                            // Attempt to fetch from API (currently just logs what's needed)
                            const fetchedIdentifier = await fetchStringIdentifierFromAPI(stringData.id, receivedContext.projectId);
                            if (fetchedIdentifier) {
                                receivedContext.identifier = fetchedIdentifier;
                                console.log('‚úÖ Successfully fetched identifier from API:', fetchedIdentifier);
                            }
                        }
                        
                        // Use translation if available and not empty - PRIORITIZE SPANISH
                        if (translations && typeof translations === 'object') {
                            let foundTranslation = false;
                            
                            console.log('üåç === TRANSLATION PRIORITY SELECTION ===');
                            console.log('üåç Available translations:', Object.keys(translations));
                            
                            // Priority order for language selection (Spanish first!)
                            const languagePriority = ['es-CO', 'es', 'fr-CA', 'fr', 'de', 'pt', 'nl', 'it'];
                            
                            // Try to find translation in priority order
                            for (const priorityLang of languagePriority) {
                                if (translations[priorityLang] && Array.isArray(translations[priorityLang]) && translations[priorityLang].length > 0) {
                                    const translation = translations[priorityLang][0];
                                    if (translation && translation.text) {
                                        receivedContext.targetString = translation.text;
                                        receivedContext.targetLanguageId = priorityLang;
                                        receivedContext.languageCode = priorityLang;
                                        console.log(`üéØ ‚úÖ PRIORITY MATCH - Using ${priorityLang} translation: ${translation.text.substring(0, 50)}...`);
                                        foundTranslation = true;
                                        break;
                                    }
                                }
                            }
                            
                            // If no priority language found, fall back to any available translation
                            if (!foundTranslation) {
                                for (const [langCode, translationArray] of Object.entries(translations)) {
                                    if (translationArray && Array.isArray(translationArray) && translationArray.length > 0) {
                                        const translation = translationArray[0];
                                        if (translation && translation.text) {
                                            receivedContext.targetString = translation.text;
                                            receivedContext.targetLanguageId = langCode;
                                            receivedContext.languageCode = langCode;
                                            console.log(`üéØ üìã FALLBACK - Using ${langCode} translation: ${translation.text.substring(0, 50)}...`);
                                            foundTranslation = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            if (!foundTranslation) {
                                console.log('üéØ ‚ùå No translations found, using source text:', stringData.text);
                                receivedContext.targetLanguageId = 'en'; // Default to English if no translation
                                receivedContext.languageCode = 'en';
                            }
                            
                            console.log('üåç === END TRANSLATION PRIORITY SELECTION ===');
                        } else {
                            console.log('üéØ No translations object, using source text:', stringData.text);
                            receivedContext.targetLanguageId = 'en'; // Default to English if no translations
                        }
                        
                        console.log('üéØ STORED CONTEXT:', receivedContext);
                        
                        // Set a timeout to check if context persists
            setTimeout(() => {
                            console.log('‚è∞ Context check after 2 seconds:', {
                                stringId: receivedContext.stringId,
                                identifier: receivedContext.identifier,
                                targetString: receivedContext.targetString
                            });
                        }, 2000);
                    }
                    
                    if (event.data.etyp === 'string.change') {
                        console.log('üéØ PROCESSING string.change event');
                        const stringData = event.data.evnt;
                        console.log('üéØ String change data:', stringData);
                        
                        if (stringData) {
                            // Check if this is actually a different string (different ID)
                            const isDifferentString = receivedContext.stringId !== stringData.id;
                            
                            console.log('üîÑ String change analysis:', {
                                oldStringId: receivedContext.stringId,
                                newStringId: stringData.id,
                                isDifferentString: isDifferentString,
                                oldIdentifier: receivedContext.identifier,
                                newIdentifier: stringData.identifier,
                                hasExistingTranslation: !!receivedContext.targetLanguageId && receivedContext.targetLanguageId !== 'en'
                            });
                            
                            // If it's a different string, reset the context completely
                            if (isDifferentString) {
                                console.log('üÜï Different string detected, resetting context completely');
                                receivedContext = { origin: receivedContext.origin }; // Clear everything but preserve origin
                                
                                // Update with new string data
                                receivedContext.stringId = stringData.id;
                                receivedContext.stringKey = stringData.text;
                                receivedContext.sourceString = stringData.text;
                                receivedContext.targetString = stringData.text; // Start fresh with source text
                                receivedContext.identifier = stringData.identifier;
                                receivedContext.fileId = stringData.file?.id;
                                receivedContext.targetLanguageId = 'en'; // Default to English since no translation data
                                receivedContext.languageCode = 'en';
                            } else {
                                console.log('üîÑ Same string, checking for translation preservation...');
                                
                                // Check if we have a valid translation that's different from source
                                const hasValidTranslation = receivedContext.targetString && 
                                                           receivedContext.targetString !== stringData.text &&
                                                           receivedContext.targetLanguageId &&
                                                           receivedContext.targetLanguageId !== 'en';
                                
                                // Check if we have recently protected translation data (within 30 seconds)
                                const hasProtectedTranslation = receivedContext.hasActiveTranslation && 
                                                               receivedContext.translationTimestamp &&
                                                               (Date.now() - receivedContext.translationTimestamp) < 30000;
                                
                                console.log('üîç Translation preservation check:', {
                                    hasTargetString: !!receivedContext.targetString,
                                    targetStringDifferent: receivedContext.targetString !== stringData.text,
                                    hasTargetLanguageId: !!receivedContext.targetLanguageId,
                                    isNotEnglish: receivedContext.targetLanguageId !== 'en',
                                    hasValidTranslation: hasValidTranslation,
                                    hasProtectedTranslation: hasProtectedTranslation,
                                    timeSinceTranslation: receivedContext.translationTimestamp ? (Date.now() - receivedContext.translationTimestamp) + 'ms' : 'none',
                                    currentTarget: receivedContext.targetString?.substring(0, 50) + '...',
                                    newSource: stringData.text?.substring(0, 50) + '...'
                                });
                                
                                if (hasValidTranslation || hasProtectedTranslation) {
                                    console.log('üéØ ‚úÖ PRESERVING TRANSLATION DATA - Same string with existing translation');
                                    console.log('üõ°Ô∏è Reason for preservation:', hasProtectedTranslation ? 'PROTECTED (recent textarea.edited)' : 'VALID TRANSLATION');
                                    console.log('üéØ Translation being preserved:', {
                                        targetLanguageId: receivedContext.targetLanguageId,
                                        targetString: receivedContext.targetString?.substring(0, 50) + '...',
                                        sourceString: stringData.text?.substring(0, 50) + '...'
                                    });
                                    
                                    // Only update basic string info, preserve translation
                                    receivedContext.stringKey = stringData.text;
                                    receivedContext.sourceString = stringData.text;
                                    receivedContext.identifier = stringData.identifier;
                                    receivedContext.fileId = stringData.file?.id;
                                    // Keep existing targetString, targetLanguageId, languageCode
                                } else {
                                    console.log('üîÑ No valid translation to preserve, updating with source text');
                                    // No translation to preserve, update normally
                                    receivedContext.stringKey = stringData.text;
                                    receivedContext.sourceString = stringData.text;
                                    receivedContext.targetString = stringData.text;
                                    receivedContext.identifier = stringData.identifier;
                                    receivedContext.fileId = stringData.file?.id;
                                    receivedContext.targetLanguageId = 'en';
                                    receivedContext.languageCode = 'en';
                                }
                            }
                            
                            // If identifier is missing and we have string ID, try to fetch it
                            if (!stringData.identifier && stringData.id) {
                                console.log('üîç Identifier missing in string.change, will attempt API fetch');
                                receivedContext.identifier = `string_${stringData.id}`;
                                
                                // Attempt to fetch from API (async operation)
                                fetchStringIdentifierFromAPI(stringData.id, receivedContext.projectId).then(fetchedIdentifier => {
                                    if (fetchedIdentifier) {
                                        receivedContext.identifier = fetchedIdentifier;
                                        console.log('‚úÖ Updated identifier from API in string.change:', fetchedIdentifier);
                                    }
                                });
                            }
                            
                            console.log('üéØ STORED CONTEXT from string.change:', receivedContext);
                        }
                    }
                    
                    // Handle textarea.edited events - these indicate the current string being edited
                    if (event.data.etyp === 'textarea.edited') {
                        console.log('üéØ PROCESSING textarea.edited event');
                        const stringData = event.data.evnt;
                        console.log('üéØ Textarea edited data:', stringData);
                        
                        if (stringData && stringData.id) {
                            // This is the CURRENT string being edited - always update context
                            console.log('‚ú® TEXTAREA EDITED - This is the currently active string!');
                            
                            // Check if this is a different string
                            const isDifferentString = receivedContext.stringId !== stringData.id;
                            console.log('üîÑ Textarea edit analysis:', {
                                oldStringId: receivedContext.stringId,
                                newStringId: stringData.id,
                                isDifferentString: isDifferentString,
                                oldIdentifier: receivedContext.identifier,
                                newIdentifier: stringData.identifier,
                                oldText: stringData.oldText,
                                newText: stringData.newText
                            });
                            
                            // Always reset context for textarea.edited as this is the active string
                            console.log('üÜï Textarea edited detected, updating to current active string');
                            receivedContext = { origin: receivedContext.origin }; // Clear but preserve origin
                            
                            // Update with current string data
                            receivedContext.stringId = stringData.id;
                            receivedContext.stringKey = stringData.text;
                            receivedContext.sourceString = stringData.text;
                            receivedContext.identifier = stringData.identifier;
                            receivedContext.fileId = stringData.file?.id;
                            
                            // For textarea.edited, the newText is the translated text being edited
                            if (stringData.newText && stringData.newText.trim()) {
                                receivedContext.targetString = stringData.newText;
                                receivedContext.targetLanguageId = detectLanguageFromText(stringData.newText);
                                receivedContext.languageCode = receivedContext.targetLanguageId;
                                receivedContext.hasActiveTranslation = true; // Flag to protect this data
                                receivedContext.translationTimestamp = Date.now(); // Timestamp for freshness
                                console.log('üéØ Found translated text in textarea.edited:', stringData.newText);
                                console.log('üõ°Ô∏è Protected translation data set - expires in 30 seconds');
                            } else if (stringData.oldText && stringData.oldText.trim()) {
                                receivedContext.targetString = stringData.oldText;
                                receivedContext.targetLanguageId = detectLanguageFromText(stringData.oldText);
                                receivedContext.languageCode = receivedContext.targetLanguageId;
                                receivedContext.hasActiveTranslation = true;
                                receivedContext.translationTimestamp = Date.now();
                                console.log('üéØ Using old text as target from textarea.edited:', stringData.oldText);
                                console.log('üõ°Ô∏è Protected translation data set - expires in 30 seconds');
                            } else {
                                receivedContext.targetString = stringData.text;
                                receivedContext.targetLanguageId = 'en'; // Fallback to English for source text
                                receivedContext.languageCode = 'en';
                                receivedContext.hasActiveTranslation = false;
                                console.log('üéØ Using source text as target from textarea.edited');
                            }
                            
                            console.log('‚ú® STORED CONTEXT from textarea.edited (CURRENT ACTIVE):', receivedContext);
                        }
                    }
                }
                
                // Direct context updates
                if (event.data.type === 'crowdin-context' || event.data.type === 'context') {
                    console.log('üéØ Received context update:', event.data.context);
                    receivedContext = { ...receivedContext, ...event.data.context };
                }
                
                // String data in various forms
                if (event.data.stringId || event.data.stringKey || event.data.sourceString || event.data.targetString) {
                    console.log('üéØ Received string data:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // Editor context updates
                if (event.data.type === 'app-context' || event.data.type === 'editor-context') {
                    console.log('üéØ Received editor context:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // Current string updates (when user selects different strings)
                if (event.data.type === 'current-string' || event.data.type === 'string-selected') {
                    console.log('üéØ Received current string update:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // Any other data that might contain useful context
                if (event.data.projectId || event.data.fileId || event.data.languageId) {
                    console.log('üéØ Received project context:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // AGGRESSIVE EVENT CAPTURE: Try to catch any string-related events in side-by-side mode
                console.log('üîç EVENT SCAN - Checking for any useful data in event:', {
                    etyp: event.data.etyp,
                    hasEvnt: !!event.data.evnt,
                    hasString: !!(event.data.evnt && (event.data.evnt.string || event.data.evnt.id)),
                    eventKeys: event.data.evnt ? Object.keys(event.data.evnt) : []
                });
                
                // Catch any event with string data if we don't have context yet
                if (!receivedContext.stringId && event.data.evnt) {
                    const eventData = event.data.evnt;
                    
                    // Look for string data in various formats
                    if (eventData.string && eventData.string.id) {
                        console.log('üéØ AGGRESSIVE CAPTURE - Found string in nested format');
                        const stringData = eventData.string;
                        receivedContext.stringId = stringData.id;
                        receivedContext.stringKey = stringData.text;
                        receivedContext.sourceString = stringData.text;
                        receivedContext.targetString = stringData.text;
                        receivedContext.identifier = stringData.identifier;
                        receivedContext.fileId = stringData.file?.id;
                    } else if (eventData.id && eventData.text) {
                        console.log('üéØ AGGRESSIVE CAPTURE - Found string in direct format');
                        receivedContext.stringId = eventData.id;
                        receivedContext.stringKey = eventData.text;
                        receivedContext.sourceString = eventData.text;
                        receivedContext.targetString = eventData.text;
                        receivedContext.identifier = eventData.identifier;
                        receivedContext.fileId = eventData.file?.id;
                    }
                    
                    // Look for language data
                    if (eventData.language) {
                        receivedContext.targetLanguageId = eventData.language.id || eventData.language;
                        receivedContext.languageCode = eventData.language.id || eventData.language;
                        console.log('üåç AGGRESSIVE CAPTURE - Found language:', receivedContext.targetLanguageId);
                    }
                    
                    if (receivedContext.stringId) {
                        console.log('üéØ AGGRESSIVE CAPTURE SUCCESS - Got string data from event:', event.data.etyp);
                        console.log('üéØ CAPTURED CONTEXT:', receivedContext);
                    }
                }
                
                console.log('üéØ Updated receivedContext:', receivedContext);
            }
        }
        
        // Listen for messages from parent window (if in iframe)
        window.addEventListener('message', enhancedMessageHandler);
        
        // Enhanced context getter that includes received messages
        function getEnhancedCrowdinContext() {
            const urlContext = getCrowdinContext();
            return { ...urlContext, ...receivedContext };
        }
        
        // Function to manually refresh context from Crowdin
        function refreshContext() {
            console.log('üîÑ Manually refreshing context...');
            console.log('üîÑ Current context before refresh:', Object.keys(receivedContext));
            // Don't clear existing context - just try to enhance it
            
            // Try to get context using AP API if available
            if (typeof AP !== 'undefined') {
                console.log('üéØ Using AP API to refresh context...');
                
                if (AP.editor && AP.editor.getCurrentString) {
                    AP.editor.getCurrentString(function(stringData) {
                        console.log('üéØ Refresh: AP.editor.getCurrentString result:', stringData);
                        if (stringData) {
                            receivedContext = { ...receivedContext, ...stringData };
                        }
                    });
                }
                
                if (AP.context && AP.context.getContext) {
                    AP.context.getContext(function(contextData) {
                        console.log('üéØ Refresh: AP.context.getContext result:', contextData);
                        if (contextData) {
                            receivedContext = { ...receivedContext, ...contextData };
                        }
                    });
                }
                
                if (AP.editor && AP.editor.getCurrentTranslation) {
                    AP.editor.getCurrentTranslation(function(translationData) {
                        console.log('üéØ Refresh: AP.editor.getCurrentTranslation result:', translationData);
                        if (translationData) {
                            receivedContext = { ...receivedContext, ...translationData };
                        }
                    });
                }
            } else {
                console.log('üéØ AP API not available, using fallback methods...');
                requestCrowdinContext();
            }
            
            // Show updated context after a short delay
            setTimeout(() => {
                const context = getEnhancedCrowdinContext();
                console.log('üîÑ Context after refresh:', context);
                showStatus('Context refreshed. Check console for details.', 'success');
            }, 1000);
        }
        
        // Initialize context on page load
        function initializeContext() {
            console.log('üöÄ Initializing Crowdin context...');
            
            // Wait a bit for AP API to load if it's going to
            setTimeout(() => {
                if (typeof AP !== 'undefined') {
                    console.log('‚úÖ AP API is available, requesting initial context...');
                    refreshContext();
                } else {
                    console.log('‚ö†Ô∏è AP API not available, using fallback methods...');
                    requestCrowdinContext();
                }
            }, 500);
            
            // Try again after a longer delay in case AP loads slowly
            setTimeout(() => {
                if (typeof AP !== 'undefined' && Object.keys(receivedContext).length === 0) {
                    console.log('üîÑ Second attempt to get context with AP API...');
                    refreshContext();
                }
            }, 2000);
        }

        // Simple language detection from text content
        function detectLanguageFromText(text) {
            if (!text || typeof text !== 'string') return null;
            
            console.log('üåç Detecting language from text:', text.substring(0, 50) + '...');
            
            // Simple keyword-based detection for common languages
            const lowerText = text.toLowerCase();
            
            // German indicators - detecting common German words and patterns
            if (lowerText.includes('zuerst') || lowerText.includes('kannst') || lowerText.includes('einen') ||
                lowerText.includes('spielpartner') || lowerText.includes('ausw√§hlen') || lowerText.includes('spiele') ||
                lowerText.includes('zusammen') || lowerText.includes('jedem') || lowerText.includes('darfst') ||
                lowerText.includes('beispiel') || lowerText.includes('brille') || lowerText.includes('aufsetzen') ||
                lowerText.includes('anziehen') || lowerText.includes('deutsch') || lowerText.includes('aktivit√§ten') ||
                lowerText.includes(' der ') || lowerText.includes(' die ') || lowerText.includes(' das ') ||
                lowerText.includes(' den ') || lowerText.includes(' dem ') || lowerText.includes(' des ') ||
                lowerText.includes(' ein ') || lowerText.includes(' eine ') || lowerText.includes(' einen ') ||
                lowerText.includes(' mit ') || lowerText.includes(' f√ºr ') || lowerText.includes(' auf ') ||
                lowerText.includes(' von ') || lowerText.includes(' zu ') || lowerText.includes(' und ') ||
                lowerText.includes(' oder ') || lowerText.includes(' aber ') || lowerText.includes(' auch ') ||
                lowerText.includes(' nicht ') || lowerText.includes(' sich ') || lowerText.includes(' werden ') ||
                lowerText.includes('k√∂nnen') || lowerText.includes('m√ºssen') || lowerText.includes('sollen') ||
                lowerText.includes('wollen') || lowerText.includes('d√ºrfen') || lowerText.includes('hallo') ||
                lowerText.includes('danke') || lowerText.includes('bitte') || lowerText.includes('entschuldigung')) {
                console.log('üåç Detected German from text content');
                return 'de';
            }
            
            // French indicators - enhanced detection
            if (lowerText.includes('votre') || lowerText.includes('pour') || lowerText.includes('des') || 
                lowerText.includes('activit√©s') || lowerText.includes('fran√ßais') || lowerText.includes('pivoter') ||
                lowerText.includes('papa') || lowerText.includes('est-il') || lowerText.includes('f√¢ch√©') ||
                lowerText.includes('contre') || lowerText.includes('comment') || lowerText.includes('sophie') ||
                lowerText.includes('se sent-elle') || lowerText.includes('apr√®s') || lowerText.includes('avoir') ||
                lowerText.includes('perdu') || lowerText.includes('chaussure') || lowerText.includes('faites') ||
                lowerText.includes('meilleure') || lowerText.includes('appareil')) {
                console.log('üåç Detected French from text content');
                return 'fr';
            }
            
            // Spanish indicators
            if (lowerText.includes('para') || lowerText.includes('actividades') || lowerText.includes('espa√±ol') ||
                lowerText.includes('dispositivo') || lowerText.includes('mejor') || lowerText.includes('vista')) {
                console.log('üåç Detected Spanish from text content');
                return 'es';
            }
            
            // Spanish Colombian specific
            if (lowerText.includes('sof√≠a') || lowerText.includes('pap√°') || lowerText.includes('enfade') ||
                lowerText.includes('zapato') || lowerText.includes('jaime')) {
                console.log('üåç Detected Spanish (Colombian) from text content');
                return 'es-CO';
            }
            
            // Portuguese indicators
            if (lowerText.includes('para') || lowerText.includes('atividades') || lowerText.includes('dispositivo') ||
                lowerText.includes('melhor') || lowerText.includes('portugu√™s')) {
                console.log('üåç Detected Portuguese from text content');
                return 'pt';
            }
            
            console.log('üåç Could not detect language from text, defaulting to null');
            return null;
        }

        // Enhanced function to detect the target language from Crowdin context
        function detectTargetLanguage(context) {
            console.log('üåç === LANGUAGE DETECTION DEBUG ===');
            console.log('üåç Input context:', JSON.stringify(context, null, 2));
            
            // PRIORITY 1: Use direct language API results (most reliable)
            if (context.targetLanguageId && context.targetLanguageId !== 'en') {
                console.log('üåç ‚úÖ PRIORITY 1: Using targetLanguageId from API:', context.targetLanguageId);
                console.log('üåç Language detection complete - returning:', context.targetLanguageId);
                return context.targetLanguageId;
            }
            
            if (context.languageCode && context.languageCode !== 'en') {
                console.log('üåç ‚úÖ PRIORITY 1b: Using languageCode from API:', context.languageCode);
                console.log('üåç Language detection complete - returning:', context.languageCode);
                return context.languageCode;
            }
            
            // PRIORITY 1c: Check for language ID from various API sources
            if (context.languageId && context.languageId !== 'en') {
                console.log('üåç ‚úÖ PRIORITY 1c: Using languageId from API:', context.languageId);
                console.log('üåç Language detection complete - returning:', context.languageId);
                return context.languageId;
            }
            
            // PRIORITY 2: Try text-based detection (reliable for translation content)
            if (context.targetString && typeof context.targetString === 'string') {
                console.log('üåç PRIORITY 2: Trying text-based detection from:', context.targetString.substring(0, 50) + '...');
                
                const detectedFromText = detectLanguageFromText(context.targetString);
                if (detectedFromText) {
                    console.log('üåç ‚úÖ DETECTED language from text content:', detectedFromText);
                    return detectedFromText;
                }
            }
            
            // PRIORITY 3: Try other language IDs from context
            let detectedLanguage = context.sourceLanguageId || context.languageId;
            console.log('üåç PRIORITY 3: Other language from context:', detectedLanguage);
            
            // If no direct language, try URL detection
            if (!detectedLanguage) {
                console.log('üåç No direct language found, trying URL detection...');
                
                // Try current window URL parameters first
                const urlParams = new URLSearchParams(window.location.search);
                const urlLang = urlParams.get('language') || urlParams.get('lang') || urlParams.get('target_language');
                if (urlLang) {
                    console.log('üåç Found language in current URL:', urlLang);
                    detectedLanguage = urlLang;
                }
                
                // Try to detect from parent window location
                if (!detectedLanguage) {
                    try {
                        if (window.parent && window.parent.location) {
                            const parentUrl = window.parent.location.href;
                            console.log('üåç Analyzing parent URL for language:', parentUrl);
                            
                            // Multiple patterns to match different Crowdin URL formats
                            const patterns = [
                                /\/en-([a-z]+)(?:\/|#|\?|$)/,                    // en-esco format (Crowdin comfortable mode)
                                /\/enus-([a-z]{2}(?:-[A-Z]{2})?)(?:\/|#|$)/,     // enus-es-CO format (with country code)
                                /\/([a-z]{2}(?:-[A-Z]{2})?)-enus(?:\/|#|$)/,     // es-CO-enus format (with country code)
                                /editor\/[^\/]+\/\d+\/en-([a-z]+)/,              // editor/project/83/en-esco
                                /editor\/[^\/]+\/\d+\/enus-([a-z]{2}(?:-[A-Z]{2})?)/,  // editor/project/83/enus-es-CO
                                /\/enus-([a-z]{2})(?:[-_][A-Z]{2})?(?:\/|#|$)/,  // enus-fr format (legacy)
                                /\/([a-z]{2})(?:[-_][A-Z]{2})?-enus(?:\/|#|$)/,  // fr-enus format (legacy)
                                /editor\/[^\/]+\/\d+\/enus-([a-z]{2})(?:[-_][A-Z]{2})?/,  // editor/project/83/enus-frca (legacy)
                                /\/([a-z]{2}(?:-[A-Z]{2})?)(?:\/|#|$)/,          // generic /es-CO/ format
                                /target_language=([a-z]{2}(?:-[A-Z]{2})?)/,      // URL parameter with country code
                                /lang=([a-z]{2}(?:-[A-Z]{2})?)/                 // URL parameter with country code
                            ];
                            
                            for (const pattern of patterns) {
                                const match = parentUrl.match(pattern);
                                if (match && match[1] && match[1] !== 'en') {
                                    let langCode = match[1];
                                    
                                    // Map Crowdin shorthand codes to proper language codes
                                    if (langCode === 'esco') {
                                        langCode = 'es-CO';
                                        console.log('üåç ‚úÖ Detected esco -> mapping to es-CO');
                                    } else if (langCode === 'frca') {
                                        langCode = 'fr-CA';
                                        console.log('üåç ‚úÖ Detected frca -> mapping to fr-CA');
                                    } else if (langCode === 'dede') {
                                        langCode = 'de-DE';
                                        console.log('üåç ‚úÖ Detected dede -> mapping to de-DE');
                                    }
                                    
                                    console.log('üåç ‚úÖ Detected language from parent URL pattern:', langCode);
                                    detectedLanguage = langCode;
                                    break;
                                }
                            }
                        }
                    } catch (e) {
                        console.log('üåç Could not access parent URL due to cross-origin restrictions');
                    }
                }
            }
            
            // Map language codes (from audio-previewer logic)
            function mapLanguageCode(languageId) {
                if (!languageId) return null;
                
                const langId = String(languageId).toLowerCase().trim();
                console.log('üåç Mapping language code:', langId);
                
                const languageMappings = {
                    'en': 'en', 'en-us': 'en', 'english': 'en',
                    'es': 'es', 'es-co': 'es', 'spanish': 'es', 'espa√±ol': 'es',
                    'fr': 'fr', 'fr-ca': 'fr', 'french': 'fr', 'fran√ßais': 'fr', 'frca': 'fr',
                    'pt': 'pt', 'pt-br': 'pt', 'portuguese': 'pt', 'portugu√™s': 'pt',
                    'de': 'de', 'de-de': 'de', 'german': 'de', 'deutsch': 'de',
                    'nl': 'nl', 'nl-nl': 'nl', 'nl-be': 'nl', 'dutch': 'nl', 'nederlands': 'nl',
                    'it': 'it', 'it-it': 'it', 'italian': 'it', 'italiano': 'it'
                };
                
                const mapped = languageMappings[langId];
                console.log('üåç Language mapping result:', langId, '->', mapped);
                return mapped || null;
            }
            
            const mappedLanguage = mapLanguageCode(detectedLanguage);
            console.log('üåç Final language detection result:', {
                original: detectedLanguage,
                mapped: mappedLanguage,
                fallback: mappedLanguage || 'en'
            });
            
            // COMFORTABLE MODE FALLBACK: If we still don't have a language, try harder URL detection
            if (!mappedLanguage) {
                console.log('üåç ‚ö†Ô∏è No language detected via normal methods - trying aggressive URL detection for comfortable mode');
                
                try {
                    // Try to get the full parent window URL and extract language more aggressively
                    if (window.parent && window.parent.location) {
                        const fullUrl = window.parent.location.href;
                        console.log('üåç Full parent URL for aggressive detection:', fullUrl);
                        
                        // Look for es-CO specifically in the URL (common in Crowdin comfortable mode)
                        if (fullUrl.includes('es-CO') || fullUrl.includes('es_CO') || fullUrl.includes('esco') || fullUrl.includes('en-esco')) {
                            console.log('üåç ‚úÖ AGGRESSIVE: Found es-CO pattern in URL');
                            return 'es-CO';
                        }
                        
                        // Look for other Spanish variants
                        if (fullUrl.includes('es-MX') || fullUrl.includes('es_MX')) {
                            console.log('üåç ‚úÖ AGGRESSIVE: Found es-MX in URL');
                            return 'es-MX';
                        }
                        
                        // Look for German variants
                        if (fullUrl.includes('de-DE') || fullUrl.includes('de_DE') || fullUrl.includes('/de/')) {
                            console.log('üåç ‚úÖ AGGRESSIVE: Found German in URL');
                            return 'de';
                        }
                        
                        // Look for French variants
                        if (fullUrl.includes('fr-CA') || fullUrl.includes('fr_CA')) {
                            console.log('üåç ‚úÖ AGGRESSIVE: Found fr-CA in URL');
                            return 'fr-CA';
                        }
                    }
                } catch (e) {
                    console.log('üåç Aggressive URL detection failed:', e.message);
                }
            }
            
            return mappedLanguage || 'en'; // Default to English if nothing detected
        }

        // Audio Generation Functionality
        class AudioManager {
            constructor() {
                this.apiConfig = {
                    playht: {
                        apiUrl: 'https://api.play.ht/api/v2/tts/stream',
                        voicesUrl: 'https://api.play.ht/api/v2/voices',
                        apiKey: null,
                        userId: null
                    },
                    elevenlabs: {
                        apiUrl: 'https://api.elevenlabs.io/v1/text-to-speech',
                        voicesUrl: 'https://api.elevenlabs.io/v1/voices',
                        apiKey: null
                    }
                };
                
                this.voiceCache = {};
                this.currentService = null;
                this.currentVoice = null;
                
                // Load credentials using the same method as dashboard.js
                this.loadCredentials();
            }

            loadCredentials() {
                console.log('üîÑ Loading credentials from storage...');
                
                // Load with backup recovery (same as dashboard.js)
                let playhtApiKey = localStorage.getItem('PLAY_DOT_HT_API_KEY') || '';
                let playhtUserId = localStorage.getItem('PLAY_DOT_HT_USER_ID') || '';
                let elevenlabsApiKey = localStorage.getItem('ELEVENLABS_API_KEY') || '';

                // Backup credential recovery - try alternative storage keys
                if (!playhtApiKey) {
                    playhtApiKey = localStorage.getItem('playht_api_key') ||
                                   localStorage.getItem('PLAYHT_API_KEY') ||
                                   sessionStorage.getItem('PLAY_DOT_HT_API_KEY') || '';
                }

                if (!playhtUserId) {
                    playhtUserId = localStorage.getItem('playht_user_id') ||
                                   localStorage.getItem('PLAYHT_USER_ID') ||
                                   sessionStorage.getItem('PLAY_DOT_HT_USER_ID') || '';
                }

                if (!elevenlabsApiKey) {
                    elevenlabsApiKey = localStorage.getItem('elevenlabs_api_key') ||
                                       localStorage.getItem('ELEVENLABS_KEY') ||
                                       localStorage.getItem('ELEVENLABS_API_KEY') ||
                                       sessionStorage.getItem('ELEVENLABS_API_KEY') ||
                                       sessionStorage.getItem('elevenlabs_api_key') || '';
                }

                console.log('üîç Credential loading results:', {
                    playhtApiKey: playhtApiKey ? `${playhtApiKey.substring(0, 8)}...` : 'Missing',
                    playhtUserId: playhtUserId ? `${playhtUserId.substring(0, 8)}...` : 'Missing',
                    elevenlabsApiKey: elevenlabsApiKey ? `${elevenlabsApiKey.substring(0, 8)}...` : 'Missing'
                });

                // Update the API config - THIS WAS THE MISSING PART!
                this.apiConfig.playht.apiKey = playhtApiKey;
                this.apiConfig.playht.userId = playhtUserId;
                this.apiConfig.elevenlabs.apiKey = elevenlabsApiKey;

                console.log('‚úÖ API config updated:', {
                    playhtConfigured: !!(this.apiConfig.playht.apiKey && this.apiConfig.playht.userId),
                    elevenlabsConfigured: !!this.apiConfig.elevenlabs.apiKey
                });
            }

            async loadVoices(service, languageCode = 'en') {
                const cacheKey = `${service}_${languageCode}`;
                
                console.log(`üóÇÔ∏è Loading voices for ${service} (${languageCode}), cache key: ${cacheKey}`);
                
                if (this.voiceCache[cacheKey]) {
                    console.log(`‚úÖ Using cached voices for ${cacheKey}: ${this.voiceCache[cacheKey].length} voices`);
                    return this.voiceCache[cacheKey];
                }

                try {
                    console.log(`üîÑ Loading fresh voices for ${service} (${languageCode})`);
                    let voices = [];
                    if (service === 'PlayHT') {
                        voices = await this.loadPlayHTVoices(languageCode);
                    } else if (service === 'ElevenLabs') {
                        voices = await this.loadElevenLabsVoices(languageCode);
                    }
                    
                    console.log(`üíæ Caching ${voices.length} voices for ${cacheKey}`);
                    this.voiceCache[cacheKey] = voices;
                    return voices;
                } catch (error) {
                    console.error(`Error loading ${service} voices:`, error);
                    return [];
                }
            }

            async loadPlayHTVoices(languageCode = 'en') {
                console.log('üé§ Loading PlayHT voices from CSV for language:', languageCode);
                
                try {
                    // Load voices from CSV file instead of API
                    const response = await fetch('/preloaded_voices/comprehensive_female_voices_v1.csv');
                    
                    if (!response.ok) {
                        throw new Error(`Failed to load CSV: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log(' PlayHT CSV loaded, first 500 chars:', csvText.substring(0, 500));
                    
                    // Parse CSV properly - handle quoted values and commas within quotes
                    const lines = csvText.split('\n');
                    const headers = this.parseCSVLine(lines[0]);
                    console.log('üìã CSV Headers:', headers);
                    
                    const voices = [];
                    let playhtCount = 0;
                    let totalLines = 0;
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        totalLines++;
                        const values = this.parseCSVLine(line);
                        
                        // Create voice object
                        const voice = {};
                        headers.forEach((header, index) => {
                            voice[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        
                        // Debug first few lines
                        if (i <= 5) {
                            console.log(`üìù Line ${i}:`, voice.service, '|', voice.name);
                        }
                        
                        // Only include PlayHT voices (check first column)
                        if (voice.service === 'PlayHT') {
                            playhtCount++;
                            voices.push({
                                id: voice.id,
                                name: voice.name,
                                language: voice.language,
                                language_code: voice.language_code,
                                gender: voice.gender,
                                age: voice.age,
                                accent: voice.accent,
                                style: voice.style,
                                description: voice.description
                            });
                        }
                    }
                    
                    console.log(`üìä PlayHT CSV parsing results: ${totalLines} total lines, ${playhtCount} PlayHT voices found`);
                    console.log(`üìä PlayHT Total voices from CSV: ${voices.length}`);
                    
                    // Filter by language with improved matching
                    let filteredVoices = voices;
                    if (languageCode) {
                        filteredVoices = voices.filter(voice => {
                            const voiceLang = (voice.language_code || voice.language || '').toLowerCase();
                            const targetLang = languageCode.toLowerCase();
                            
                            // Exact match first
                            if (voiceLang === targetLang) return true;
                            
                            // Partial match (e.g., "en" matches "english", "fr" matches "french")
                            if (voiceLang.includes(targetLang) || targetLang.includes(voiceLang)) return true;
                            
                            // Language name matching
                            const languageNames = {
                                'en': ['english', 'en'],
                                'es': ['spanish', 'es', 'espa√±ol'],
                                'fr': ['french', 'fr', 'fran√ßais'],
                                'de': ['german', 'de', 'deutsch'],
                                'pt': ['portuguese', 'pt', 'portugu√™s'],
                                'nl': ['dutch', 'nl', 'nederlands']
                            };
                            
                            const possibleNames = languageNames[targetLang] || [targetLang];
                            return possibleNames.some(name => voiceLang.includes(name));
                        });
                        
                        // If no voices found for specific language, fall back to English
                        if (filteredVoices.length === 0 && languageCode !== 'en') {
                            console.log(`‚ö†Ô∏è No PlayHT voices found for "${languageCode}", falling back to English voices`);
                            filteredVoices = voices.filter(voice => {
                                const voiceLang = (voice.language_code || voice.language || '').toLowerCase();
                                return voiceLang.includes('en') || voiceLang.includes('english');
                            });
                        }
                    }
                    
                    console.log(`üéØ PlayHT Filtered voices for "${languageCode}": ${filteredVoices.length}`);
                    
                    // Log first few voices for debugging
                    if (filteredVoices.length > 0) {
                        console.log('üéµ First 3 PlayHT voices from CSV:', filteredVoices.slice(0, 3));
                    } else {
                        console.warn('‚ö†Ô∏è No PlayHT voices found after filtering');
                    }
                    
                    return filteredVoices;
                    
                } catch (error) {
                    console.error('Error loading PlayHT voices from CSV:', error);
                    return [];
                }
            }

            // Helper method to properly parse CSV lines with quoted values
            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                result.push(current); // Add the last field
                return result;
            }

            async loadElevenLabsVoices(languageCode = 'en') {
                console.log('üéôÔ∏è Loading ElevenLabs Voice Library for language:', languageCode);
                
                if (!this.apiConfig.elevenlabs.apiKey) {
                    console.log('  ‚ùå ElevenLabs API key missing, cannot load personal voice library');
                    return [];
                }
                
                console.log('‚úÖ ElevenLabs API key found, loading your personal voice library...');
                
                try {
                    const response = await fetch('/api/elevenlabs-voices-proxy', {
                        method: 'GET',
                        headers: {
                            'xi-api-key': this.apiConfig.elevenlabs.apiKey
                        }
                    });
                    
                    console.log('üì° ElevenLabs API response status:', response.status);
                    
                    if (!response.ok) {
                        throw new Error(`ElevenLabs API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const allVoices = data.voices || [];
                    
                    // Store voices for optional CSV export (don't auto-download)
                    window.elevenLabsVoiceLibrary = allVoices;
                    
                    // Only show your personal voice library - exclude all public/premade voices
                    const voiceLibrary = allVoices.filter(voice => {
                        const category = voice.category || '';
                        // Only include voices from your personal library
                        const isPersonalLibrary = category === 'cloned' || 
                                                category === 'professional' || 
                                                category === 'generated' ||
                                                category === 'instant';
                        return isPersonalLibrary;
                    });
                    
                    const publicCount = allVoices.length - voiceLibrary.length;
                    console.log(`üéØ ElevenLabs Voice Library: ${voiceLibrary.length} personal voices loaded, ${publicCount} public voices excluded`);
                    
                    if (voiceLibrary.length > 0) {
                        console.log('üéµ Using your personal ElevenLabs voice library');
                        
                        // Update default voices with actual voice IDs from our library
                        this.updateDefaultVoicesFromLibrary(voiceLibrary);
                        
                        return voiceLibrary.map(voice => ({
                            id: voice.voice_id,
                            name: voice.name,
                            category: voice.category,
                            language: voice.language || 'English',
                            language_code: voice.language_code || 'en',
                            description: voice.description || ''
                        }));
                    } else {
                        console.log('‚ö†Ô∏è No personal voices found in your ElevenLabs voice library');
                        return [];
                    }
                    
                } catch (error) {
                    console.error('üö® ElevenLabs Voice Library loading failed:', error);
                    return [];
                }
            }

            async exportVoiceLibraryToCSV(voices) {
                console.log('üìù Exporting voice library to CSV...');
                
                try {
                    // Create CSV content
                    const headers = ['voice_id', 'name', 'category', 'language', 'language_code', 'description', 'labels'];
                    const csvRows = [headers.join(',')];
                    
                    voices.forEach(voice => {
                        const row = [
                            voice.voice_id || '',
                            `"${(voice.name || '').replace(/"/g, '""')}"`, // Escape quotes
                            voice.category || '',
                            voice.language || '',
                            voice.language_code || '',
                            `"${(voice.description || '').replace(/"/g, '""')}"`, // Escape quotes
                            `"${Object.keys(voice.labels || {}).join(';')}"` // Convert labels object to string
                        ];
                        csvRows.push(row.join(','));
                    });
                    
                    const csvContent = csvRows.join('\n');
                    
                    // Create download link
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    if (link.download !== undefined) {
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', `elevenlabs_voice_library_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.csv`);
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        console.log('‚úÖ Voice library CSV exported successfully');
                    }
                } catch (error) {
                    console.error('‚ùå Failed to export voice library CSV:', error);
                }
            }

            updateDefaultVoicesFromLibrary(voiceLibrary) {
                console.log('üîÑ Updating default voices with actual voice IDs from library...');
                
                // Create a mapping of language preferences to voice names/patterns
                const languageVoiceMap = {
                    'en': ['Clara', 'Children', 'Storyteller', 'Female', 'English'],
                    'es': ['Malena', 'Spanish', 'Espa√±ol'],
                    'de': ['Julia', 'German', 'Deutsch'],
                    'fr': ['Caroline', 'French', 'Fran√ßais'],
                    'nl': ['Emma', 'Dutch', 'Nederlands']
                };
                
                // Find best matching voices for each language
                const updatedDefaults = {};
                
                Object.keys(languageVoiceMap).forEach(langCode => {
                    const preferredNames = languageVoiceMap[langCode];
                    
                    // Find voice that matches preferred names or language
                    let bestMatch = voiceLibrary.find(voice => {
                        const voiceName = voice.name.toLowerCase();
                        const voiceLang = (voice.language || voice.language_code || '').toLowerCase();
                        
                        // Check if voice name contains any preferred names
                        const nameMatch = preferredNames.some(pref => voiceName.includes(pref.toLowerCase()));
                        // Check if voice language matches
                        const langMatch = voiceLang.includes(langCode) || voiceLang.includes(languageVoiceMap[langCode][2]?.toLowerCase() || '');
                        
                        return nameMatch || langMatch;
                    });
                    
                    // If no specific match, try to find any voice with the language code
                    if (!bestMatch) {
                        bestMatch = voiceLibrary.find(voice => {
                            const voiceLang = (voice.language || voice.language_code || '').toLowerCase();
                            return voiceLang.includes(langCode);
                        });
                    }
                    
                    if (bestMatch) {
                        updatedDefaults[langCode] = {
                            id: bestMatch.voice_id,
                            name: bestMatch.name,
                            service: 'ElevenLabs',
                            language_code: langCode
                        };
                        console.log(`‚úÖ Found voice for ${langCode}: ${bestMatch.name} (${bestMatch.voice_id})`);
                    } else {
                        console.log(`‚ö†Ô∏è No suitable voice found for ${langCode}`);
                    }
                });
                
                // Store updated defaults globally for use by getDefaultVoiceForLanguage
                window.updatedDefaultVoices = updatedDefaults;
                console.log('üìã Updated default voices:', updatedDefaults);
            }

            async loadElevenLabsVoicesFromCSV(languageCode = 'en') {
                console.log('üéôÔ∏è Loading ElevenLabs voices from CSV for language:', languageCode);
                
                try {
                    const response = await fetch('/preloaded_voices/comprehensive_female_voices_v1.csv');
                    
                    if (!response.ok) {
                        throw new Error(`Failed to load CSV: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log('üì¶ ElevenLabs CSV loaded, parsing...');
                    
                    // Parse CSV
                    const lines = csvText.split('\n');
                    const headers = lines[0].split(',');
                    const voices = [];
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        const values = line.split(',');
                        const voice = {};
                        
                        headers.forEach((header, index) => {
                            voice[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        
                        // Only include ElevenLabs voices, and only professional/generated (no premade)
                        if (voice.service === 'ElevenLabs' && voice.category !== 'premade') {
                            voices.push({
                                voice_id: voice.id,
                                name: voice.name,
                                language: voice.language,
                                language_code: voice.language_code,
                                gender: voice.gender,
                                age: voice.age,
                                accent: voice.accent,
                                category: voice.category,
                                description: voice.description
                            });
                        }
                    }
                    
                    console.log(`üìä ElevenLabs Total voices from CSV: ${voices.length}`);
                    
                    // Filter by language if specified
                    let filteredVoices = voices;
                    if (languageCode && languageCode !== 'en') {
                        filteredVoices = voices.filter(voice => {
                            const voiceLang = voice.language_code || voice.language || '';
                            return voiceLang.toLowerCase().includes(languageCode.toLowerCase());
                        });
                    }
                    
                    console.log(`üéØ ElevenLabs Filtered voices for "${languageCode}": ${filteredVoices.length}`);
                    
                    // Log first few voices for debugging
                    if (filteredVoices.length > 0) {
                        console.log('üéµ First 3 ElevenLabs voices from CSV:', filteredVoices.slice(0, 3));
                    }
                    
                    return filteredVoices;
                    
                } catch (error) {
                    console.error('Error loading ElevenLabs voices from CSV:', error);
                    return [];
                }
            }

            async generateAudio(service, voiceId, text) {
                console.log(`üé§ Generating audio with ${service}, voice: ${voiceId}, text: "${text.substring(0, 50)}..."`);
                
                if (service === 'PlayHT') {
                    return await this.generatePlayHTAudio(voiceId, text);
                } else if (service === 'ElevenLabs') {
                    return await this.generateElevenLabsAudio(voiceId, text);
                } else {
                    throw new Error(`Unsupported service: ${service}`);
                }
            }

            async generatePlayHTAudio(voiceId, text) {
                console.log(`üé§ Generating audio with PlayHT, voice: ${voiceId}, text: "${text.substring(0, 50)}..."`);
                showStatus('Generating PlayHT audio...', 'info');
                
                const requestData = {
                    text: text,
                    voice: voiceId,
                    voice_engine: 'Play3.0-mini',
                    output_format: 'mp3',
                    sample_rate: 22050
                };

                const response = await fetch('/api/playht-proxy', {
                    method: 'POST',
                    headers: {
                        'Authorization': this.apiConfig.playht.apiKey,
                        'X-USER-ID': this.apiConfig.playht.userId,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`PlayHT API error: ${response.status}`);
                }

                const audioData = await response.arrayBuffer();
                showStatus('Playing PlayHT audio...', 'success');
                await this.playAudioData(audioData);
                showStatus('PlayHT audio completed!', 'success');
                return audioData;
            }

            async generateElevenLabsAudio(voiceId, text) {
                console.log(`üé§ Generating audio with ElevenLabs, voice: ${voiceId}, text: "${text.substring(0, 50)}..."`);
                showStatus('Generating ElevenLabs audio...', 'info');
                
                const requestData = {
                    text: text,
                    model_id: 'eleven_multilingual_v2',
                    voice_settings: {
                        stability: 0.65,
                        similarity_boost: 0.5,
                        style: 0.0,
                        use_speaker_boost: true
                    }
                };

                const response = await fetch(`/api/elevenlabs-proxy/${voiceId}`, {
                    method: 'POST',
                    headers: {
                        'xi-api-key': this.apiConfig.elevenlabs.apiKey,
                        'Content-Type': 'application/json',
                        'Accept': 'audio/mpeg'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`ElevenLabs API error: ${response.status}`);
                }

                const audioData = await response.arrayBuffer();
                showStatus('Playing ElevenLabs audio...', 'success');
                await this.playAudioData(audioData);
                showStatus('ElevenLabs audio completed!', 'success');
                return audioData;
            }

            async playAudioData(audioData) {
                const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                
                return new Promise((resolve, reject) => {
                    audio.addEventListener('ended', () => {
                        URL.revokeObjectURL(audioUrl);
                        resolve();
                    });
                    audio.addEventListener('error', (e) => {
                        URL.revokeObjectURL(audioUrl);
                        reject(e);
                    });
                    audio.play().catch(reject);
                });
            }
        }

        // Initialize audio manager
        const audioManager = new AudioManager();

        // Voice Dropdown Helper Function
        function populateVoiceDropdown(voices, serviceName) {
            const voiceSelect = document.getElementById('voiceSelect');
            
            // Clear dropdown completely first
            voiceSelect.innerHTML = '<option value="">Select Voice</option>';
            
            console.log(`üìã Populating ${serviceName} dropdown with ${voices.length} voices`);
            console.log(`üìã Current dropdown children before population: ${voiceSelect.children.length}`);
            
            // Check for duplicate voice IDs in the input array
            const voiceIds = new Set();
            const duplicateIds = [];
            voices.forEach(voice => {
                if (voiceIds.has(voice.id)) {
                    duplicateIds.push(voice.id);
                } else {
                    voiceIds.add(voice.id);
                }
            });
            
            if (duplicateIds.length > 0) {
                console.warn(`‚ö†Ô∏è DUPLICATE VOICE IDs DETECTED in ${serviceName}:`, duplicateIds);
                console.warn(`‚ö†Ô∏è This may cause voices to appear twice in dropdown`);
            }
            
            // Remove duplicates by creating a Map with voice.id as key
            const uniqueVoices = Array.from(new Map(voices.map(voice => [voice.id, voice])).values());
            
            if (uniqueVoices.length !== voices.length) {
                console.warn(`‚ö†Ô∏è Removed ${voices.length - uniqueVoices.length} duplicate voices from ${serviceName}`);
            }
            
            // Sort voices alphabetically by name
            const sortedVoices = uniqueVoices.sort((a, b) => {
                const nameA = (a.name || 'Unnamed Voice').toLowerCase();
                const nameB = (b.name || 'Unnamed Voice').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            console.log(`üî§ Voices sorted alphabetically for ${serviceName} (${sortedVoices.length} unique voices)`);
            
            sortedVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = voice.name || 'Unnamed Voice';
                voiceSelect.appendChild(option);
            });
            
            console.log(`‚úÖ ${serviceName} dropdown populated successfully with ${sortedVoices.length} unique voices`);
            console.log(`üìã Final dropdown children count: ${voiceSelect.children.length}`);
        }
        
        function showAudioGeneration() {
            console.log('üé§ Show audio generation called');
            document.getElementById('audioGeneration').style.display = 'block';
            
            // Move auto-play checkbox inside audio generation panel
            const autoPlayContainer = document.getElementById('autoPlayContainer');
            const audioGeneration = document.getElementById('audioGeneration');
            if (autoPlayContainer && audioGeneration) {
                audioGeneration.appendChild(autoPlayContainer);
                autoPlayContainer.style.marginTop = '12px';
            }
        }

        function hideAudioGeneration() {
            console.log('üé§ Hide audio generation called');
            document.getElementById('audioGeneration').style.display = 'none';
            
            // Move auto-play checkbox back to main area
            const autoPlayContainer = document.getElementById('autoPlayContainer');
            const audioSection = document.querySelector('.audio-section');
            if (autoPlayContainer && audioSection) {
                // Insert after the audio buttons div
                const audioButtons = audioSection.querySelector('.audio-buttons');
                if (audioButtons) {
                    audioButtons.parentNode.insertBefore(autoPlayContainer, audioButtons.nextSibling);
                    autoPlayContainer.style.marginTop = '8px';
                }
            }
        }

        async function onServiceChange() {
            const serviceSelect = document.getElementById('serviceSelect');
            const voiceSelect = document.getElementById('voiceSelect');
            const generateBtn = document.getElementById('generateBtn');
            
            // Clear voice dropdown
            voiceSelect.innerHTML = '<option value="">Select Voice</option>';
            if (generateBtn) generateBtn.disabled = true;
            
            const selectedService = serviceSelect.value;
            console.log('üîÑ Service changed to:', selectedService);
            
            if (!selectedService) {
                audioManager.currentService = null;
                return;
            }
            
            // Set the current service in audioManager
            audioManager.currentService = selectedService;
            
            // Load voices for the selected service
            showStatus('Loading voices...', 'info');
            try {
                // Detect current language from Crowdin context
                let detectedLanguageCode = 'en'; // Default fallback
                
                if (receivedContext && receivedContext.targetLanguageId) {
                    detectedLanguageCode = receivedContext.targetLanguageId;
                    console.log('üåç Using language from receivedContext:', detectedLanguageCode);
                } else {
                    // Try to get language from URL params as fallback
                    const urlParams = new URLSearchParams(window.location.search);
                    const urlLang = urlParams.get('language') || urlParams.get('lang') || urlParams.get('target_language');
                    if (urlLang) {
                        detectedLanguageCode = urlLang;
                        console.log('üåç Using language from URL params:', detectedLanguageCode);
                    }
                }
                
                // Map language codes (fr-CA -> fr, etc.)
                function mapLanguageCode(langId) {
                    if (!langId) return 'en';
                    const lang = langId.toLowerCase();
                    const languageMappings = {
                        'es': 'es', 'es-co': 'es', 'es-mx': 'es', 'es-es': 'es',
                        'en': 'en', 'en-us': 'en', 'en-gb': 'en', 'en-ca': 'en',
                        'fr': 'fr', 'fr-ca': 'fr', 'fr-fr': 'fr',
                        'pt': 'pt', 'pt-br': 'pt', 'pt-pt': 'pt',
                        'de': 'de', 'de-de': 'de',
                        'nl': 'nl', 'nl-nl': 'nl', 'nl-be': 'nl'
                    };
                    return languageMappings[lang] || 'en';
                }
                
                const languageCode = mapLanguageCode(detectedLanguageCode);
                console.log('üåç Final language for voice filtering:', { original: detectedLanguageCode, mapped: languageCode });
                
                let voices = [];
                if (selectedService === 'PlayHT') {
                    voices = await audioManager.loadVoices('PlayHT', languageCode);
                } else if (selectedService === 'ElevenLabs') {
                    voices = await audioManager.loadVoices('ElevenLabs', languageCode);
                }
                
                populateVoiceDropdown(voices, selectedService);
                showStatus(`Loaded ${voices.length} ${selectedService} voices for ${languageCode}`, 'success');
            } catch (error) {
                console.error(`Error loading ${selectedService} voices:`, error);
                showStatus(`Failed to load ${selectedService} voices`, 'error');
            }
        }

        function onVoiceChange() {
            const voiceSelect = document.getElementById('voiceSelect');
            const generateBtn = document.getElementById('generateBtn');
            
            audioManager.currentVoice = voiceSelect.value;
            if (generateBtn) generateBtn.disabled = !voiceSelect.value;
            
            console.log('üéµ Voice changed:', voiceSelect.value, 'Generate button enabled:', !!voiceSelect.value);
        }



        async function generateAudio() {
            const selectedService = document.getElementById('serviceSelect').value;
            const selectedVoice = document.getElementById('voiceSelect').value;
            
            if (!selectedService || !selectedVoice) {
                showStatus('Please select both service and voice', 'error');
                return;
            }

            // Get the current context with detailed debugging
            console.log('üé§ === GENERATE AUDIO DEBUG ===');
            console.log('üé§ receivedContext:', JSON.stringify(receivedContext, null, 2));
            
            // Use receivedContext directly - don't call getEnhancedCrowdinContext() as it overwrites the translation
            let textToGenerate;
            if (receivedContext && receivedContext.targetString && receivedContext.targetString.trim()) {
                textToGenerate = receivedContext.targetString;
                console.log('üé§ ‚úÖ Using TRANSLATED text from receivedContext:', textToGenerate);
            } else if (receivedContext && receivedContext.sourceString && receivedContext.sourceString.trim()) {
                textToGenerate = receivedContext.sourceString;
                console.log('üé§ ‚ö†Ô∏è Using SOURCE text from receivedContext (no translation):', textToGenerate);
            } else {
                textToGenerate = 'Test audio generation for the selected string.';
                console.log('üé§ ‚ùå Using fallback text (no context available):', textToGenerate);
            }

            if (!textToGenerate || textToGenerate.trim() === '') {
                showStatus('No text available for audio generation', 'error');
                return;
            }

            console.log('üé§ Final text to generate:', JSON.stringify(textToGenerate));
            console.log('üé§ Text length:', textToGenerate.length);

            showStatus('Generating audio...', 'info');

            try {
                if (selectedService === 'PlayHT') {
                    await audioManager.generatePlayHTAudio(selectedVoice, textToGenerate);
                } else if (selectedService === 'ElevenLabs') {
                    await audioManager.generateElevenLabsAudio(selectedVoice, textToGenerate);
                }
            } catch (error) {
                console.error('üö® Audio generation failed:', error);
                showStatus(`Audio generation failed: ${error.message}`, 'error');
            }
        }

        function getCurrentTextareaContent() {
            console.log('üéß === SEARCHING FOR ACTIVE TEXTAREA CONTENT ===');
            
            // Try to find the active translation textarea in Crowdin
            const textareas = document.querySelectorAll('textarea');
            console.log(`üéß Found ${textareas.length} textareas total`);
            
            let candidateTextareas = [];
            
            for (let i = 0; i < textareas.length; i++) {
                const textarea = textareas[i];
                const isVisible = textarea.offsetParent !== null;
                const hasContent = textarea.value && textarea.value.trim().length > 0;
                const isEditable = !textarea.disabled && !textarea.readOnly;
                
                console.log(`üéß Textarea ${i}:`, {
                    visible: isVisible,
                    hasContent: hasContent,
                    editable: isEditable,
                    content: hasContent ? textarea.value.substring(0, 30) + '...' : 'empty',
                    placeholder: textarea.placeholder,
                    className: textarea.className,
                    dataCy: textarea.getAttribute('data-cy'),
                    id: textarea.id
                });
                
                if (isVisible && hasContent && isEditable) {
                    candidateTextareas.push({
                        textarea,
                        content: textarea.value.trim(),
                        score: 0
                    });
                }
            }
            
            console.log(`üéß Found ${candidateTextareas.length} candidate textareas with content`);
            
            // Score textareas to find the most likely translation textarea
            for (const candidate of candidateTextareas) {
                const textarea = candidate.textarea;
                
                // Check for translation-related indicators
                if (textarea.placeholder?.toLowerCase().includes('translation')) candidate.score += 10;
                if (textarea.className?.includes('translation')) candidate.score += 10;
                if (textarea.getAttribute('data-cy')?.includes('translation')) candidate.score += 10;
                if (textarea.closest('[data-cy*="translation"]')) candidate.score += 8;
                if (textarea.closest('.translation-panel')) candidate.score += 8;
                if (textarea.closest('.target-editor')) candidate.score += 8;
                if (textarea.parentElement?.className?.includes('translation')) candidate.score += 5;
                if (textarea.parentElement?.getAttribute('data-cy')?.includes('translation')) candidate.score += 5;
                
                // Check if this textarea is focused
                if (document.activeElement === textarea) candidate.score += 15;
                
                // Check if content looks like non-English (likely translation)
                const hasNonEnglishChars = /[√°√©√≠√≥√∫√±√º¬ø¬°√†√®√¨√≤√π√ß√¢√™√Æ√¥√ª√§√∂√º]/i.test(candidate.content);
                if (hasNonEnglishChars) candidate.score += 5;
                
                console.log(`üéß Textarea scored ${candidate.score} points:`, candidate.content.substring(0, 50) + '...');
            }
            
            // Sort by score and return the highest scoring textarea
            candidateTextareas.sort((a, b) => b.score - a.score);
            
            if (candidateTextareas.length > 0) {
                const best = candidateTextareas[0];
                console.log(`üéß Selected best textarea (score: ${best.score}):`, best.content.substring(0, 50) + '...');
                return best.content;
            }
            
            console.log('üéß No suitable textarea content found');
            return null;
        }

        async function previewTranslation() {
            console.log('üéß === PREVIEW TRANSLATION ===');
            
            // Get the current context 
            const context = getEnhancedCrowdinContext();
            
            // Try multiple sources for the most current text (prioritize recent edits)
            let textToPreview = null;
            let textSource = '';
            
            // 1. Check for latest edited text from textarea.edited events
            if (window.latestEditedText && window.latestEditedText.trim()) {
                textToPreview = window.latestEditedText;
                textSource = 'latestEditedText (from textarea.edited event)';
            }
            
            // 2. Try to get current text from active textarea (for unsaved content)
            if (!textToPreview) {
                textToPreview = getCurrentTextareaContent();
                if (textToPreview) textSource = 'active textarea content';
            }
            
            // 3. Check receivedContext for recent translation updates
            if (!textToPreview && receivedContext.hasActiveTranslation && receivedContext.targetString) {
                const timeSinceEdit = Date.now() - (receivedContext.translationTimestamp || 0);
                if (timeSinceEdit < 30000) { // Use if edited within last 30 seconds
                    textToPreview = receivedContext.targetString;
                    textSource = 'receivedContext.targetString (recent edit)';
                }
            }
            
            // 4. Fall back to standard context data
            if (!textToPreview) {
                textToPreview = context.targetString || receivedContext.targetString || 
                               context.sourceString || receivedContext.sourceString ||
                               context.stringKey || receivedContext.stringKey;
                if (textToPreview) textSource = 'context/receivedContext fallback';
            }
            
            console.log('üéß Text source priority: latestEditedText ‚Üí textarea ‚Üí recent context ‚Üí fallback');
            console.log(`üéß Selected text source: ${textSource}`);
            
            if (!textToPreview) {
                console.error('üéß No text found to preview');
                showStatus('No text found to preview', 'error');
                return;
            }
            
            // Detect the language of the text
            const detectedLanguage = detectTargetLanguage(context) || 
                                   detectLanguageFromText(textToPreview) || 'en';
            
            console.log(`üéß Previewing text: "${textToPreview.substring(0, 50)}..."`);
            console.log(`üéß Detected language: ${detectedLanguage}`);
            
            const service = getDefaultServiceForLanguage(detectedLanguage);
            
            // Ensure ElevenLabs voices are loaded to populate updated defaults
            if (service === 'ElevenLabs') {
                console.log('üéß Loading ElevenLabs voices to ensure updated defaults...');
                try {
                    await audioManager.loadVoices('ElevenLabs', detectedLanguage);
                } catch (error) {
                    console.warn('üéß Failed to load ElevenLabs voices, using fallback:', error);
                }
            }
            
            // Get default voice for the language (now should have updated voices)
            const defaultVoice = getDefaultVoiceForLanguage(detectedLanguage);
            
            if (!defaultVoice || !service) {
                console.error(`üéß No default voice/service found for language: ${detectedLanguage}`);
                showStatus(`No default voice found for ${detectedLanguage}`, 'error');
                return;
            }
            
            console.log(`üéß Using ${service} voice: ${defaultVoice.name || defaultVoice.id} (ID: ${defaultVoice.id})`);
            
            if (!defaultVoice.id) {
                console.error('üéß Voice ID is missing, cannot generate audio');
                showStatus('Voice ID missing - please select ElevenLabs service first', 'error');
                return;
            }
            
            showStatus(`Generating preview with ${service}...`, 'info');
            
            try {
                // Generate and play audio using the audio manager
                await audioManager.generateAudio(service, defaultVoice.id, textToPreview);
                showStatus('Preview completed!', 'success');
            } catch (error) {
                console.error('üéß Preview failed:', error);
                showStatus('Preview failed: ' + error.message, 'error');
            }
        }
        
        function getDefaultVoiceForLanguage(languageCode) {
            // Check if we have updated voices from the actual ElevenLabs library
            if (window.updatedDefaultVoices && Object.keys(window.updatedDefaultVoices).length > 0) {
                const normalizedLang = languageCode.toLowerCase();
                const updatedVoice = window.updatedDefaultVoices[normalizedLang] || 
                                   window.updatedDefaultVoices[normalizedLang.split('-')[0]] || // Try without region code
                                   window.updatedDefaultVoices['en']; // Fallback to English
                
                if (updatedVoice) {
                    console.log(`üéØ Using updated voice for ${languageCode}: ${updatedVoice.name} (${updatedVoice.id})`);
                    return updatedVoice;
                }
            }
            
            // Fallback to static default voices if no updated voices available
            const defaultVoices = {
                'en': { name: 'Clara', service: 'ElevenLabs', language_code: 'en' },
                'es': { name: 'Malena Tango', service: 'ElevenLabs', language_code: 'es-CO' },
                'es-CO': { name: 'Malena Tango', service: 'ElevenLabs', language_code: 'es-CO' },
                'de': { name: 'Julia', service: 'ElevenLabs', language_code: 'de' },
                'de-CH': { name: 'Julia', service: 'ElevenLabs', language_code: 'de-CH' },
                'fr': { name: 'Caroline', service: 'ElevenLabs', language_code: 'fr-CA' },
                'fr-CA': { name: 'Caroline', service: 'ElevenLabs', language_code: 'fr-CA' },
                'nl': { name: 'Emma', service: 'ElevenLabs', language_code: 'nl' }
            };
            
            const normalizedLang = languageCode.toLowerCase();
            const fallbackVoice = defaultVoices[normalizedLang] || defaultVoices['en'];
            console.log(`‚ö†Ô∏è Using fallback voice for ${languageCode}: ${fallbackVoice.name} (no ID)`);
            return fallbackVoice;
        }
        
        function getDefaultServiceForLanguage(languageCode) {
            // Use ElevenLabs as default service for all languages based on language configuration
            return 'ElevenLabs';
        }

        async function playCurrentAudio() {
            try {
                console.log('üéµ === PLAY CURRENT AUDIO DEBUG START ===');
                console.log('üéµ Current URL:', window.location.href);
                console.log('üéµ Parent URL:', window.parent ? window.parent.location.href : 'No parent');
                console.log('üéµ receivedContext:', JSON.stringify(receivedContext, null, 2));
                
                showStatus('Looking for existing audio...', 'loading');
                
                // Stop any currently playing audio and clear references
                if (window.currentAudio) {
                    window.currentAudio.pause();
                    window.currentAudio.currentTime = 0;
                    window.currentAudio.src = '';
                    window.currentAudio = null;
                    console.log('üõë Stopped and cleared previous audio');
                }
                
                // Clear any cached audio for this itemId to prevent language mixing
                if (window.lastPlayedLanguage && window.lastPlayedItemId) {
                    console.log('üóëÔ∏è Clearing cached audio references for language switch');
                    // Force garbage collection of previous audio references
                    window.lastPlayedAudio = null;
                }
                
                // Also stop any other audio elements that might be playing
                const audioElements = document.querySelectorAll('audio');
                audioElements.forEach(audio => {
                    if (!audio.paused) {
                        audio.pause();
                        audio.currentTime = 0;
                        console.log('üõë Stopped lingering audio element');
                    }
                });
                
                // Force refresh context before playing
                console.log('üîÑ Forcing context refresh before play...');
                await refreshContext();
                
                // If no context yet, aggressively request it from Crowdin
                if (!receivedContext.stringId && !receivedContext.targetString) {
                    console.log('‚ö†Ô∏è No context available, requesting from Crowdin...');
                    requestCrowdinContext();
                    
                    // Wait a moment for response
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    console.log('üîÑ Context after request:', receivedContext);
                }
                
                // Get current Crowdin context with detailed debugging
                const context = getEnhancedCrowdinContext();
                console.log('üéµ === PLAY CURRENT AUDIO DEBUG ===');
                console.log('üéµ Timestamp:', new Date().toISOString());
                console.log('üéµ receivedContext (raw):', JSON.stringify(receivedContext, null, 2));
                console.log('üéµ FULL CONTEXT DEBUG:', JSON.stringify(context, null, 2));
                console.log('üéµ Context keys:', Object.keys(context));
                
                // Try multiple ways to get the string ID/key with detailed logging
                console.log('üéµ STRING EXTRACTION DEBUG:');
                console.log('  - context.targetString:', context.targetString);
                console.log('  - context.sourceString:', context.sourceString);
                console.log('  - context.stringKey:', context.stringKey);
                console.log('  - context.key:', context.key);
                console.log('  - context.identifier:', context.identifier);
                console.log('  - context.text:', context.text);
                console.log('  - context.stringId:', context.stringId);
                
                // Also check receivedContext directly
                console.log('üéµ RECEIVED CONTEXT DIRECT CHECK:');
                console.log('  - receivedContext.targetString:', receivedContext.targetString);
                console.log('  - receivedContext.sourceString:', receivedContext.sourceString);
                console.log('  - receivedContext.stringKey:', receivedContext.stringKey);
                console.log('  - receivedContext.identifier:', receivedContext.identifier);
                console.log('  - receivedContext.stringId:', receivedContext.stringId);
                
                // For GCP bucket, we need the item ID (identifier/stringKey) - try both contexts
                const itemId = context.identifier || context.stringKey || context.key || context.stringId ||
                              receivedContext.identifier || receivedContext.stringKey || receivedContext.stringId;
                const displayText = context.targetString || context.sourceString || context.text ||
                                  receivedContext.targetString || receivedContext.sourceString;
                
                // Use enhanced language detection - prioritize receivedContext
                const enhancedContext = { ...context, ...receivedContext };
                console.log('üåç Enhanced context for language detection:', enhancedContext);
                const languageCode = detectTargetLanguage(enhancedContext);
                
                console.log('üéµ SELECTED VALUES:');
                console.log('  - itemId (for GCP bucket):', JSON.stringify(itemId));
                console.log('  - displayText (for reference):', JSON.stringify(displayText));
                console.log('  - languageCode (detected):', JSON.stringify(languageCode));
                console.log('  - itemId type:', typeof itemId);
                console.log('  - itemId length:', itemId ? itemId.length : 'null');
                console.log('üéµ === END DEBUG ===');
                
                if (!itemId) {
                    console.log('üéµ No item ID found in either context. Contexts:', {
                        enhancedContext: context,
                        receivedContext: receivedContext
                    });
                    showStatus('No item ID found to play audio for. Try selecting a string in the editor first.', 'error');
                    return;
                }
                
                console.log('üéµ === AUDIO PLAYBACK ATTEMPT ===');
                console.log('üéµ Looking for audio with:', { 
                    itemId, 
                    displayText, 
                    languageCode,
                    timestamp: new Date().toISOString()
                });
                
                // Track language switches for the same item
                if (window.lastPlayedItemId === itemId && window.lastPlayedLanguage !== languageCode) {
                    console.log('üîÑ Language switch detected for same item:', {
                        itemId,
                        from: window.lastPlayedLanguage,
                        to: languageCode
                    });
                }
                
                // Store current playback info for next comparison
                window.lastPlayedItemId = itemId;
                window.lastPlayedLanguage = languageCode;
                
                // Use GCP bucket logic (adapted from source_dashboard.js)
                await playExistingAudioFromGCP(itemId, languageCode);
                
            } catch (error) {
                console.error('Error in playCurrentAudio:', error);
                showStatus(`Error playing audio: ${error.message}`, 'error');
            }
        }

        // Map language codes specifically for GCP bucket structure
        function mapLanguageCodeForGCP(langCode) {
            if (!langCode) return 'en';
            
            const lang = langCode.toLowerCase();
            console.log('üåç === GCP LANGUAGE MAPPING DEBUG ===');
            console.log('üåç Input language code:', langCode);
            console.log('üåç Normalized language code:', lang);
            
            // Map regional language codes to match GCP bucket folder structure
            const gcpLanguageMappings = {
                'en': 'en', 'en-us': 'en', 'en-gb': 'en', 'en-ca': 'en',
                'es': 'es-CO', 'es-co': 'es-CO', 'es-mx': 'es-CO', 'es-es': 'es-CO',  // Spanish uses es-CO folder
                'fr': 'fr', 'fr-ca': 'fr', 'fr-fr': 'fr', 'frca': 'fr',
                'pt': 'pt', 'pt-br': 'pt', 'pt-pt': 'pt',
                'de': 'de', 'de-de': 'de',
                'nl': 'nl', 'nl-nl': 'nl', 'nl-be': 'nl',
                'it': 'it', 'it-it': 'it'
            };
            
            const mappedLang = gcpLanguageMappings[lang] || lang.split('-')[0] || 'en';
            
            console.log('üåç Available GCP mappings for Spanish:');
            console.log('  - "es" maps to:', gcpLanguageMappings['es']);
            console.log('  - "es-co" maps to:', gcpLanguageMappings['es-co']);
            console.log('  - "es-mx" maps to:', gcpLanguageMappings['es-mx']);
            console.log('  - "es-es" maps to:', gcpLanguageMappings['es-es']);
            console.log('üåç GCP language mapping result:', lang, '->', mappedLang);
            console.log('üåç === END GCP LANGUAGE MAPPING DEBUG ===');
            
            return mappedLang;
        }

        // GCP bucket audio player (based on source_dashboard.js logic)
        async function playExistingAudioFromGCP(itemId, langCode) {
            try {
                // Map the language code for GCP bucket structure
                const gcpLangCode = mapLanguageCodeForGCP(langCode);
                
                // Construct GCS bucket URL for audio file using simplified structure
                const audioUrl = `https://storage.googleapis.com/levante-assets-dev/audio/${gcpLangCode}/${itemId}.mp3`;
                
                console.log('üéµ === GCP AUDIO ATTEMPT ===');
                console.log('üéµ GCP bucket URL construction:');
                console.log('  - Original langCode:', langCode);
                console.log('  - Mapped GCP langCode:', gcpLangCode);
                console.log('  - itemId:', itemId);
                console.log('  - Final URL:', audioUrl);
                console.log('  - Timestamp:', new Date().toISOString());
                
                // Special debugging for German audio issues
                if (gcpLangCode === 'de') {
                    console.log('üá©üá™ === GERMAN AUDIO DEBUG ===');
                    console.log('üá©üá™ This is a German audio request');
                    console.log('üá©üá™ Previous language for this item:', window.lastPlayedLanguage);
                    console.log('üá©üá™ URL will include lang parameter to prevent caching:', `lang=${gcpLangCode}`);
                    console.log('üá©üá™ Will check for voice update fallback after attempting GCP');
                    console.log('üá©üá™ === END GERMAN AUDIO DEBUG ===');
                }
                
                showStatus(`Loading existing audio for ${itemId} (${gcpLangCode})...`, 'loading');
                
                // Try to load and play the audio with enhanced cache busting
                // Include language code to prevent cross-language caching issues
                const cacheBustUrl = `${audioUrl}?lang=${gcpLangCode}&t=${Date.now()}`;
                console.log('üéµ Cache-busted URL (with language):', cacheBustUrl);
                
                // INVESTIGATION MODE: Let's find out where the new German audio actually is
                if (gcpLangCode === 'de') {
                    console.log('üîç === GERMAN AUDIO INVESTIGATION ===');
                    console.log('üîç Temporarily disabling force generation to debug where new audio is located');
                    console.log('üîç Will try multiple possible paths and log results');
                    
                    // Try alternative bucket structures that might be used for new audio
                    const possibleUrls = [
                        // Current structure
                        `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}.mp3`,
                        // With voice ID suffix
                        `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}_new.mp3`,
                        `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}_updated.mp3`,
                        // In a separate subfolder
                        `https://storage.googleapis.com/levante-assets-dev/audio/de/new/${itemId}.mp3`,
                        `https://storage.googleapis.com/levante-assets-dev/audio/de/updated/${itemId}.mp3`,
                        // Production bucket
                        `https://storage.googleapis.com/levante-assets-prod/audio/de/${itemId}.mp3`,
                        // GitHub repository structure (like audio-previewer uses)
                        `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/de/shared/${itemId}.mp3`,
                        `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/general/de/shared/${itemId}.mp3`
                    ];
                    
                    console.log('üîç Will test these possible URLs for new German audio:');
                    possibleUrls.forEach((url, index) => {
                        console.log(`üîç ${index + 1}. ${url}`);
                    });
                    console.log('üîç === END GERMAN AUDIO INVESTIGATION ===');
                }
                
                const audio = new Audio(cacheBustUrl);
                audio.id = `audio_${itemId}_${Date.now()}`;
                
                audio.addEventListener('loadstart', () => {
                    console.log('üéµ Audio loading started');
                    showStatus(`Loading audio: ${itemId}`, 'info');
                });
                
                audio.addEventListener('canplaythrough', () => {
                    console.log('üéµ Audio can play through, starting playback');
                    showStatus(`Playing existing audio: ${itemId}`, 'success');
                    
                    // Store reference to current audio for stopping later
                    window.currentAudio = audio;
                    
                    audio.play().catch(error => {
                        console.error('Error starting playback:', error);
                        showStatus(`Error starting playback: ${error.message}`, 'error');
                    });
                });
                
                audio.addEventListener('error', async (e) => {
                    console.warn('Audio file not found in GCP bucket (levante-assets-dev/audio):', audioUrl);
                    console.warn('Audio error details:', e);
                    
                    // INVESTIGATION MODE: For German, try alternative URLs to find new audio
                    if (gcpLangCode === 'de') {
                        console.log('üîç === TESTING ALTERNATIVE GERMAN AUDIO LOCATIONS ===');
                        
                        const alternativeUrls = [
                            // With voice ID suffix
                            `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}_new.mp3`,
                            `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}_updated.mp3`,
                            // In a separate subfolder
                            `https://storage.googleapis.com/levante-assets-dev/audio/de/new/${itemId}.mp3`,
                            `https://storage.googleapis.com/levante-assets-dev/audio/de/updated/${itemId}.mp3`,
                            // Production bucket
                            `https://storage.googleapis.com/levante-assets-prod/audio/de/${itemId}.mp3`,
                            // GitHub repository structure (like audio-previewer uses)
                            `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/de/shared/${itemId}.mp3`,
                            `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/general/de/shared/${itemId}.mp3`
                        ];
                        
                        for (let i = 0; i < alternativeUrls.length; i++) {
                            const testUrl = alternativeUrls[i];
                            console.log(`üîç Testing alternative URL ${i + 1}/${alternativeUrls.length}: ${testUrl}`);
                            
                            try {
                                const testAudio = new Audio(testUrl + `?t=${Date.now()}`);
                                
                                // Test if this URL loads successfully
                                const audioLoadPromise = new Promise((resolve, reject) => {
                                    testAudio.addEventListener('canplaythrough', () => {
                                        console.log(`üéØ SUCCESS! Found German audio at: ${testUrl}`);
                                        showStatus(`Found updated German audio at alternative location!`, 'success');
                                        
                                        // Store reference and play
                                        window.currentAudio = testAudio;
                                        testAudio.play();
                                        resolve(true);
                                    });
                                    
                                    testAudio.addEventListener('error', () => {
                                        console.log(`üîç Alternative URL ${i + 1} failed: ${testUrl}`);
                                        reject(false);
                                    });
                                    
                                    // Timeout after 3 seconds
                                    setTimeout(() => reject(false), 3000);
                                });
                                
                                testAudio.load();
                                const success = await audioLoadPromise;
                                if (success) {
                                    console.log('üîç === INVESTIGATION COMPLETE - FOUND AUDIO ===');
                                    return; // Exit early - we found and played the audio
                                }
                                
                            } catch (error) {
                                console.log(`üîç Alternative URL ${i + 1} error:`, error);
                            }
                        }
                        
                        console.log('üîç === NO ALTERNATIVE URLS WORKED - USING LIVE GENERATION ===');
                        
                        // If none of the alternative URLs worked, generate fresh audio
                        try {
                            let textToGenerate = receivedContext.targetString || receivedContext.sourceString;
                            if (!textToGenerate) {
                                const context = getEnhancedCrowdinContext();
                                textToGenerate = context.targetString || context.sourceString || context.stringKey;
                            }
                            
                            if (textToGenerate) {
                                const detectedLanguage = detectTargetLanguage() || detectLanguageFromText(textToGenerate) || gcpLangCode;
                                const defaultVoice = getDefaultVoiceForLanguage(detectedLanguage);
                                const service = getDefaultServiceForLanguage(detectedLanguage);
                                
                                console.log(`üîÑ No stored audio found - generating live ${detectedLanguage} audio`);
                                showStatus(`No German audio found in any location - generating fresh audio...`, 'info');
                                
                                if (defaultVoice && defaultVoice.id && service) {
                                    if (service === 'ElevenLabs') {
                                        await audioManager.loadVoices('ElevenLabs', detectedLanguage);
                                    }
                                    
                                    await audioManager.generateAudio(service, defaultVoice.id, textToGenerate);
                                    showStatus(`Generated fresh ${detectedLanguage} audio!`, 'success');
                                    return;
                                }
                            }
                        } catch (liveGenError) {
                            console.error('Live generation fallback failed:', liveGenError);
                            showStatus(`All German audio options failed: ${liveGenError.message}`, 'error');
                        }
                        
                        console.log('üîç === INVESTIGATION COMPLETE - NO AUDIO FOUND ===');
                        return; // Exit early for German - we've exhausted all options
                    }
                    
                    // Original fallback logic - try alternative language mappings
                    if (gcpLangCode !== langCode && gcpLangCode !== 'en') {
                        console.log('üéµ Trying fallback to English...');
                        const fallbackUrl = `https://storage.googleapis.com/levante-assets-dev/audio/en/${itemId}.mp3`;
                        console.log('üéµ Fallback URL:', fallbackUrl);
                        
                        const fallbackAudio = new Audio(fallbackUrl);
                        fallbackAudio.addEventListener('canplaythrough', () => {
                            console.log('üéµ Fallback audio found, playing English version');
                            showStatus(`Playing English audio for ${itemId} (no ${gcpLangCode} version found)`, 'warning');
                            
                            // Store reference to current audio for stopping later
                            window.currentAudio = fallbackAudio;
                            
                            fallbackAudio.play();
                        });
                        fallbackAudio.addEventListener('error', () => {
                            showStatus(`No existing audio found for ${itemId} in ${gcpLangCode} or English. Try generating with PlayHT or ElevenLabs.`, 'warning');
                        });
                    } else {
                        showStatus(`No existing audio found for ${itemId}. Try generating with PlayHT or ElevenLabs.`, 'warning');
                    }
                });
                
                audio.addEventListener('ended', () => {
                    console.log('üéµ Audio playback finished');
                    showStatus(`Finished playing ${itemId}`, 'success');
                });
                
                // Load the audio file
                audio.load();
                
            } catch (error) {
                console.error('Error playing existing audio from GCP:', error);
                showStatus(`Error playing existing audio: ${error.message}`, 'error');
            }
        }

        // Credential Management Functions (based on levante_translations/dashboard.js)
        function saveCredentials() {
            const credentials = {
                playhtApiKey: document.getElementById('playhtApiKey').value,
                playhtUserId: document.getElementById('playhtUserId').value,
                elevenlabsApiKey: document.getElementById('elevenlabsApiKey').value
            };

            // Save to localStorage with multiple backup keys (same as dashboard.js)
            localStorage.setItem('PLAY_DOT_HT_API_KEY', credentials.playhtApiKey);
            localStorage.setItem('playht_api_key', credentials.playhtApiKey);
            localStorage.setItem('PLAYHT_API_KEY', credentials.playhtApiKey);
            localStorage.setItem('PLAY_DOT_HT_USER_ID', credentials.playhtUserId);
            localStorage.setItem('playht_user_id', credentials.playhtUserId);
            localStorage.setItem('PLAYHT_USER_ID', credentials.playhtUserId);
            localStorage.setItem('ELEVENLABS_API_KEY', credentials.elevenlabsApiKey);
            localStorage.setItem('elevenlabs_api_key', credentials.elevenlabsApiKey);
            localStorage.setItem('ELEVEN_LABS_API_KEY', credentials.elevenlabsApiKey);

            // Also save to sessionStorage as backup
            sessionStorage.setItem('PLAY_DOT_HT_API_KEY', credentials.playhtApiKey);
            sessionStorage.setItem('PLAY_DOT_HT_USER_ID', credentials.playhtUserId);
            sessionStorage.setItem('ELEVENLABS_API_KEY', credentials.elevenlabsApiKey);

            // Update the audio manager's API config
            audioManager.apiConfig.playht.apiKey = credentials.playhtApiKey;
            audioManager.apiConfig.playht.userId = credentials.playhtUserId;
            audioManager.apiConfig.elevenlabs.apiKey = credentials.elevenlabsApiKey;

            updateCredentialStatus();
            showStatus('Credentials saved successfully with backup storage!', 'success');
            
            // Close the modal
            document.getElementById('credentialsModal').style.display = 'none';
        }

        function loadCredentials() {
            // Reload credentials in AudioManager first
            audioManager.loadCredentials();

            // Update form fields with the loaded credentials
            document.getElementById('playhtApiKey').value = audioManager.apiConfig.playht.apiKey || '';
            document.getElementById('playhtUserId').value = audioManager.apiConfig.playht.userId || '';
            document.getElementById('elevenlabsApiKey').value = audioManager.apiConfig.elevenlabs.apiKey || '';

            updateCredentialStatus();
        }

        function recoverCredentials() {
            // Try to recover from all possible storage locations
            const sources = [
                { name: 'localStorage', storage: localStorage },
                { name: 'sessionStorage', storage: sessionStorage }
            ];

            const keys = [
                { api: 'playht_key', variants: ['PLAY_DOT_HT_API_KEY', 'playht_api_key', 'PLAYHT_API_KEY'] },
                { api: 'playht_user', variants: ['PLAY_DOT_HT_USER_ID', 'playht_user_id', 'PLAYHT_USER_ID'] },
                { api: 'elevenlabs', variants: ['ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY'] }
            ];

            let recovered = { playht_key: '', playht_user: '', elevenlabs: '' };
            let recoveryCount = 0;

            sources.forEach(source => {
                keys.forEach(keyGroup => {
                    if (!recovered[keyGroup.api]) {
                        keyGroup.variants.forEach(variant => {
                            const value = source.storage.getItem(variant);
                            if (value && value.length > 10) {
                                recovered[keyGroup.api] = value;
                                recoveryCount++;
                            }
                        });
                    }
                });
            });

            if (recoveryCount > 0) {
                document.getElementById('playhtApiKey').value = recovered.playht_key;
                document.getElementById('playhtUserId').value = recovered.playht_user;
                document.getElementById('elevenlabsApiKey').value = recovered.elevenlabs;
                
                updateCredentialStatus();
                showStatus(`Recovered ${recoveryCount} credential(s) from backup storage!`, 'success');
            } else {
                showStatus('No backup credentials found in storage.', 'error');
            }
        }

        function clearCredentials() {
            if (confirm('Are you sure you want to clear all stored credentials?')) {
                // Clear from all storage locations
                const keys = [
                    'PLAY_DOT_HT_API_KEY', 'playht_api_key', 'PLAYHT_API_KEY',
                    'PLAY_DOT_HT_USER_ID', 'playht_user_id', 'PLAYHT_USER_ID',
                    'ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY'
                ];

                keys.forEach(key => {
                    localStorage.removeItem(key);
                    sessionStorage.removeItem(key);
                });

                // Clear form fields
                document.getElementById('playhtApiKey').value = '';
                document.getElementById('playhtUserId').value = '';
                document.getElementById('elevenlabsApiKey').value = '';

                // Clear audio manager config
                audioManager.apiConfig.playht.apiKey = null;
                audioManager.apiConfig.playht.userId = null;
                audioManager.apiConfig.elevenlabs.apiKey = null;

                updateCredentialStatus();
                showStatus('All credentials cleared successfully.', 'success');
            }
        }

        function updateCredentialStatus() {
            const playhtKey = audioManager.apiConfig.playht.apiKey;
            const playhtUser = audioManager.apiConfig.playht.userId;
            const elevenlabsKey = audioManager.apiConfig.elevenlabs.apiKey;

            document.getElementById('playhtKeyStatus').textContent = 
                playhtKey && playhtKey.length > 10 ? '‚úÖ Present' : '‚ùå Not Set';
            document.getElementById('playhtKeyStatus').className = 
                playhtKey && playhtKey.length > 10 ? 'status-indicator present' : 'status-indicator missing';

            document.getElementById('playhtUserStatus').textContent = 
                playhtUser && playhtUser.length > 10 ? '‚úÖ Present' : '‚ùå Not Set';
            document.getElementById('playhtUserStatus').className = 
                playhtUser && playhtUser.length > 10 ? 'status-indicator present' : 'status-indicator missing';

            document.getElementById('elevenlabsKeyStatus').textContent = 
                elevenlabsKey && elevenlabsKey.length > 10 ? '‚úÖ Present' : '‚ùå Not Set';
            document.getElementById('elevenlabsKeyStatus').className = 
                elevenlabsKey && elevenlabsKey.length > 10 ? 'status-indicator present' : 'status-indicator missing';
        }

        function showCredentialsModal() {
            console.log('üîß MODAL: showCredentialsModal() called');
            console.trace('üîß MODAL: Call stack for showCredentialsModal');
            loadCredentials(); // Load current credentials
            document.getElementById('credentialsModal').style.display = 'block';
        }

        function closeCredentialsModal() {
            console.log('üîß MODAL: closeCredentialsModal() called');
            document.getElementById('credentialsModal').style.display = 'none';
        }

        // Manual credential testing function (call from browser console)
        window.testCredentials = function() {
            console.log('=== MANUAL CREDENTIAL TEST ===');
            
            // Test all possible credential keys
            const allKeys = [
                'PLAY_DOT_HT_API_KEY', 'playht_api_key', 'PLAYHT_API_KEY',
                'PLAY_DOT_HT_USER_ID', 'playht_user_id', 'PLAYHT_USER_ID',
                'ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY', 'ELEVENLABS_KEY'
            ];
            
            console.log('Testing localStorage:');
            allKeys.forEach(key => {
                const value = localStorage.getItem(key);
                console.log(`  ${key}: ${value ? `Present (${value.length} chars)` : 'Missing'}`);
            });
            
            console.log('Testing sessionStorage:');
            allKeys.forEach(key => {
                const value = sessionStorage.getItem(key);
                console.log(`  ${key}: ${value ? `Present (${value.length} chars)` : 'Missing'}`);
            });
            
            // Show current domain/origin
            console.log('Current domain:', window.location.origin);
            console.log('Current hostname:', window.location.hostname);
            
            // Force reload credentials
            audioManager.loadCredentials();
            console.log('AudioManager credentials after reload:', {
                playht: audioManager.apiConfig.playht.apiKey ? `Present (${audioManager.apiConfig.playht.apiKey.length} chars)` : 'Missing',
                playhtUser: audioManager.apiConfig.playht.userId ? `Present (${audioManager.apiConfig.playht.userId.length} chars)` : 'Missing',
                elevenlabs: audioManager.apiConfig.elevenlabs.apiKey ? `Present (${audioManager.apiConfig.elevenlabs.apiKey.length} chars)` : 'Missing'
            });
            console.log('=== END MANUAL TEST ===');
        };
        
        // Debug function specifically for ElevenLabs
        window.debugElevenLabs = function() {
            console.log('=== ELEVENLABS DEBUG ===');
            const possibleKeys = [
                'ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY', 'ELEVENLABS_KEY'
            ];
            
            console.log('Checking all possible ElevenLabs key names:');
            possibleKeys.forEach(key => {
                const localStorage_val = localStorage.getItem(key);
                const sessionStorage_val = sessionStorage.getItem(key);
                console.log(`  ${key}:`);
                console.log(`    localStorage: ${localStorage_val ? `Present (${localStorage_val.length} chars)` : 'Missing'}`);
                console.log(`    sessionStorage: ${sessionStorage_val ? `Present (${sessionStorage_val.length} chars)` : 'Missing'}`);
            });
            
            console.log('Current audioManager elevenlabs config:', {
                apiKey: audioManager.apiConfig.elevenlabs.apiKey ? `Present (${audioManager.apiConfig.elevenlabs.apiKey.length} chars)` : 'Missing'
            });
            console.log('=== END ELEVENLABS DEBUG ===');
        };

        // Manual debug function for testing context extraction
        try {
            window.debugContext = function() {
                try {
                    console.log('=== CONTEXT DEBUG ===');
                    console.log('üìã receivedContext:', JSON.stringify(receivedContext, null, 2));
                    console.log('üìã getEnhancedCrowdinContext():', JSON.stringify(getEnhancedCrowdinContext(), null, 2));
                    console.log('üìã URL params:', Object.fromEntries(new URLSearchParams(window.location.search)));
                    
                    // Test the playCurrentAudio logic manually
                    const context = getEnhancedCrowdinContext();
                    const stringKey = context.targetString || context.sourceString || context.stringKey || context.key || context.identifier;
                    const languageCode = context.targetLanguageId || context.sourceLanguageId || context.languageId || 'en';
                    
                    console.log('üìã Extracted for audio:', { stringKey, languageCode });
                    console.log('=== END DEBUG ===');
                    
                    return { receivedContext, context, stringKey, languageCode };
                } catch (error) {
                    console.error('Error in debugContext:', error);
                    return { error: error.message };
                }
            };
            console.log('‚úÖ debugContext function defined successfully');
        } catch (error) {
            console.error('‚ùå Failed to define debugContext function:', error);
        }
        
        // Simple debug function for testing context
        window.checkContext = function() {
            console.log('=== CONTEXT CHECK ===');
            console.log('receivedContext:', receivedContext);
            const enhanced = getEnhancedCrowdinContext();
            console.log('getEnhancedCrowdinContext():', enhanced);
            const stringKey = enhanced.targetString || enhanced.sourceString || enhanced.stringKey;
            console.log('Extracted text for audio:', stringKey);
            console.log('=== END CHECK ===');
        };
        
        // Debug function to show what would be used for audio
        try {
            window.debugAudio = function() {
                try {
                    const context = getEnhancedCrowdinContext();
                    const itemId = context.identifier || context.stringKey || context.key || context.stringId ||
                                  receivedContext.identifier || receivedContext.stringKey || receivedContext.stringId;
                    const displayText = context.targetString || context.sourceString || context.text ||
                                      receivedContext.targetString || receivedContext.sourceString;
                    const languageCode = detectTargetLanguage(context);
                    
                    console.log('üéµ AUDIO DEBUG SUMMARY:');
                    console.log('  - itemId that would be used:', itemId);
                    console.log('  - displayText that would be used:', displayText);
                    console.log('  - languageCode that would be used:', languageCode);
                    console.log('  - receivedContext snapshot:', JSON.stringify(receivedContext, null, 2));
                    
                    return { itemId, displayText, languageCode, receivedContext };
                } catch (error) {
                    console.error('Error in debugAudio:', error);
                    return { error: error.message };
                }
            };
            console.log('‚úÖ debugAudio function defined successfully');
        } catch (error) {
            console.error('‚ùå Failed to define debugAudio function:', error);
        }
        
        // Debug language detection specifically
        try {
            window.debugLanguageDetection = function() {
                console.log('üåç === LANGUAGE DETECTION DEBUG ===');
                console.log('üåç receivedContext:', JSON.stringify(receivedContext, null, 2));
                
                // Test the language detection function
                const enhancedContext = { ...receivedContext };
                console.log('üåç Enhanced context:', enhancedContext);
                
                const detectedLanguage = detectTargetLanguage(enhancedContext);
                console.log('üåç Detected language result:', detectedLanguage);
                
                // Test URL detection manually
                try {
                    if (window.parent && window.parent.location) {
                        const parentUrl = window.parent.location.href;
                        console.log('üåç Parent URL for manual check:', parentUrl);
                        
                        // Check for es-CO patterns
                        const hasEsCO = parentUrl.includes('es-CO') || parentUrl.includes('es_CO') || parentUrl.includes('esco');
                        console.log('üåç Contains es-CO pattern:', hasEsCO);
                        
                        if (hasEsCO) {
                            console.log('üåç ‚úÖ URL contains es-CO - should detect Spanish!');
                        } else {
                            console.log('üåç ‚ùå URL does not contain es-CO pattern');
                        }
                    }
                } catch (e) {
                    console.log('üåç Cannot access parent URL:', e.message);
                }
                
                return detectedLanguage;
            };
            console.log('‚úÖ debugLanguageDetection function defined successfully');
        } catch (error) {
            console.error('‚ùå Failed to define debugLanguageDetection function:', error);
        }

        console.log('üí° To debug context manually, run: debugContext()');
        console.log('üí° To debug audio extraction, run: debugAudio()');
        console.log('üí° To debug language detection, run: debugLanguageDetection()');
        console.log('üöÄ App loaded at:', new Date().toISOString());
        console.log('üîß Comfortable mode language detection fix v1');
        
        // Manual CSV export function
        try {
            window.exportVoiceLibraryCSV = function() {
                if (window.elevenLabsVoiceLibrary && window.elevenLabsVoiceLibrary.length > 0) {
                    audioManager.exportVoiceLibraryToCSV(window.elevenLabsVoiceLibrary);
                    console.log('üìù ‚úÖ Voice library exported to CSV');
                } else {
                    console.log('‚ö†Ô∏è No voice library loaded. Please select ElevenLabs service first to load voices.');
                }
            };
            console.log('‚úÖ exportVoiceLibraryCSV function defined successfully');
            console.log('üí° To export voice library to CSV, run: exportVoiceLibraryCSV()');
        } catch (error) {
            console.error('‚ùå Failed to define exportVoiceLibraryCSV function:', error);
        }

        // Test if functions are properly defined
        console.log('üîß Debug functions status:');
        console.log('  - debugContext:', typeof window.debugContext);
        console.log('  - debugAudio:', typeof window.debugAudio);
        console.log('  - receivedContext:', typeof receivedContext);
        console.log('  - getEnhancedCrowdinContext:', typeof getEnhancedCrowdinContext);
        console.log('  - exportVoiceLibraryCSV:', typeof window.exportVoiceLibraryCSV);
        
        // Add a manual context injection function for testing
        try {
            window.injectTestContext = function() {
                window.receivedContext = {
                    stringId: 52615,
                    identifier: "ToM-scene-15-q3-false_belief",
                    targetString: "¬øEs justo que pap√° se enfade con Sof√≠a por haber perdido su zapato?",
                    sourceString: "Is it fair that Dad is mad at Sophie for losing her shoe?",
                    stringKey: "Is it fair that Dad is mad at Sophie for losing her shoe?",
                    targetLanguageId: "es-CO",
                    fileId: 83
                };
                console.log('üß™ Test context injected:', window.receivedContext);
                console.log('üß™ Now try: debugAudio() or click the play button');
                return window.receivedContext;
            };
            console.log('‚úÖ injectTestContext function defined successfully');
            console.log('üí° To inject test context, run: injectTestContext()');
        } catch (error) {
            console.error('‚ùå Failed to define injectTestContext function:', error);
        }
        
        // Add immediate context check function
        try {
            window.quickContext = function() {
                console.log('‚ö° QUICK CONTEXT CHECK:');
                console.log('  receivedContext keys:', Object.keys(receivedContext));
                console.log('  receivedContext.stringId:', receivedContext.stringId);
                console.log('  receivedContext.identifier:', receivedContext.identifier);
                console.log('  receivedContext.targetString:', receivedContext.targetString);
                return receivedContext;
            };
            console.log('‚úÖ quickContext function defined successfully');
            console.log('üí° For quick context check, run: quickContext()');
        
        // Add manual language override function for testing
        try {
            window.setLanguage = function(langCode) {
                if (receivedContext) {
                    receivedContext.targetLanguageId = langCode;
                    console.log(`üåç Manually set target language to: ${langCode}`);
                    console.log('üåç Updated context:', receivedContext);
                } else {
                    console.log('‚ùå No receivedContext available to update');
                }
                return langCode;
            };
            console.log('‚úÖ setLanguage function defined successfully');
            console.log('üí° To manually set language, run: setLanguage("es-CO") or setLanguage("fr")');
        } catch (error) {
            console.error('‚ùå Failed to define setLanguage function:', error);
        }
        } catch (error) {
            console.error('‚ùå Failed to define quickContext function:', error);
        }

        // Initialize credentials and context on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ DOM Content Loaded - Initializing app...');
            
            // Initialize Crowdin context detection
            initializeContext();
            
            // Force reload credentials from storage
            audioManager.loadCredentials();
            loadCredentials();
            updateCredentialStatus();
            
            // Log current credentials for debugging
            console.log('Initialized credentials:', {
                playht: audioManager.apiConfig.playht.apiKey ? 'Present' : 'Missing',
                playhtUser: audioManager.apiConfig.playht.userId ? 'Present' : 'Missing', 
                elevenlabs: audioManager.apiConfig.elevenlabs.apiKey ? 'Present' : 'Missing'
            });
            
            // Add click event listeners with debugging
            const playBtn = document.getElementById('playAudioBtn');
            const previewBtn = document.getElementById('previewBtn');
            const generateBtn = document.getElementById('generateAudioBtn');
            const refreshBtn = document.getElementById('refreshBtn');
            
            if (playBtn) {
                playBtn.addEventListener('click', function() {
                    console.log('üéµ Play button clicked!');
                    playCurrentAudio();
                });
                console.log('‚úÖ Play button event listener added');
            } else {
                console.error('‚ùå Play button not found!');
            }
            
            if (previewBtn) {
                previewBtn.addEventListener('click', function() {
                    console.log('üéß Preview button clicked!');
                    previewTranslation();
                });
                console.log('‚úÖ Preview button event listener added');
            } else {
                console.error('‚ùå Preview button not found!');
            }
            
            const configBtn = document.getElementById('configBtn');
            if (configBtn) {
                configBtn.addEventListener('click', function() {
                    console.log('‚öôÔ∏è Config button clicked!');
                    showCredentialsModal();
                });
                console.log('‚úÖ Config button event listener added');
            } else {
                console.error('‚ùå Config button not found!');
            }
            
            if (generateBtn) {
                generateBtn.addEventListener('click', function() {
                    console.log('üé§ Generate button clicked!');
                    showAudioGeneration();
                });
                console.log('‚úÖ Generate button event listener added');
            } else {
                console.error('‚ùå Generate button not found!');
            }
            
            if (refreshBtn) {
                refreshBtn.addEventListener('click', function() {
                    console.log('üîÑ Refresh button clicked!');
                    refreshContext();
                });
                console.log('‚úÖ Refresh button event listener added');
            } else {
                console.error('‚ùå Refresh button not found!');
            }
            
            // Show instruction for manual testing
            console.log('üí° To manually test credentials, run: testCredentials()');
            console.log('üéØ App initialization complete!');
            
            // Let Crowdin handle iframe sizing automatically
        });

        // Debug function to check and force close modal
        window.debugModal = function() {
            const modal = document.getElementById('credentialsModal');
            const audioGen = document.getElementById('audioGeneration');
            const status = document.getElementById('status');
            
            console.log('üîß MODAL DEBUG:', {
                modal_display: modal ? modal.style.display : 'not found',
                audioGen_display: audioGen ? audioGen.style.display : 'not found',
                status_display: status ? status.style.display : 'not found',
                modal_visible: modal ? getComputedStyle(modal).display : 'not found'
            });
            
            return {
                modal: modal ? modal.style.display : 'not found',
                audioGen: audioGen ? audioGen.style.display : 'not found',
                status: status ? status.style.display : 'not found'
            };
        };
        
        // Force close all overlays
        window.forceCloseAll = function() {
            console.log('üîß FORCE CLOSING all overlays...');
            const modal = document.getElementById('credentialsModal');
            const audioGen = document.getElementById('audioGeneration');
            const status = document.getElementById('status');
            
            if (modal) {
                modal.style.display = 'none';
                console.log('üîß Closed credentials modal');
            }
            if (audioGen) {
                audioGen.style.display = 'none';
                console.log('üîß Closed audio generation');
            }
            if (status) {
                status.style.display = 'none';
                console.log('üîß Closed status');
            }
            
            console.log('üîß All overlays closed');
        };

        // WEBHOOK-STYLE MESSAGE HANDLER with Auto-Play
        async function enhancedMessageHandler(event) {
            // Only process messages from Crowdin origins
            if (!event.origin || !event.origin.includes('crowdin.com')) {
                return;
            }
            
            console.log('üì® Received message from Crowdin:', JSON.stringify({
                origin: event.origin,
                type: event.data?.type,
                etyp: event.data?.etyp
            }, null, 2));
            
            // WEBHOOK-STYLE: Process string.selected events (side-by-side mode)
            if (event.data && event.data.type === 'evt' && event.data.etyp === 'string.selected' && 
                event.data.evnt && event.data.evnt.length > 0) {
                
                const stringInfo = event.data.evnt[0];
                
                // ALWAYS store context for manual play
                if (stringInfo.string) {
                    receivedContext.stringId = stringInfo.string.id;
                    receivedContext.identifier = stringInfo.string.identifier;
                    receivedContext.sourceString = stringInfo.string.text;
                    receivedContext.stringKey = stringInfo.string.text;
                    receivedContext.fileId = stringInfo.string.file?.id;
                    
                    // Store translation if available
                    if (stringInfo.translations && Object.keys(stringInfo.translations).length > 0) {
                        for (const [langCode, translationArray] of Object.entries(stringInfo.translations)) {
                            if (translationArray && Array.isArray(translationArray) && translationArray.length > 0) {
                                const translation = translationArray[0];
                                if (translation && translation.text) {
                                    receivedContext.targetString = translation.text;
                                    receivedContext.targetLanguageId = langCode;
                                    receivedContext.languageCode = langCode;
                                    console.log(`üéµ WEBHOOK: Stored context with ${langCode} translation`);
                                    break;
                                }
                            }
                        }
                    } else {
                        // No translation, use source
                        receivedContext.targetString = stringInfo.string.text;
                        console.log('üéµ WEBHOOK: Stored context with source text (no translation)');
                    }
                }
                
                // Check if auto-play is enabled
                const autoPlayCheckbox = document.getElementById('autoPlayCheckbox');
                if (autoPlayCheckbox && autoPlayCheckbox.checked) {
                    if (stringInfo.translations && Object.keys(stringInfo.translations).length > 0) {
                        console.log('üéµ WEBHOOK: Auto-playing audio for selected string with translations');
                        
                        // Find the first available translation
                        for (const [langCode, translationArray] of Object.entries(stringInfo.translations)) {
                            if (translationArray && Array.isArray(translationArray) && translationArray.length > 0) {
                                const translation = translationArray[0];
                                if (translation && translation.text) {
                                    console.log(`üéµ WEBHOOK: Found ${langCode} translation, playing audio`);
                                    
                                    // Map language for GCP bucket
                                    const gcpLangCode = mapLanguageCodeForGCP(langCode);
                                    const itemId = stringInfo.string.identifier;
                                    
                                    if (itemId) {
                                        // Check if user has interacted first
                                        if (!userHasInteracted) {
                                            console.log('üéµ WEBHOOK: Waiting for user interaction before autoplay');
                                            return;
                                        }
                                        // Play immediately
                                        playExistingAudioFromGCP(itemId, gcpLangCode);
                                        return; // Exit early, don't process as normal context
                                    }
                                    break;
                                }
                            }
                        }
                    } else {
                        console.log('üéµ WEBHOOK: No translations found, skipping auto-play');
                    }
                } else {
                    console.log('üéµ WEBHOOK: Auto-play disabled, context stored for manual play');
                }
            }
            
            // WEBHOOK-STYLE: Process string.change events (comfortable mode)
            if (event.data && event.data.type === 'evt' && event.data.etyp === 'string.change' && event.data.evnt) {
                console.log('üéµ WEBHOOK: Processing string.change event for comfortable mode');
                
                const stringData = event.data.evnt;
                if (stringData && stringData.id && stringData.identifier) {
                    // Store basic context from string.change
                    receivedContext.stringId = stringData.id;
                    receivedContext.identifier = stringData.identifier;
                    receivedContext.sourceString = stringData.text;
                    receivedContext.stringKey = stringData.text;
                    receivedContext.fileId = stringData.file?.id;
                    
                    // In comfortable mode, we don't have translation data in string.change
                    // We'll try to get it from textarea.edited events or AP API
                    console.log(`üéµ WEBHOOK: Stored basic context for comfortable mode: ${stringData.identifier}`);
                }
            }
            
            // WEBHOOK-STYLE: Process textarea.edited events (comfortable mode)
            if (event.data && event.data.type === 'evt' && event.data.etyp === 'textarea.edited' && event.data.evnt) {
                console.log('üéµ WEBHOOK: Processing textarea.edited event for comfortable mode');
                console.log('üéµ textarea.edited data:', JSON.stringify(event.data.evnt, null, 2));
                
                const textareaData = event.data.evnt;
                
                // Check for newText first (current edit), then text, then oldText
                let editedText = textareaData.newText || textareaData.text || textareaData.oldText;
                
                if (editedText && editedText.trim() && receivedContext.stringId) {
                    // Update the target string with the edited text
                    receivedContext.targetString = editedText.trim();
                    receivedContext.hasActiveTranslation = true;
                    receivedContext.translationTimestamp = Date.now();
                    
                    // Try to detect language from the translated text
                    const detectedLang = detectLanguageFromText(editedText);
                    if (detectedLang) {
                        receivedContext.targetLanguageId = detectedLang;
                        receivedContext.languageCode = detectedLang;
                        console.log(`üéµ WEBHOOK: Updated comfortable mode context with translation (${detectedLang}): "${editedText.substring(0, 50)}..."`);
                    } else {
                        console.log(`üéµ WEBHOOK: Updated comfortable mode context with text (no lang detected): "${editedText.substring(0, 50)}..."`);
                    }
                    
                    // Store the latest edited text globally for immediate access
                    window.latestEditedText = editedText.trim();
                    console.log('üíæ Stored latest edited text globally for immediate access');
                } else {
                    console.log('üéµ WEBHOOK: No valid edited text found in textarea.edited event');
                }
            }
            
            // Process as normal context (rest of the enhanced message handler logic)
            // ... existing message processing logic would go here if needed
        }

        // Add event listener for webhook-style message handling
        window.addEventListener('message', enhancedMessageHandler);
        console.log('‚úÖ Webhook-style message handler registered');
        
        // Enable autoplay after any user interaction
        let userHasInteracted = false;
        function enableAutoplay() {
            if (!userHasInteracted) {
                userHasInteracted = true;
                console.log('‚úÖ User interaction detected, autoplay enabled');
            }
        }
        
        // Listen for any user interaction to enable autoplay
        document.addEventListener('click', enableAutoplay, { once: true });
        document.addEventListener('keydown', enableAutoplay, { once: true });
        document.addEventListener('touchstart', enableAutoplay, { once: true });
        
        // Debug helper function to investigate German audio locations
        window.debugGermanAudio = function(testItemId) {
            const itemId = testItemId || (receivedContext.identifier || receivedContext.stringKey || 'test-string-id');
            console.log('üîç === MANUAL GERMAN AUDIO DEBUG ===');
            console.log('üîç Testing itemId:', itemId);
            
            const testUrls = [
                `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}.mp3`,
                `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}_new.mp3`,
                `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}_updated.mp3`,
                `https://storage.googleapis.com/levante-assets-dev/audio/de/new/${itemId}.mp3`,
                `https://storage.googleapis.com/levante-assets-dev/audio/de/updated/${itemId}.mp3`,
                `https://storage.googleapis.com/levante-assets-prod/audio/de/${itemId}.mp3`,
                `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/de/shared/${itemId}.mp3`,
                `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/general/de/shared/${itemId}.mp3`
            ];
            
            testUrls.forEach((url, index) => {
                const audio = new Audio(url + `?t=${Date.now()}`);
                audio.addEventListener('canplaythrough', () => {
                    console.log(`üéØ FOUND AUDIO at location ${index + 1}: ${url}`);
                });
                audio.addEventListener('error', () => {
                    console.log(`‚ùå No audio at location ${index + 1}: ${url}`);
                });
                audio.load();
            });
            
            console.log('üîç === Check console for results in a few seconds ===');
        };
        
        // Quick debug function to show all possible German audio URLs for current string
        window.showGermanAudioUrls = function() {
            const itemId = receivedContext.identifier || receivedContext.stringKey || 'current-string-id';
            console.log('üîç === ALL POSSIBLE GERMAN AUDIO URLS ===');
            console.log('üîç For itemId:', itemId);
            console.log('üîç Primary GCP bucket:', `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}.mp3`);
            console.log('üîç With suffix:', `https://storage.googleapis.com/levante-assets-dev/audio/de/${itemId}_new.mp3`);
            console.log('üîç In subfolder:', `https://storage.googleapis.com/levante-assets-dev/audio/de/new/${itemId}.mp3`);
            console.log('üîç Prod bucket:', `https://storage.googleapis.com/levante-assets-prod/audio/de/${itemId}.mp3`);
            console.log('üîç GitHub repo:', `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/de/shared/${itemId}.mp3`);
            console.log('üîç Call debugGermanAudio() to test which ones work');
        };

        // Update deployment timestamp
        console.log('üîß GCP Bucket Path Corrected: levante-assets-dev/audio - ' + new Date().toISOString());
        console.log('üîß Available debug functions: debugGermanAudio(), showGermanAudioUrls()');
    </script>
</body>
</html> "// Cache buster $(date)" 
