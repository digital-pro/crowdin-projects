<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Levante Audio Test</title>
    <script src="https://cdn.crowdin.com/apps/dist/iframe.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 200px;
            height: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 400px;
            width: 100%;
            min-height: 160px;
            height: auto;
        }
        
        h1 {
            color: #333;
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 6px;
            font-weight: 500;
            font-size: 11px;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .audio-section {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #eee;
        }
        
        .audio-buttons {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        
        .audio-btn {
            flex: 1;
            min-width: 110px;
            background: linear-gradient(45deg, #9C27B0, #673AB7);
        }
        
        .audio-generation {
            background: rgba(108, 117, 125, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-top: 8px;
            border: 1px solid rgba(108, 117, 125, 0.2);
        }
        
        .service-selection,
        .voice-selection {
            margin-bottom: 8px;
        }
        
        .service-selection label,
        .voice-selection label {
            display: block;
            margin-bottom: 3px;
            font-weight: 600;
            color: #333;
            font-size: 11px;
        }
        
        select {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
            background-color: white;
        }
        
        .generate-controls {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            align-items: center;
        }
        
        .settings-btn {
            background: linear-gradient(45deg, #6c757d, #495057);
            font-size: 10px;
            padding: 6px 12px;
        }
        
        .generate-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            flex: 1;
        }
        
        .loading-spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 5px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 2% auto;
            padding: 0;
            border: none;
            border-radius: 12px;
            width: 85%;
            max-width: 450px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 12px 12px 0 0;
            position: relative;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }
        
        .close {
            color: white;
            float: right;
            font-size: 24px;
            font-weight: bold;
            position: absolute;
            right: 15px;
            top: 8px;
            cursor: pointer;
        }
        
        .close:hover {
            opacity: 0.7;
        }
        
        .modal-body {
            padding: 15px 20px;
        }
        
        .credential-section {
            margin-bottom: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .credential-section h3 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 13px;
            font-weight: 600;
        }
        
        .credential-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }
        
        .credential-row:last-child {
            margin-bottom: 0;
        }
        
        .credential-row label {
            min-width: 80px;
            font-weight: 500;
            color: #666;
            font-size: 11px;
        }
        
        .credential-row input {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .password-toggle {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 4px;
            font-size: 11px;
        }
        
        .modal-footer {
            padding: 12px 20px;
            border-top: 1px solid #eee;
            text-align: right;
            border-radius: 0 0 12px 12px;
        }
        
        .modal-footer button {
            margin-left: 8px;
            font-size: 11px;
            padding: 6px 12px;
        }
        
        .credentials-form {
            padding: 30px;
        }
        
        .credential-group {
            margin-bottom: 20px;
            position: relative;
        }
        
        .credential-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }
        
        .credential-group input {
            width: 100%;
            padding: 12px 45px 12px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: monospace;
            background: #f9f9f9;
            transition: border-color 0.3s, background-color 0.3s;
        }
        
        .credential-group input:focus {
            outline: none;
            border-color: #4facfe;
            background: white;
        }
        
        .toggle-visibility {
            position: absolute;
            right: 10px;
            top: 35px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 5px;
        }
        
        .toggle-visibility:hover {
            opacity: 0.7;
        }
        
        .credentials-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .credentials-buttons .btn {
            flex: 1;
            min-width: 120px;
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
        }
        
        .btn-success {
            background: linear-gradient(45deg, #43e97b, #38f9d7);
        }
        
        .credential-status {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #e0e0e0;
        }
        
        .credential-status p {
            margin: 0 0 15px 0;
            font-weight: 600;
            color: #333;
        }
        
        .status-grid {
            display: grid;
            gap: 10px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        
        .status-label {
            font-weight: 500;
            color: #555;
        }
        
        .status-indicator {
            font-weight: 600;
            font-size: 14px;
        }
        
        .status-indicator.present {
            color: #28a745;
        }
        
        .status-indicator.missing {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎵 Levante Audio Test</h1>
        
        <div class="button-group">
            <div class="audio-section">
                <div class="audio-buttons">
                    <button id="playAudioBtn" class="audio-btn">
                        🎵 Play Current Audio
                    </button>
                    <button id="generateAudioBtn" class="audio-btn">
                        🎤 Generate New Audio
                    </button>
                    <button id="refreshBtn" class="audio-btn" style="background: #007bff;">
                        🔄 Refresh Context
                    </button>
                </div>
                <div id="audioGeneration" class="audio-generation" style="display: none;">
                    <div class="service-selection">
                        <label for="audioService">Service:</label>
                        <select id="audioService" onchange="onServiceChange()">
                            <option value="">Select Service...</option>
                            <option value="PlayHT">PlayHT</option>
                            <option value="ElevenLabs">ElevenLabs</option>
                        </select>
                    </div>
                    <div class="voice-selection">
                        <label for="voiceSelect">Voice:</label>
                        <select id="voiceSelect" onchange="onVoiceChange()">
                            <option value="">Select Voice...</option>
                        </select>
                    </div>
                    <div class="audio-actions">
                        <button onclick="generateAudio()" id="generateBtn" disabled>
                            Generate Audio
                        </button>
                        <button onclick="showCredentialsModal()" class="settings-btn">
                            ⚙️ API Settings
                        </button>
                        <button onclick="hideAudioGeneration()" class="cancel-btn">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
    </div>

    <!-- Credentials Modal -->
    <div id="credentialsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🔑 API Credentials</h2>
                <span class="close" onclick="closeCredentialsModal()">&times;</span>
            </div>
            <div class="credentials-form">
                <div class="credential-group">
                    <label for="playhtApiKey">PlayHT API Key:</label>
                    <input type="password" id="playhtApiKey" placeholder="Enter PlayHT API Key">
                    <button type="button" class="toggle-visibility" onclick="togglePasswordVisibility('playhtApiKey')">👁️</button>
                </div>
                <div class="credential-group">
                    <label for="playhtUserId">PlayHT User ID:</label>
                    <input type="password" id="playhtUserId" placeholder="Enter PlayHT User ID">
                    <button type="button" class="toggle-visibility" onclick="togglePasswordVisibility('playhtUserId')">👁️</button>
                </div>
                <div class="credential-group">
                    <label for="elevenlabsApiKey">ElevenLabs API Key:</label>
                    <input type="password" id="elevenlabsApiKey" placeholder="Enter ElevenLabs API Key">
                    <button type="button" class="toggle-visibility" onclick="togglePasswordVisibility('elevenlabsApiKey')">👁️</button>
                </div>
                <div class="credentials-buttons">
                    <button onclick="saveCredentials()" class="btn btn-primary">
                        💾 Save Credentials
                    </button>
                    <button onclick="recoverCredentials()" class="btn btn-success">
                        🔄 Recover Credentials
                    </button>
                    <button onclick="clearCredentials()" class="btn btn-secondary">
                        🗑️ Clear All
                    </button>
                </div>
                <div class="credential-status" id="credentialStatus">
                    <p><strong>Current Status:</strong></p>
                    <div class="status-grid">
                        <div class="status-item">
                            <span class="status-label">PlayHT API Key:</span>
                            <span id="playhtKeyStatus" class="status-indicator">❌ Not Set</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">PlayHT User ID:</span>
                            <span id="playhtUserStatus" class="status-indicator">❌ Not Set</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">ElevenLabs API Key:</span>
                            <span id="elevenlabsKeyStatus" class="status-indicator">❌ Not Set</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced context detection using Crowdin AP API
        function getCrowdinContext() {
            const urlParams = new URLSearchParams(window.location.search);
            const context = {};
            
            // Standard Crowdin parameters from URL
            const crowdinParams = [
                'projectId', 'fileId', 'stringId', 'languageId', 'userId', 'mode',
                'stringKey', 'identifier', 'key', 'sourceString', 'targetString',
                'context', 'maxLength', 'isPlural', 'pluralForm', 'origin', 'client_id', 'clientId', 'jwtToken'
            ];
            
            crowdinParams.forEach(param => {
                const value = urlParams.get(param);
                if (value) {
                    context[param] = value;
                }
            });
            
            // Use Crowdin AP API if available (proper way to access context)
            if (typeof AP !== 'undefined') {
                console.log('🎯 Crowdin AP API is available, requesting context...');
                
                // Request current string context
                if (AP.editor && AP.editor.getCurrentString) {
                    AP.editor.getCurrentString(function(stringData) {
                        console.log('🎯 AP.editor.getCurrentString result:', stringData);
                        if (stringData) {
                            receivedContext = { ...receivedContext, ...stringData };
                        }
                    });
                }
                
                // Request general context
                if (AP.context && AP.context.getContext) {
                    AP.context.getContext(function(contextData) {
                        console.log('🎯 AP.context.getContext result:', contextData);
                        if (contextData) {
                            receivedContext = { ...receivedContext, ...contextData };
                        }
                    });
                }
                
                // Request current translation
                if (AP.editor && AP.editor.getCurrentTranslation) {
                    AP.editor.getCurrentTranslation(function(translationData) {
                        console.log('🎯 AP.editor.getCurrentTranslation result:', translationData);
                        if (translationData) {
                            receivedContext = { ...receivedContext, ...translationData };
                        }
                    });
                }
            } else {
                console.log('🎯 Crowdin AP API not available, using fallback methods...');
                
                // Fallback: Try to get context from parent window if in iframe (without accessing cross-origin properties)
                if (window.parent && window.parent !== window) {
                    try {
                        // Request context from parent via postMessage (safe cross-origin method)
                        window.parent.postMessage({
                            type: 'request-context',
                            source: 'crowdin-app'
                        }, '*');
                    } catch (e) {
                        console.log('Cannot send postMessage to parent');
                    }
                }
            }
            
            return context;
        }
        

        
        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
            
            if (type !== 'loading') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        }
        

        
        // Function to actively request context from Crowdin
        function requestCrowdinContext() {
            if (window.parent && window.parent !== window) {
                // Try multiple message types that Crowdin might respond to
                const messages = [
                    { type: 'get-context' },
                    { type: 'request-context' },
                    { type: 'app-ready' },
                    { type: 'get-editor-context' },
                    { type: 'get-string-context' },
                    { action: 'getContext' },
                    { action: 'getCurrentString' }
                ];
                
                messages.forEach(message => {
                    try {
                        window.parent.postMessage(message, '*');
                    } catch (e) {
                        console.log('Failed to send message:', message);
                    }
                });
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Crowdin context detection
            initializeContext();
        });
        
        // Store received context data
        let receivedContext = {};
        
        // Enhanced message handler for Crowdin context
        function enhancedMessageHandler(event) {
            // Only process messages from Crowdin origins
            if (!event.origin || !event.origin.includes('crowdin.com')) {
                return;
            }
            
            // Throttle message processing to prevent overload
            if (window.lastMessageTime && Date.now() - window.lastMessageTime < 50) {
                return;
            }
            window.lastMessageTime = Date.now();
            
            console.log('📨 Received message from Crowdin:', JSON.stringify({
                origin: event.origin,
                type: event.data?.type,
                data: event.data
            }, null, 2));
            
            // Handle different types of messages from Crowdin
            if (event.data) {
                console.log('🔍 Checking event data:', {
                    type: event.data.type,
                    etyp: event.data.etyp,
                    hasEvnt: !!event.data.evnt
                });
                
                // Handle string.selected and string.change events directly
                if (event.data.type === 'evt') {
                    if (event.data.etyp === 'string.selected' && event.data.evnt && event.data.evnt.length > 0) {
                        console.log('🎯 PROCESSING string.selected event');
                        const stringInfo = event.data.evnt[0];
                        const stringData = stringInfo.string;
                        const translations = stringInfo.translations;
                        
                        receivedContext.stringId = stringData.id;
                        receivedContext.stringKey = stringData.text;
                        receivedContext.sourceString = stringData.text;
                        receivedContext.targetString = stringData.text;
                        receivedContext.identifier = stringData.identifier;
                        receivedContext.fileId = stringData.file?.id;
                        
                        // Use translation if available and not empty
                        if (translations && typeof translations === 'object') {
                            let foundTranslation = false;
                            for (const [langCode, translationArray] of Object.entries(translations)) {
                                if (translationArray && Array.isArray(translationArray) && translationArray.length > 0) {
                                    const translation = translationArray[0];
                                    if (translation && translation.text) {
                                        receivedContext.targetString = translation.text;
                                        receivedContext.targetLanguageId = langCode;
                                        console.log(`🎯 Using ${langCode} translation: ${translation.text}`);
                                        foundTranslation = true;
                                        break;
                                    }
                                }
                            }
                            if (!foundTranslation) {
                                console.log('🎯 No translations found, using source text:', stringData.text);
                                receivedContext.targetLanguageId = 'en'; // Default to English if no translation
                            }
                        } else {
                            console.log('🎯 No translations object, using source text:', stringData.text);
                            receivedContext.targetLanguageId = 'en'; // Default to English if no translations
                        }
                        
                        console.log('🎯 STORED CONTEXT:', receivedContext);
                    }
                    
                    if (event.data.etyp === 'string.change') {
                        console.log('🎯 PROCESSING string.change event');
                        const stringData = event.data.evnt;
                        console.log('🎯 String change data:', stringData);
                        
                        if (stringData) {
                            receivedContext.stringId = stringData.id;
                            receivedContext.stringKey = stringData.text;
                            receivedContext.sourceString = stringData.text;
                            receivedContext.targetString = stringData.text;
                            receivedContext.identifier = stringData.identifier;
                            receivedContext.fileId = stringData.file?.id;
                            
                            console.log('🎯 STORED CONTEXT from string.change:', receivedContext);
                        }
                    }
                }
                
                // Direct context updates
                if (event.data.type === 'crowdin-context' || event.data.type === 'context') {
                    console.log('🎯 Received context update:', event.data.context);
                    receivedContext = { ...receivedContext, ...event.data.context };
                }
                
                // String data in various forms
                if (event.data.stringId || event.data.stringKey || event.data.sourceString || event.data.targetString) {
                    console.log('🎯 Received string data:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // Editor context updates
                if (event.data.type === 'app-context' || event.data.type === 'editor-context') {
                    console.log('🎯 Received editor context:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // Current string updates (when user selects different strings)
                if (event.data.type === 'current-string' || event.data.type === 'string-selected') {
                    console.log('🎯 Received current string update:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                // Any other data that might contain useful context
                if (event.data.projectId || event.data.fileId || event.data.languageId) {
                    console.log('🎯 Received project context:', event.data);
                    receivedContext = { ...receivedContext, ...event.data };
                }
                
                console.log('🎯 Updated receivedContext:', receivedContext);
            }
        }
        
        // Listen for messages from parent window (if in iframe)
        window.addEventListener('message', enhancedMessageHandler);
        
        // Enhanced context getter that includes received messages
        function getEnhancedCrowdinContext() {
            const urlContext = getCrowdinContext();
            return { ...urlContext, ...receivedContext };
        }
        
        // Function to manually refresh context from Crowdin
        function refreshContext() {
            console.log('🔄 Manually refreshing context...');
            receivedContext = {}; // Clear existing context
            
            // Try to get context using AP API if available
            if (typeof AP !== 'undefined') {
                console.log('🎯 Using AP API to refresh context...');
                
                if (AP.editor && AP.editor.getCurrentString) {
                    AP.editor.getCurrentString(function(stringData) {
                        console.log('🎯 Refresh: AP.editor.getCurrentString result:', stringData);
                        if (stringData) {
                            receivedContext = { ...receivedContext, ...stringData };
                        }
                    });
                }
                
                if (AP.context && AP.context.getContext) {
                    AP.context.getContext(function(contextData) {
                        console.log('🎯 Refresh: AP.context.getContext result:', contextData);
                        if (contextData) {
                            receivedContext = { ...receivedContext, ...contextData };
                        }
                    });
                }
                
                if (AP.editor && AP.editor.getCurrentTranslation) {
                    AP.editor.getCurrentTranslation(function(translationData) {
                        console.log('🎯 Refresh: AP.editor.getCurrentTranslation result:', translationData);
                        if (translationData) {
                            receivedContext = { ...receivedContext, ...translationData };
                        }
                    });
                }
            } else {
                console.log('🎯 AP API not available, using fallback methods...');
                requestCrowdinContext();
            }
            
            // Show updated context after a short delay
            setTimeout(() => {
                const context = getEnhancedCrowdinContext();
                console.log('🔄 Context after refresh:', context);
                showStatus('Context refreshed. Check console for details.', 'success');
            }, 1000);
        }
        
        // Initialize context on page load
        function initializeContext() {
            console.log('🚀 Initializing Crowdin context...');
            
            // Wait a bit for AP API to load if it's going to
            setTimeout(() => {
                if (typeof AP !== 'undefined') {
                    console.log('✅ AP API is available, requesting initial context...');
                    refreshContext();
                } else {
                    console.log('⚠️ AP API not available, using fallback methods...');
                    requestCrowdinContext();
                }
            }, 500);
            
            // Try again after a longer delay in case AP loads slowly
            setTimeout(() => {
                if (typeof AP !== 'undefined' && Object.keys(receivedContext).length === 0) {
                    console.log('🔄 Second attempt to get context with AP API...');
                    refreshContext();
                }
            }, 2000);
        }

        // Enhanced function to detect the target language from Crowdin context
        function detectTargetLanguage(context) {
            console.log('🌍 LANGUAGE DETECTION DEBUG:', JSON.stringify(context, null, 2));
            
            // First try direct language IDs from context
            let detectedLanguage = context.targetLanguageId || context.sourceLanguageId || context.languageId;
            console.log('🌍 Direct language from context:', detectedLanguage);
            
            // If no direct language, try URL detection
            if (!detectedLanguage) {
                console.log('🌍 No direct language found, trying URL detection...');
                
                // Try current window URL parameters first
                const urlParams = new URLSearchParams(window.location.search);
                const urlLang = urlParams.get('language') || urlParams.get('lang') || urlParams.get('target_language');
                if (urlLang) {
                    console.log('🌍 Found language in current URL:', urlLang);
                    detectedLanguage = urlLang;
                }
                
                // Try to detect from parent window location
                if (!detectedLanguage) {
                    try {
                        if (window.parent && window.parent.location) {
                            const parentUrl = window.parent.location.href;
                            console.log('🌍 Analyzing parent URL for language:', parentUrl);
                            
                            // Multiple patterns to match different Crowdin URL formats
                            const patterns = [
                                /\/enus-([a-z]{2})(?:[-_][A-Z]{2})?(?:\/|#|$)/,  // enus-fr format
                                /\/([a-z]{2})(?:[-_][A-Z]{2})?-enus(?:\/|#|$)/,  // fr-enus format  
                                /editor\/[^\/]+\/\d+\/enus-([a-z]{2})(?:[-_][A-Z]{2})?/,  // editor/project/83/enus-frca
                                /\/([a-z]{2})(?:[-_][A-Z]{2})?(?:\/|#|$)/,       // generic /fr/ format
                                /target_language=([a-z]{2})/,                    // URL parameter
                                /lang=([a-z]{2})/                               // URL parameter
                            ];
                            
                            for (const pattern of patterns) {
                                const match = parentUrl.match(pattern);
                                if (match && match[1] && match[1] !== 'en') {
                                    console.log('🌍 ✅ Detected language from parent URL pattern:', match[1]);
                                    detectedLanguage = match[1];
                                    break;
                                }
                            }
                        }
                    } catch (e) {
                        console.log('🌍 Could not access parent URL due to cross-origin restrictions');
                    }
                }
            }
            
            // Map language codes (from audio-previewer logic)
            function mapLanguageCode(languageId) {
                if (!languageId) return null;
                
                const langId = String(languageId).toLowerCase().trim();
                console.log('🌍 Mapping language code:', langId);
                
                const languageMappings = {
                    'en': 'en', 'en-us': 'en', 'english': 'en',
                    'es': 'es', 'es-co': 'es', 'spanish': 'es', 'español': 'es',
                    'fr': 'fr', 'fr-ca': 'fr', 'french': 'fr', 'français': 'fr', 'frca': 'fr',
                    'pt': 'pt', 'pt-br': 'pt', 'portuguese': 'pt', 'português': 'pt',
                    'de': 'de', 'de-de': 'de', 'german': 'de', 'deutsch': 'de',
                    'nl': 'nl', 'nl-nl': 'nl', 'nl-be': 'nl', 'dutch': 'nl', 'nederlands': 'nl',
                    'it': 'it', 'it-it': 'it', 'italian': 'it', 'italiano': 'it'
                };
                
                const mapped = languageMappings[langId];
                console.log('🌍 Language mapping result:', langId, '->', mapped);
                return mapped || null;
            }
            
            const mappedLanguage = mapLanguageCode(detectedLanguage);
            console.log('🌍 Final language detection result:', {
                original: detectedLanguage,
                mapped: mappedLanguage,
                fallback: mappedLanguage || 'en'
            });
            
            return mappedLanguage || 'en'; // Default to English if nothing detected
        }

        // Audio Generation Functionality
        class AudioManager {
            constructor() {
                this.apiConfig = {
                    playht: {
                        apiUrl: 'https://api.play.ht/api/v2/tts/stream',
                        voicesUrl: 'https://api.play.ht/api/v2/voices',
                        apiKey: null,
                        userId: null
                    },
                    elevenlabs: {
                        apiUrl: 'https://api.elevenlabs.io/v1/text-to-speech',
                        voicesUrl: 'https://api.elevenlabs.io/v1/voices',
                        apiKey: null
                    }
                };
                
                this.voiceCache = {};
                this.currentService = null;
                this.currentVoice = null;
                
                // Load credentials using the same method as dashboard.js
                this.loadCredentials();
            }

            loadCredentials() {
                console.log('🔄 Loading credentials from storage...');
                
                // Load with backup recovery (same as dashboard.js)
                let playhtApiKey = localStorage.getItem('PLAY_DOT_HT_API_KEY') || '';
                let playhtUserId = localStorage.getItem('PLAY_DOT_HT_USER_ID') || '';
                let elevenlabsApiKey = localStorage.getItem('ELEVENLABS_API_KEY') || '';

                // Backup credential recovery - try alternative storage keys
                if (!playhtApiKey) {
                    playhtApiKey = localStorage.getItem('playht_api_key') ||
                                   localStorage.getItem('PLAYHT_API_KEY') ||
                                   sessionStorage.getItem('PLAY_DOT_HT_API_KEY') || '';
                }

                if (!playhtUserId) {
                    playhtUserId = localStorage.getItem('playht_user_id') ||
                                   localStorage.getItem('PLAYHT_USER_ID') ||
                                   sessionStorage.getItem('PLAY_DOT_HT_USER_ID') || '';
                }

                if (!elevenlabsApiKey) {
                    elevenlabsApiKey = localStorage.getItem('elevenlabs_api_key') ||
                                       localStorage.getItem('ELEVENLABS_KEY') ||
                                       sessionStorage.getItem('ELEVENLABS_API_KEY') || '';
                }

                console.log('🔍 Credential loading results:', {
                    playhtApiKey: playhtApiKey ? `${playhtApiKey.substring(0, 8)}...` : 'Missing',
                    playhtUserId: playhtUserId ? `${playhtUserId.substring(0, 8)}...` : 'Missing',
                    elevenlabsApiKey: elevenlabsApiKey ? `${elevenlabsApiKey.substring(0, 8)}...` : 'Missing'
                });

                // Update the API config - THIS WAS THE MISSING PART!
                this.apiConfig.playht.apiKey = playhtApiKey;
                this.apiConfig.playht.userId = playhtUserId;
                this.apiConfig.elevenlabs.apiKey = elevenlabsApiKey;

                console.log('✅ API config updated:', {
                    playhtConfigured: !!(this.apiConfig.playht.apiKey && this.apiConfig.playht.userId),
                    elevenlabsConfigured: !!this.apiConfig.elevenlabs.apiKey
                });
            }

            async loadVoices(service, languageCode = 'en') {
                const cacheKey = `${service}_${languageCode}`;
                if (this.voiceCache[cacheKey]) {
                    return this.voiceCache[cacheKey];
                }

                try {
                    let voices = [];
                    if (service === 'PlayHT') {
                        voices = await this.loadPlayHTVoices(languageCode);
                    } else if (service === 'ElevenLabs') {
                        voices = await this.loadElevenLabsVoices(languageCode);
                    }
                    
                    this.voiceCache[cacheKey] = voices;
                    return voices;
                } catch (error) {
                    console.error(`Error loading ${service} voices:`, error);
                    return [];
                }
            }

            async loadPlayHTVoices(languageCode = 'en') {
                console.log('🎤 Loading PlayHT voices from CSV for language:', languageCode);
                
                try {
                    // Load voices from CSV file instead of API
                    const response = await fetch('/preloaded_voices/comprehensive_female_voices_v1.csv');
                    
                    if (!response.ok) {
                        throw new Error(`Failed to load CSV: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log(' PlayHT CSV loaded, first 500 chars:', csvText.substring(0, 500));
                    
                    // Parse CSV properly - handle quoted values and commas within quotes
                    const lines = csvText.split('\n');
                    const headers = this.parseCSVLine(lines[0]);
                    console.log('📋 CSV Headers:', headers);
                    
                    const voices = [];
                    let playhtCount = 0;
                    let totalLines = 0;
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        totalLines++;
                        const values = this.parseCSVLine(line);
                        
                        // Create voice object
                        const voice = {};
                        headers.forEach((header, index) => {
                            voice[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        
                        // Debug first few lines
                        if (i <= 5) {
                            console.log(`📝 Line ${i}:`, voice.service, '|', voice.name);
                        }
                        
                        // Only include PlayHT voices (check first column)
                        if (voice.service === 'PlayHT') {
                            playhtCount++;
                            voices.push({
                                id: voice.id,
                                name: voice.name,
                                language: voice.language,
                                language_code: voice.language_code,
                                gender: voice.gender,
                                age: voice.age,
                                accent: voice.accent,
                                style: voice.style,
                                description: voice.description
                            });
                        }
                    }
                    
                    console.log(`📊 PlayHT CSV parsing results: ${totalLines} total lines, ${playhtCount} PlayHT voices found`);
                    console.log(`📊 PlayHT Total voices from CSV: ${voices.length}`);
                    
                    // Filter by language if specified
                    let filteredVoices = voices;
                    if (languageCode && languageCode !== 'en') {
                        filteredVoices = voices.filter(voice => {
                            const voiceLang = voice.language_code || voice.language || '';
                            return voiceLang.toLowerCase().includes(languageCode.toLowerCase());
                        });
                    }
                    
                    console.log(`🎯 PlayHT Filtered voices for "${languageCode}": ${filteredVoices.length}`);
                    
                    // Log first few voices for debugging
                    if (filteredVoices.length > 0) {
                        console.log('🎵 First 3 PlayHT voices from CSV:', filteredVoices.slice(0, 3));
                    } else {
                        console.warn('⚠️ No PlayHT voices found after filtering');
                    }
                    
                    return filteredVoices;
                    
                } catch (error) {
                    console.error('Error loading PlayHT voices from CSV:', error);
                    return [];
                }
            }

            // Helper method to properly parse CSV lines with quoted values
            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                result.push(current); // Add the last field
                return result;
            }

            async loadElevenLabsVoices(languageCode = 'en') {
                console.log('🎙️ Loading ElevenLabs voices for language:', languageCode);
                
                if (!this.apiConfig.elevenlabs.apiKey) {
                    console.log('  ❌ ElevenLabs API key missing, falling back to CSV');
                    return await this.loadElevenLabsVoicesFromCSV(languageCode);
                }
                
                console.log('✅ ElevenLabs API key found, trying API first...');
                
                try {
                    // Try API first
                    const response = await fetch('https://api.elevenlabs.io/v1/voices?show_legacy=false', {
                        headers: {
                            'xi-api-key': this.apiConfig.elevenlabs.apiKey
                        }
                    });
                    
                    console.log('📡 ElevenLabs API response status:', response.status);
                    
                    if (!response.ok) {
                        throw new Error(`ElevenLabs API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const allVoices = data.voices || [];
                    
                    // Filter to only personal/cloned voices (exclude public voices)
                    const personalVoices = allVoices.filter(voice => {
                        const category = voice.category || '';
                        const isPersonal = category === 'cloned' || 
                                         category === 'professional' || 
                                         category === 'generated' ||
                                         category === 'instant';
                        return isPersonal;
                    });
                    
                    console.log(`🎯 ElevenLabs Personal voices: ${personalVoices.length} personal, ${allVoices.length - personalVoices.length} public (excluded)`);
                    
                    if (personalVoices.length > 0) {
                        console.log('🎵 Using personal ElevenLabs voices from API');
                        return personalVoices;
                    } else {
                        console.log('⚠️ No personal voices found in API, falling back to CSV');
                        return await this.loadElevenLabsVoicesFromCSV(languageCode);
                    }
                    
                } catch (error) {
                    console.error('ElevenLabs API failed, falling back to CSV:', error);
                    return await this.loadElevenLabsVoicesFromCSV(languageCode);
                }
            }

            async loadElevenLabsVoicesFromCSV(languageCode = 'en') {
                console.log('🎙️ Loading ElevenLabs voices from CSV for language:', languageCode);
                
                try {
                    const response = await fetch('/preloaded_voices/comprehensive_female_voices_v1.csv');
                    
                    if (!response.ok) {
                        throw new Error(`Failed to load CSV: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    console.log('📦 ElevenLabs CSV loaded, parsing...');
                    
                    // Parse CSV
                    const lines = csvText.split('\n');
                    const headers = lines[0].split(',');
                    const voices = [];
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        const values = line.split(',');
                        const voice = {};
                        
                        headers.forEach((header, index) => {
                            voice[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        
                        // Only include ElevenLabs voices, and only professional/generated (no premade)
                        if (voice.service === 'ElevenLabs' && voice.category !== 'premade') {
                            voices.push({
                                voice_id: voice.id,
                                name: voice.name,
                                language: voice.language,
                                language_code: voice.language_code,
                                gender: voice.gender,
                                age: voice.age,
                                accent: voice.accent,
                                category: voice.category,
                                description: voice.description
                            });
                        }
                    }
                    
                    console.log(`📊 ElevenLabs Total voices from CSV: ${voices.length}`);
                    
                    // Filter by language if specified
                    let filteredVoices = voices;
                    if (languageCode && languageCode !== 'en') {
                        filteredVoices = voices.filter(voice => {
                            const voiceLang = voice.language_code || voice.language || '';
                            return voiceLang.toLowerCase().includes(languageCode.toLowerCase());
                        });
                    }
                    
                    console.log(`🎯 ElevenLabs Filtered voices for "${languageCode}": ${filteredVoices.length}`);
                    
                    // Log first few voices for debugging
                    if (filteredVoices.length > 0) {
                        console.log('🎵 First 3 ElevenLabs voices from CSV:', filteredVoices.slice(0, 3));
                    }
                    
                    return filteredVoices;
                    
                } catch (error) {
                    console.error('Error loading ElevenLabs voices from CSV:', error);
                    return [];
                }
            }

            async generateAudio(service, voiceId, text) {
                console.log(`🎤 Generating audio with ${service}, voice: ${voiceId}, text: "${text.substring(0, 50)}..."`);
                
                if (service === 'PlayHT') {
                    return await this.generatePlayHTAudio(voiceId, text);
                } else if (service === 'ElevenLabs') {
                    return await this.generateElevenLabsAudio(voiceId, text);
                } else {
                    throw new Error(`Unsupported service: ${service}`);
                }
            }

            async generatePlayHTAudio(voiceId, text) {
                const requestData = {
                    text: text,
                    voice: voiceId,
                    voice_engine: 'Play3.0-mini',
                    output_format: 'mp3',
                    sample_rate: 22050
                };

                const response = await fetch('/api/playht-proxy', {
                    method: 'POST',
                    headers: {
                        'Authorization': this.apiConfig.playht.apiKey,
                        'X-USER-ID': this.apiConfig.playht.userId,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`PlayHT API error: ${response.status}`);
                }

                return await response.arrayBuffer();
            }

            async generateElevenLabsAudio(voiceId, text) {
                const requestData = {
                    text: text,
                    model_id: 'eleven_multilingual_v2',
                    voice_settings: {
                        stability: 0.65,
                        similarity_boost: 0.5,
                        style: 0.0,
                        use_speaker_boost: true
                    }
                };

                const response = await fetch(`${this.apiConfig.elevenlabs.apiUrl}/${voiceId}`, {
                    method: 'POST',
                    headers: {
                        'xi-api-key': this.apiConfig.elevenlabs.apiKey,
                        'Content-Type': 'application/json',
                        'Accept': 'audio/mpeg'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`ElevenLabs API error: ${response.status}`);
                }

                return await response.arrayBuffer();
            }

            async playAudioData(audioData) {
                const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                
                return new Promise((resolve, reject) => {
                    audio.addEventListener('ended', () => {
                        URL.revokeObjectURL(audioUrl);
                        resolve();
                    });
                    audio.addEventListener('error', (e) => {
                        URL.revokeObjectURL(audioUrl);
                        reject(e);
                    });
                    audio.play().catch(reject);
                });
            }
        }

        // Initialize audio manager
        const audioManager = new AudioManager();

        // Audio UI Functions
        function showAudioGeneration() {
            console.log('🎤 Show audio generation called');
            document.getElementById('audioGeneration').style.display = 'block';
            
            // Trigger frame resize to accommodate the new content
            setTimeout(() => {
                if (typeof AP !== 'undefined' && AP.resize) {
                    AP.resize();
                    console.log('🎤 Frame resized for audio generation');
                }
            }, 100);
        }

        function hideAudioGeneration() {
            console.log('🎤 Hide audio generation called');
            document.getElementById('audioGeneration').style.display = 'none';
            
            // Trigger frame resize to shrink back to original size
            setTimeout(() => {
                if (typeof AP !== 'undefined' && AP.resize) {
                    AP.resize();
                    console.log('🎤 Frame resized back to original');
                }
            }, 100);
        }

        async function onServiceChange() {
            const serviceSelect = document.getElementById('audioService');
            const voiceSelect = document.getElementById('voiceSelect');
            const generateBtn = document.getElementById('generateBtn');
            
            // Clear voice dropdown
            voiceSelect.innerHTML = '<option value="">Select Voice...</option>';
            generateBtn.disabled = true;
            
            const selectedService = serviceSelect.value;
            console.log('🔄 Service changed to:', selectedService);
            
            if (!selectedService) {
                audioManager.currentService = null;
                return;
            }
            
            // Set the current service in audioManager
            audioManager.currentService = selectedService;
            
            // Reload credentials to ensure they're fresh
            audioManager.loadCredentials();
            
            try {
                let voices = [];
                
                if (selectedService === 'PlayHT') {
                    voices = await audioManager.loadPlayHTVoices();
                } else if (selectedService === 'ElevenLabs') {
                    voices = await audioManager.loadElevenLabsVoices();
                }
                
                console.log(`📋 Populating ${selectedService} dropdown with ${voices.length} voices`);
                
                // Populate voice dropdown
                voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.id || voice.voice_id;
                    option.textContent = voice.name;
                    voiceSelect.appendChild(option);
                });
                
                if (voices.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = `No ${selectedService} voices available`;
                    voiceSelect.appendChild(option);
                }
                
            } catch (error) {
                console.error(`Error loading ${selectedService} voices:`, error);
                const option = document.createElement('option');
                option.value = '';
                option.textContent = `Error loading ${selectedService} voices`;
                voiceSelect.appendChild(option);
            }
        }

        function onVoiceChange() {
            const voiceSelect = document.getElementById('voiceSelect');
            const generateBtn = document.getElementById('generateBtn');
            
            audioManager.currentVoice = voiceSelect.value;
            generateBtn.disabled = !voiceSelect.value;
        }

        async function generateAudio() {
            if (!audioManager.currentService || !audioManager.currentVoice) {
                showStatus('Please select a service and voice', 'error');
                return;
            }

            // Refresh credentials before generating audio
            audioManager.loadCredentials();

            const generateBtn = document.getElementById('generateBtn');
            const originalText = generateBtn.textContent;
            
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<div class="loading-spinner"></div> Generating...';
            
            try {
                // Get current string text from context
                const context = getEnhancedCrowdinContext();
                const text = context.targetString || context.sourceString || 'Hello, this is a test audio generation.';
                
                showStatus(`Generating audio with ${audioManager.currentService}...`, 'loading');
                
                const audioData = await audioManager.generateAudio(
                    audioManager.currentService,
                    audioManager.currentVoice,
                    text
                );
                
                await audioManager.playAudioData(audioData);
                showStatus('Audio generated and played successfully!', 'success');
                
            } catch (error) {
                console.error('Error generating audio:', error);
                showStatus(`Error: ${error.message}`, 'error');
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = originalText;
            }
        }

        async function playCurrentAudio() {
            try {
                showStatus('Looking for existing audio...', 'loading');
                
                // Get current Crowdin context with detailed debugging
                const context = getEnhancedCrowdinContext();
                console.log('🎵 FULL CONTEXT DEBUG:', JSON.stringify(context, null, 2));
                console.log('🎵 Context keys:', Object.keys(context));
                
                // Try multiple ways to get the string text with detailed logging
                console.log('🎵 STRING EXTRACTION DEBUG:');
                console.log('  - context.targetString:', context.targetString);
                console.log('  - context.sourceString:', context.sourceString);
                console.log('  - context.stringKey:', context.stringKey);
                console.log('  - context.key:', context.key);
                console.log('  - context.identifier:', context.identifier);
                console.log('  - context.text:', context.text);
                
                // Use identifier as primary source for filename, fallback to text for display
                const stringKey = context.identifier || context.targetString || context.sourceString || context.stringKey || context.key || context.text;
                const displayText = context.targetString || context.sourceString || context.stringKey || context.key || context.text || context.identifier;
                
                // Use enhanced language detection
                const languageCode = detectTargetLanguage(context);
                
                console.log('🎵 SELECTED VALUES:');
                console.log('  - stringKey (for filename):', JSON.stringify(stringKey));
                console.log('  - displayText (for reference):', JSON.stringify(displayText));
                console.log('  - languageCode (detected):', JSON.stringify(languageCode));
                console.log('  - stringKey type:', typeof stringKey);
                console.log('  - stringKey length:', stringKey ? stringKey.length : 'null');
                
                if (!stringKey) {
                    console.log('🎵 No string found in context. Full context:', context);
                    showStatus('No text found to play audio for. Try selecting a string in the editor first.', 'error');
                    return;
                }
                
                console.log('🎵 Looking for audio:', { stringKey, displayText, languageCode });
                
                // Enhanced label detection (from audio-previewer logic)
                let labelName = 'general'; // Default fallback
                
                // Try to detect label from various context sources
                if (context.labels && context.labels.length > 0) {
                    labelName = context.labels[0];
                } else if (context.identifier) {
                    // Extract label from string identifier patterns
                    const labelPatterns = [
                        /^([^_]+)_/,  // prefix_something
                        /([a-z]+)[-_]/i,  // label-something or label_something
                    ];
                    
                    for (const pattern of labelPatterns) {
                        const match = context.identifier.match(pattern);
                        if (match) {
                            const extractedLabel = match[1].toLowerCase();
                            
                            // Map common variations to standard directory names (from audio-previewer)
                            const labelMappings = {
                                'egma': 'egma-math',
                                'math': 'egma-math',
                                'matrix': 'matrix-reasoning',
                                'mental': 'mental-rotation',
                                'same': 'same-different-selection',
                                'theory': 'theory-of-mind',
                                'tom': 'theory-of-mind',
                                'trog': 'trog',
                                'vocab': 'vocab',
                                'vocabulary': 'vocab',
                                'survey': 'survey',
                                'general': 'general'
                            };
                            
                            // Check for exact match first
                            if (labelMappings[extractedLabel]) {
                                labelName = labelMappings[extractedLabel];
                                console.log('🎵 Found exact label mapping:', extractedLabel, '->', labelName);
                                break;
                            }
                            
                            // Check for partial matches
                            for (const [key, value] of Object.entries(labelMappings)) {
                                if (extractedLabel.includes(key) || key.includes(extractedLabel)) {
                                    labelName = value;
                                    console.log('🎵 Found partial label mapping:', extractedLabel, '->', labelName);
                                    break;
                                }
                            }
                            
                            // If no mapping found but we have a clean name, use it directly
                            if (labelName === 'general' && extractedLabel && extractedLabel !== 'general') {
                                labelName = extractedLabel;
                                console.log('🎵 Using direct label name:', labelName);
                            }
                            break;
                        }
                    }
                }
                
                console.log('🎵 Final label name selected:', labelName);
                
                // Clean up the string key for URL (from audio-previewer logic)
                console.log('🎵 STRING CLEANING DEBUG:');
                console.log('  - Original stringKey:', JSON.stringify(stringKey));
                console.log('  - Is identifier?:', stringKey === context.identifier);
                
                let cleanStringKey;
                if (stringKey === context.identifier) {
                    // If using identifier, it's probably already clean (like "ToM-scene-16-q4-reference")
                    // Just convert to lowercase and replace underscores with hyphens for consistency
                    cleanStringKey = stringKey.toLowerCase().replace(/_/g, '-');
                    console.log('  - Using identifier format (minimal cleaning)');
                } else {
                    // If using text content, apply full cleaning
                    cleanStringKey = stringKey
                        .toLowerCase()
                        .replace(/[^a-z0-9]+/g, '-')
                        .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens
                    console.log('  - Using text content (full cleaning)');
                }
                
                console.log('  - After cleaning processing:', cleanStringKey);
                console.log('  - Final cleanStringKey:', JSON.stringify(cleanStringKey));
                console.log('  - cleanStringKey length:', cleanStringKey.length);
                
                // Build multiple URL patterns to try (exact logic from audio-previewer)
                const baseUrl = 'https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files';
                const urlPatterns = [];
                
                // Helper function to get language variants (from audio-previewer)
                function getLanguageVariants(lang) {
                    const variants = {
                        'es': ['es', 'es-CO'], // Spanish: try both generic and Colombian
                        'en': ['en', 'en-US'],
                        'fr': ['fr', 'fr-CA'], // French: try both generic and Canadian
                        'pt': ['pt', 'pt-BR'],
                        'de': ['de', 'de-DE'], // German: try both generic and German-Germany
                        'nl': ['nl', 'nl-NL', 'nl-BE'] // Dutch: try generic, Netherlands, and Belgium
                    };
                    return variants[lang] || [lang];
                }
                
                const languageVariants = getLanguageVariants(languageCode);
                console.log('🎵 Will try language variants:', languageVariants);
                
                // Try each language variant
                for (const langVariant of languageVariants) {
                    // Primary patterns with detected label (highest priority)
                    if (labelName && labelName !== 'general') {
                        urlPatterns.push(`${baseUrl}/${labelName}/${langVariant}/shared/${cleanStringKey}.mp3`);
                        urlPatterns.push(`${baseUrl}/${labelName}/${langVariant}/shared/${stringKey.toLowerCase().replace(/\s+/g, '-')}.mp3`);
                        urlPatterns.push(`${baseUrl}/${labelName}/${langVariant}/shared/${stringKey.toLowerCase().replace(/[^a-z0-9]+/g, '_')}.mp3`);
                    }
                    
                    // Fallback patterns with 'general' (lower priority)
                    urlPatterns.push(`${baseUrl}/general/${langVariant}/shared/${cleanStringKey}.mp3`);
                    urlPatterns.push(`${baseUrl}/general/${langVariant}/shared/${stringKey.toLowerCase().replace(/\s+/g, '-')}.mp3`);
                    
                    // Try without label subdirectory (even lower priority)
                    urlPatterns.push(`${baseUrl}/${langVariant}/shared/${cleanStringKey}.mp3`);
                    
                    // Last resort patterns
                    if (labelName && labelName !== 'general') {
                        urlPatterns.push(`${baseUrl}/${labelName}/${langVariant}/shared/${stringKey}.mp3`);
                    }
                    urlPatterns.push(`${baseUrl}/general/${langVariant}/shared/${stringKey}.mp3`);
                }
                
                console.log('🎵 Will try audio URLs:', urlPatterns);
                console.log('🎵 URL components:', { labelName, languageCode, cleanStringKey, originalStringKey: stringKey });
                
                // Try each URL pattern until one works (from audio-previewer logic)
                for (let i = 0; i < urlPatterns.length; i++) {
                    const audioUrl = urlPatterns[i];
                    console.log(`🎵 Trying URL ${i + 1}/${urlPatterns.length}:`, audioUrl);
                    
                    try {
                        const audio = new Audio(audioUrl);
                        
                        // Test if the audio file can be loaded
                        await new Promise((resolve, reject) => {
                            const timeout = setTimeout(() => reject(new Error('Timeout')), 5000);
                            
                            audio.addEventListener('loadeddata', () => {
                                clearTimeout(timeout);
                                resolve();
                            });
                            
                            audio.addEventListener('error', () => {
                                clearTimeout(timeout);
                                reject(new Error('Audio load failed'));
                            });
                            
                            audio.load();
                        });
                        
                        console.log('✅ Found audio file:', audioUrl);
                        
                        // Play the audio
                        await new Promise((resolve, reject) => {
                            audio.addEventListener('ended', resolve);
                            audio.addEventListener('error', reject);
                            audio.play().catch(reject);
                        });
                        
                        showStatus('Audio playback complete', 'success');
                        return; // Success, exit the function
                        
                    } catch (error) {
                        console.log(`❌ URL ${i + 1} failed:`, error.message);
                        continue; // Try the next URL
                    }
                }
                
                // If we get here, no audio files were found
                showStatus('No existing audio file found for this text', 'error');
                console.log('❌ No audio files found for:', { stringKey, languageCode, labelName, cleanStringKey });
                
            } catch (error) {
                console.error('Error in playCurrentAudio:', error);
                showStatus(`Error playing audio: ${error.message}`, 'error');
            }
        }

        // Credential Management Functions (based on levante_translations/dashboard.js)
        function saveCredentials() {
            const credentials = {
                playhtApiKey: document.getElementById('playhtApiKey').value,
                playhtUserId: document.getElementById('playhtUserId').value,
                elevenlabsApiKey: document.getElementById('elevenlabsApiKey').value
            };

            // Save to localStorage with multiple backup keys (same as dashboard.js)
            localStorage.setItem('PLAY_DOT_HT_API_KEY', credentials.playhtApiKey);
            localStorage.setItem('playht_api_key', credentials.playhtApiKey);
            localStorage.setItem('PLAYHT_API_KEY', credentials.playhtApiKey);
            localStorage.setItem('PLAY_DOT_HT_USER_ID', credentials.playhtUserId);
            localStorage.setItem('playht_user_id', credentials.playhtUserId);
            localStorage.setItem('PLAYHT_USER_ID', credentials.playhtUserId);
            localStorage.setItem('ELEVENLABS_API_KEY', credentials.elevenlabsApiKey);
            localStorage.setItem('elevenlabs_api_key', credentials.elevenlabsApiKey);
            localStorage.setItem('ELEVEN_LABS_API_KEY', credentials.elevenlabsApiKey);

            // Also save to sessionStorage as backup
            sessionStorage.setItem('PLAY_DOT_HT_API_KEY', credentials.playhtApiKey);
            sessionStorage.setItem('PLAY_DOT_HT_USER_ID', credentials.playhtUserId);
            sessionStorage.setItem('ELEVENLABS_API_KEY', credentials.elevenlabsApiKey);

            // Update the audio manager's API config
            audioManager.apiConfig.playht.apiKey = credentials.playhtApiKey;
            audioManager.apiConfig.playht.userId = credentials.playhtUserId;
            audioManager.apiConfig.elevenlabs.apiKey = credentials.elevenlabsApiKey;

            updateCredentialStatus();
            showStatus('Credentials saved successfully with backup storage!', 'success');
            
            // Close the modal
            document.getElementById('credentialsModal').style.display = 'none';
        }

        function loadCredentials() {
            // Reload credentials in AudioManager first
            audioManager.loadCredentials();

            // Update form fields with the loaded credentials
            document.getElementById('playhtApiKey').value = audioManager.apiConfig.playht.apiKey || '';
            document.getElementById('playhtUserId').value = audioManager.apiConfig.playht.userId || '';
            document.getElementById('elevenlabsApiKey').value = audioManager.apiConfig.elevenlabs.apiKey || '';

            updateCredentialStatus();
        }

        function recoverCredentials() {
            // Try to recover from all possible storage locations
            const sources = [
                { name: 'localStorage', storage: localStorage },
                { name: 'sessionStorage', storage: sessionStorage }
            ];

            const keys = [
                { api: 'playht_key', variants: ['PLAY_DOT_HT_API_KEY', 'playht_api_key', 'PLAYHT_API_KEY'] },
                { api: 'playht_user', variants: ['PLAY_DOT_HT_USER_ID', 'playht_user_id', 'PLAYHT_USER_ID'] },
                { api: 'elevenlabs', variants: ['ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY'] }
            ];

            let recovered = { playht_key: '', playht_user: '', elevenlabs: '' };
            let recoveryCount = 0;

            sources.forEach(source => {
                keys.forEach(keyGroup => {
                    if (!recovered[keyGroup.api]) {
                        keyGroup.variants.forEach(variant => {
                            const value = source.storage.getItem(variant);
                            if (value && value.length > 10) {
                                recovered[keyGroup.api] = value;
                                recoveryCount++;
                            }
                        });
                    }
                });
            });

            if (recoveryCount > 0) {
                document.getElementById('playhtApiKey').value = recovered.playht_key;
                document.getElementById('playhtUserId').value = recovered.playht_user;
                document.getElementById('elevenlabsApiKey').value = recovered.elevenlabs;
                
                updateCredentialStatus();
                showStatus(`Recovered ${recoveryCount} credential(s) from backup storage!`, 'success');
            } else {
                showStatus('No backup credentials found in storage.', 'error');
            }
        }

        function clearCredentials() {
            if (confirm('Are you sure you want to clear all stored credentials?')) {
                // Clear from all storage locations
                const keys = [
                    'PLAY_DOT_HT_API_KEY', 'playht_api_key', 'PLAYHT_API_KEY',
                    'PLAY_DOT_HT_USER_ID', 'playht_user_id', 'PLAYHT_USER_ID',
                    'ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY'
                ];

                keys.forEach(key => {
                    localStorage.removeItem(key);
                    sessionStorage.removeItem(key);
                });

                // Clear form fields
                document.getElementById('playhtApiKey').value = '';
                document.getElementById('playhtUserId').value = '';
                document.getElementById('elevenlabsApiKey').value = '';

                // Clear audio manager config
                audioManager.apiConfig.playht.apiKey = null;
                audioManager.apiConfig.playht.userId = null;
                audioManager.apiConfig.elevenlabs.apiKey = null;

                updateCredentialStatus();
                showStatus('All credentials cleared successfully.', 'success');
            }
        }

        function updateCredentialStatus() {
            const playhtKey = audioManager.apiConfig.playht.apiKey;
            const playhtUser = audioManager.apiConfig.playht.userId;
            const elevenlabsKey = audioManager.apiConfig.elevenlabs.apiKey;

            document.getElementById('playhtKeyStatus').textContent = 
                playhtKey && playhtKey.length > 10 ? '✅ Present' : '❌ Not Set';
            document.getElementById('playhtKeyStatus').className = 
                playhtKey && playhtKey.length > 10 ? 'status-indicator present' : 'status-indicator missing';

            document.getElementById('playhtUserStatus').textContent = 
                playhtUser && playhtUser.length > 10 ? '✅ Present' : '❌ Not Set';
            document.getElementById('playhtUserStatus').className = 
                playhtUser && playhtUser.length > 10 ? 'status-indicator present' : 'status-indicator missing';

            document.getElementById('elevenlabsKeyStatus').textContent = 
                elevenlabsKey && elevenlabsKey.length > 10 ? '✅ Present' : '❌ Not Set';
            document.getElementById('elevenlabsKeyStatus').className = 
                elevenlabsKey && elevenlabsKey.length > 10 ? 'status-indicator present' : 'status-indicator missing';
        }

        function showCredentialsModal() {
            console.log('🔧 MODAL: showCredentialsModal() called');
            console.trace('🔧 MODAL: Call stack for showCredentialsModal');
            loadCredentials(); // Load current credentials
            document.getElementById('credentialsModal').style.display = 'block';
        }

        function closeCredentialsModal() {
            console.log('🔧 MODAL: closeCredentialsModal() called');
            document.getElementById('credentialsModal').style.display = 'none';
        }

        function togglePasswordVisibility(inputId) {
            const input = document.getElementById(inputId);
            const toggleBtn = input.nextElementSibling;
            
            if (input.type === 'password') {
                input.type = 'text';
                toggleBtn.textContent = '🙈';
            } else {
                input.type = 'password';
                toggleBtn.textContent = '👁️';
            }
        }

        // Manual credential testing function (call from browser console)
        window.testCredentials = function() {
            console.log('=== MANUAL CREDENTIAL TEST ===');
            
            // Test all possible credential keys
            const allKeys = [
                'PLAY_DOT_HT_API_KEY', 'playht_api_key', 'PLAYHT_API_KEY',
                'PLAY_DOT_HT_USER_ID', 'playht_user_id', 'PLAYHT_USER_ID',
                'ELEVENLABS_API_KEY', 'elevenlabs_api_key', 'ELEVEN_LABS_API_KEY'
            ];
            
            console.log('Testing localStorage:');
            allKeys.forEach(key => {
                const value = localStorage.getItem(key);
                console.log(`  ${key}: ${value ? `Present (${value.length} chars)` : 'Missing'}`);
            });
            
            console.log('Testing sessionStorage:');
            allKeys.forEach(key => {
                const value = sessionStorage.getItem(key);
                console.log(`  ${key}: ${value ? `Present (${value.length} chars)` : 'Missing'}`);
            });
            
            // Show current domain/origin
            console.log('Current domain:', window.location.origin);
            console.log('Current hostname:', window.location.hostname);
            
            // Force reload credentials
            audioManager.loadCredentials();
            console.log('AudioManager credentials after reload:', {
                playht: audioManager.apiConfig.playht.apiKey ? `Present (${audioManager.apiConfig.playht.apiKey.length} chars)` : 'Missing',
                playhtUser: audioManager.apiConfig.playht.userId ? `Present (${audioManager.apiConfig.playht.userId.length} chars)` : 'Missing',
                elevenlabs: audioManager.apiConfig.elevenlabs.apiKey ? `Present (${audioManager.apiConfig.elevenlabs.apiKey.length} chars)` : 'Missing'
            });
            console.log('=== END MANUAL TEST ===');
        };

        // Manual debug function for testing context extraction
        window.debugContext = function() {
            console.log('=== CONTEXT DEBUG ===');
            console.log('📋 receivedContext:', JSON.stringify(receivedContext, null, 2));
            console.log('📋 getEnhancedCrowdinContext():', JSON.stringify(getEnhancedCrowdinContext(), null, 2));
            console.log('📋 URL params:', Object.fromEntries(new URLSearchParams(window.location.search)));
            
            // Test the playCurrentAudio logic manually
            const context = getEnhancedCrowdinContext();
            const stringKey = context.targetString || context.sourceString || context.stringKey || context.key || context.identifier;
            const languageCode = context.targetLanguageId || context.sourceLanguageId || context.languageId || 'en';
            
            console.log('📋 Extracted for audio:', { stringKey, languageCode });
            console.log('=== END DEBUG ===');
        };
        
        // Simple debug function for testing context
        window.checkContext = function() {
            console.log('=== CONTEXT CHECK ===');
            console.log('receivedContext:', receivedContext);
            const enhanced = getEnhancedCrowdinContext();
            console.log('getEnhancedCrowdinContext():', enhanced);
            const stringKey = enhanced.targetString || enhanced.sourceString || enhanced.stringKey;
            console.log('Extracted text for audio:', stringKey);
            console.log('=== END CHECK ===');
        };
        
        console.log('💡 To debug context manually, run: debugContext()');
        console.log('🚀 App loaded at:', new Date().toISOString());

        // Initialize credentials and context on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 DOM Content Loaded - Initializing app...');
            
            // Initialize Crowdin context detection
            initializeContext();
            
            // Force reload credentials from storage
            audioManager.loadCredentials();
            loadCredentials();
            updateCredentialStatus();
            
            // Log current credentials for debugging
            console.log('Initialized credentials:', {
                playht: audioManager.apiConfig.playht.apiKey ? 'Present' : 'Missing',
                playhtUser: audioManager.apiConfig.playht.userId ? 'Present' : 'Missing', 
                elevenlabs: audioManager.apiConfig.elevenlabs.apiKey ? 'Present' : 'Missing'
            });
            
            // Add click event listeners with debugging
            const playBtn = document.getElementById('playAudioBtn');
            const generateBtn = document.getElementById('generateAudioBtn');
            const refreshBtn = document.getElementById('refreshBtn');
            
            if (playBtn) {
                playBtn.addEventListener('click', function() {
                    console.log('🎵 Play button clicked!');
                    playCurrentAudio();
                });
                console.log('✅ Play button event listener added');
            } else {
                console.error('❌ Play button not found!');
            }
            
            if (generateBtn) {
                generateBtn.addEventListener('click', function() {
                    console.log('🎤 Generate button clicked!');
                    showAudioGeneration();
                });
                console.log('✅ Generate button event listener added');
            } else {
                console.error('❌ Generate button not found!');
            }
            
            if (refreshBtn) {
                refreshBtn.addEventListener('click', function() {
                    console.log('🔄 Refresh button clicked!');
                    refreshContext();
                });
                console.log('✅ Refresh button event listener added');
            } else {
                console.error('❌ Refresh button not found!');
            }
            
            // Show instruction for manual testing
            console.log('💡 To manually test credentials, run: testCredentials()');
            console.log('🎯 App initialization complete!');
            
            // Trigger initial frame resize to fit content
            setTimeout(() => {
                if (typeof AP !== 'undefined' && AP.resize) {
                    AP.resize();
                    console.log('🎯 Initial frame resize completed');
                }
            }, 500);
        });

        // Debug function to check and force close modal
        window.debugModal = function() {
            const modal = document.getElementById('credentialsModal');
            const audioGen = document.getElementById('audioGeneration');
            const status = document.getElementById('status');
            
            console.log('🔧 MODAL DEBUG:', {
                modal_display: modal ? modal.style.display : 'not found',
                audioGen_display: audioGen ? audioGen.style.display : 'not found',
                status_display: status ? status.style.display : 'not found',
                modal_visible: modal ? getComputedStyle(modal).display : 'not found'
            });
            
            return {
                modal: modal ? modal.style.display : 'not found',
                audioGen: audioGen ? audioGen.style.display : 'not found',
                status: status ? status.style.display : 'not found'
            };
        };
        
        // Force close all overlays
        window.forceCloseAll = function() {
            console.log('🔧 FORCE CLOSING all overlays...');
            const modal = document.getElementById('credentialsModal');
            const audioGen = document.getElementById('audioGeneration');
            const status = document.getElementById('status');
            
            if (modal) {
                modal.style.display = 'none';
                console.log('🔧 Closed credentials modal');
            }
            if (audioGen) {
                audioGen.style.display = 'none';
                console.log('🔧 Closed audio generation');
            }
            if (status) {
                status.style.display = 'none';
                console.log('🔧 Closed status');
            }
            
            console.log('🔧 All overlays closed');
        };
    </script>
</body>
</html> 