<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Previewer</title>
    <script src="https://cdn.crowdin.com/apps/dist/iframe.js"></script>
    <link rel="stylesheet" href="/audio-previewer.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h3>üéµ Audio Preview</h3>
        </div>
        
        <div class="content">
            <!-- Play Audio Button -->
                                <button id="playBtn" class="play-button" onclick="playCurrentAudio()">
                        <span id="playIcon">üéµ</span>
                        <span id="playText">Play Current Audio</span>
                    </button>
                    <button id="refreshBtn" class="refresh-button" onclick="refreshContext()" style="margin-left: 10px; padding: 12px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        <span>üîÑ</span>
                        <span>Refresh Context</span>
                    </button>

            <!-- String Cache Status -->
            <div id="stringCacheStatus" class="string-cache" style="display: none;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.2rem;">‚è≥</span>
                    <span>Waiting for string selection... Select a string in the editor to cache its information.</span>
                </div>
            </div>
            
            <!-- Result Section -->
            <div id="resultSection" class="result-section">
                <div id="resultTitle" class="result-title"></div>
                <div id="resultContent"></div>
            </div>

            <!-- Debug Toggle -->
            <div class="debug-toggle">
                <label>
                    <input type="checkbox" id="debugMode"> Show debug information
                </label>
            </div>

            <!-- Debug Section -->
            <div id="debugSection" class="debug-section" style="display: none;">
                <h4>Debug Information</h4>
                <pre id="debugInfo">Waiting for debug data...</pre>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentStringCache = {
            stringId: null,
            stringKey: null,
            identifier: null,
            text: null, // This will store the translated text for TTS
            sourceText: null, // This will store the original English text
            context: null,
            labels: null,
            maxLength: null,
            fileId: null,
            fileName: null,
            projectId: null,
            sourceLanguageId: null,
            targetLanguageId: null,
            sourceLanguageName: null,
            targetLanguageName: null,
            lastUpdated: null,
            source: null,
            editorMode: null
        };

        // Main audio playing function
        async function playCurrentAudio() {
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const playText = document.getElementById('playText');
            
            // Disable button and show loading
            playBtn.disabled = true;
            playIcon.innerHTML = '<div class="loading-spinner"></div>';
            playText.textContent = 'Loading Audio...';
            
            // Hide previous results
            hideResultSection();
            
            try {
                // Check if we have a cached string
                if (!currentStringCache.stringId && !currentStringCache.stringKey) {
                    // In comfortable/multilingual modes, try harder to get current string
                    console.log('üéØ No cached string data, attempting to get current context for mode:', currentStringCache.editorMode);
                    
                    // Show different loading message
                    playText.textContent = 'Getting Current String...';
                    
                    // Try multiple methods to get current string data
                    await tryGetCurrentStringData();
                    
                    // Wait a bit for the data to be processed
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Check again after trying to get current data
                    if (!currentStringCache.stringId && !currentStringCache.stringKey) {
                        // Try to extract from current page context
                        await tryExtractFromPageContext();
                        
                        // Final check
                        if (!currentStringCache.stringId && !currentStringCache.stringKey) {
                            showErrorResult('Unable to detect current string. Please ensure a string is selected in the editor. In comfortable or multilingual mode, try clicking on a string first.');
                            return;
                        }
                    }
                }
                
                console.log('üéµ ============ AUDIO PLAYBACK DEBUG ============');
                console.log('üéµ Playing audio for string:', currentStringCache.stringId, currentStringCache.stringKey);
                console.log('üéµ Editor mode:', currentStringCache.editorMode);
                console.log('üéµ Target language ID:', currentStringCache.targetLanguageId);
                console.log('üéµ Source language ID:', currentStringCache.sourceLanguageId);
                console.log('üéµ Text to play:', currentStringCache.text ? currentStringCache.text.substring(0, 100) + '...' : 'N/A');
                console.log('üéµ Labels:', currentStringCache.labels);
                console.log('üéµ Full string cache:', JSON.stringify(currentStringCache, null, 2));
                console.log('üéµ ===============================================');
                
                // CRITICAL: Check if we're in a translation context
                if (!currentStringCache.targetLanguageId && !currentStringCache.sourceLanguageId) {
                    console.log('üéµ ‚ö†Ô∏è WARNING: No language information detected!');
                    console.log('üéµ ‚ö†Ô∏è This might be why we\'re getting English TTS');
                    
                    // Try to detect language from URL or page context
                    const urlParams = new URLSearchParams(window.location.search);
                    const urlLang = urlParams.get('language') || urlParams.get('lang') || urlParams.get('target_language');
                    if (urlLang) {
                        console.log('üéµ ‚úÖ Found language in URL:', urlLang);
                        currentStringCache.targetLanguageId = urlLang;
                    }
                    
                    // Try to detect from parent window location
                    try {
                        if (window.parent && window.parent.location) {
                            const parentUrl = window.parent.location.href;
                            console.log('üéµ Analyzing parent URL for language:', parentUrl);
                            
                            // Multiple patterns to match different Crowdin URL formats
                            const patterns = [
                                /\/enus-([a-z]{2})(?:[-_][A-Z]{2})?(?:\/|#|$)/,  // enus-es format
                                /\/([a-z]{2})(?:[-_][A-Z]{2})?-enus(?:\/|#|$)/,  // es-enus format  
                                /editor\/[^\/]+\/all\/enus-([a-z]{2})/,          // editor/project/all/enus-es
                                /\/([a-z]{2})(?:[-_][A-Z]{2})?(?:\/|#|$)/,       // generic /es/ format
                                /target_language=([a-z]{2})/,                    // URL parameter
                                /lang=([a-z]{2})/                               // URL parameter
                            ];
                            
                            for (const pattern of patterns) {
                                const match = parentUrl.match(pattern);
                                if (match && match[1] && match[1] !== 'en') {
                                    console.log('üéµ ‚úÖ Detected language from parent URL pattern:', match[1]);
                                    currentStringCache.targetLanguageId = match[1];
                                    break;
                                }
                            }
                        }
                    } catch (e) {
                        console.log('üéµ Could not access parent URL due to cross-origin restrictions');
                    }
                    
                    // Fallback: Try to detect language from translated text patterns
                    if (!currentStringCache.targetLanguageId && currentStringCache.text && currentStringCache.sourceText) {
                        const translatedText = currentStringCache.text.toLowerCase();
                        const sourceText = currentStringCache.sourceText.toLowerCase();
                        
                        // Only try detection if the texts are different (indicating translation)
                        if (translatedText !== sourceText) {
                            const languagePatterns = {
                                'es': [/¬°/, /√±/, /¬ø/, /√°|√©|√≠|√≥|√∫/, /que\s/, /con\s/, /para\s/, /hola/, /estamos/, /encantados/],
                                'fr': [/√ß/, /√†|√®|√©|√™|√´|√Æ|√Ø|√¥|√π|√ª|√º|√ø/, /avec\s/, /pour\s/, /dans\s/, /bonjour/, /nous\s/, /sommes/],
                                'de': [/√§|√∂|√º|√ü/, /und\s/, /mit\s/, /f√ºr\s/, /hallo/, /wir\s/, /sind/],
                                'it': [/√†|√®|√©|√¨|√Æ|√≤|√π/, /con\s/, /per\s/, /nel\s/, /ciao/, /siamo/, /felici/],
                                'pt': [/√£|√µ|√ß/, /com\s/, /para\s/, /ol√°/, /estamos/, /felizes/],
                                'nl': [/ij/, /met\s/, /voor\s/, /hallo/, /wij\s/, /zijn/]
                            };
                            
                            for (const [langCode, patterns] of Object.entries(languagePatterns)) {
                                let matches = 0;
                                for (const pattern of patterns) {
                                    if (pattern.test(translatedText)) {
                                        matches++;
                                    }
                                }
                                // If we find 2 or more pattern matches, consider it a match
                                if (matches >= 2) {
                                    console.log('üéµ ‚úÖ Detected language from text patterns:', langCode, `(${matches} matches)`);
                                    currentStringCache.targetLanguageId = langCode;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Update loading message
                playText.textContent = 'Finding Audio...';
                
                // Try to find and play audio for the current string
                const audioResult = await findAndPlayAudio();
                
                if (audioResult.success) {
                    showSuccessResult(
                        currentStringCache.stringKey || currentStringCache.identifier || currentStringCache.stringId,
                        `Audio Playback (${audioResult.source})`,
                        {
                            id: currentStringCache.stringId,
                            text: currentStringCache.text,
                            audioSource: audioResult.source,
                            audioUrl: audioResult.audioUrl,
                            message: audioResult.message,
                            details: audioResult.details,
                            metadata: audioResult.metadata,
                            mode: currentStringCache.editorMode,
                            detectedLanguage: currentStringCache.targetLanguageId || currentStringCache.sourceLanguageId,
                            allTriedUrls: audioResult.allTriedUrls
                        }
                    );
                } else {
                    showErrorResult(audioResult.message, audioResult.attemptedUrls, audioResult.allTriedUrls);
                }
                
            } catch (error) {
                console.error('Audio playback error:', error);
                const failedUrls = error.failedUrls ? error.failedUrls.map(item => item.url || item) : [];
                showErrorResult(`Audio playback failed: ${error.message}`, [], failedUrls);
            } finally {
                // Re-enable button
                playBtn.disabled = false;
                playIcon.textContent = 'üéµ';
                playText.textContent = 'Play Current Audio';
            }
        }

        // Enhanced function to try getting current string data
        async function tryGetCurrentStringData() {
            console.log('üéØ Trying to get current string data for mode:', currentStringCache.editorMode);
            console.log('üéØ Current cache state before API calls:', JSON.stringify(currentStringCache, null, 2));
            
            const promises = [];
            let apiResults = [];
            
            // Try all available methods simultaneously
            if (typeof AP !== 'undefined') {
                console.log('üéØ Crowdin AP API is available');
                
                // Method 1: Context API
                if (AP.context && AP.context.getContext) {
                    promises.push(new Promise(resolve => {
                        console.log('üéØ Calling AP.context.getContext...');
                        AP.context.getContext(function(context) {
                            console.log('üéØ Context API result:', context);
                            apiResults.push({ method: 'context.getContext', result: context });
                            if (context) {
                                updateStringCacheFromCrowdinEvent(context, 'context.getContext.manual');
                            }
                            resolve();
                        });
                    }));
                }
                
                // Method 2: Current String API
                if (AP.editor && AP.editor.getCurrentString) {
                    promises.push(new Promise(resolve => {
                        console.log('üéØ Calling AP.editor.getCurrentString...');
                        AP.editor.getCurrentString(function(stringData) {
                            console.log('üéØ Current string API result:', stringData);
                            apiResults.push({ method: 'editor.getCurrentString', result: stringData });
                            if (stringData) {
                                updateStringCacheFromCrowdinEvent(stringData, 'editor.getCurrentString.manual');
                            }
                            resolve();
                        });
                    }));
                }
                
                // Method 3: Current Translation API
                if (AP.editor && AP.editor.getCurrentTranslation) {
                    promises.push(new Promise(resolve => {
                        console.log('üéØ Calling AP.editor.getCurrentTranslation...');
                        AP.editor.getCurrentTranslation(function(translationData) {
                            console.log('üéØ Current translation API result:', translationData);
                            apiResults.push({ method: 'editor.getCurrentTranslation', result: translationData });
                            if (translationData) {
                                updateStringCacheFromCrowdinEvent(translationData, 'editor.getCurrentTranslation.manual');
                            }
                            resolve();
                        });
                    }));
                }
                
                // Method 4: Try to get project info
                if (AP.context && AP.context.getProject) {
                    promises.push(new Promise(resolve => {
                        console.log('üéØ Calling AP.context.getProject...');
                        AP.context.getProject(function(projectData) {
                            console.log('üéØ Project API result:', projectData);
                            apiResults.push({ method: 'context.getProject', result: projectData });
                            if (projectData) {
                                // Extract project info that might be useful
                                if (projectData.id) currentStringCache.projectId = projectData.id;
                                if (projectData.sourceLanguageId) currentStringCache.sourceLanguageId = projectData.sourceLanguageId;
                            }
                            resolve();
                        });
                    }));
                }
                
                // Method 5: Try to get current language
                if (AP.context && AP.context.getCurrentLanguage) {
                    promises.push(new Promise(resolve => {
                        console.log('üéØ Calling AP.context.getCurrentLanguage...');
                        AP.context.getCurrentLanguage(function(languageData) {
                            console.log('üéØ Current language API result:', languageData);
                            apiResults.push({ method: 'context.getCurrentLanguage', result: languageData });
                            if (languageData) {
                                if (languageData.id) currentStringCache.targetLanguageId = languageData.id;
                                if (languageData.name) currentStringCache.targetLanguageName = languageData.name;
                            }
                            resolve();
                        });
                    }));
                }
            } else {
                console.log('üéØ ‚ùå Crowdin AP API is not available');
            }
            
            // Wait for all methods to complete
            await Promise.all(promises);
            
            console.log('üéØ All API results:', apiResults);
            console.log('üéØ Updated cache state after API calls:', JSON.stringify(currentStringCache, null, 2));
            
            // If we still don't have essential data, try alternative methods
            if (!currentStringCache.stringKey && !currentStringCache.stringId) {
                console.log('üéØ Still no string data, trying alternative methods...');
                await tryAlternativeDataExtraction();
            }
        }
        
        // Try alternative methods to extract string data
        async function tryAlternativeDataExtraction() {
            console.log('üéØ Trying alternative data extraction methods...');
            
            // Try to extract from URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const urlData = {};
            
            for (const [key, value] of urlParams.entries()) {
                urlData[key] = value;
                console.log(`üéØ URL param: ${key} = ${value}`);
            }
            
            // Try to extract useful data from URL
            if (urlData.stringId) currentStringCache.stringId = urlData.stringId;
            if (urlData.stringKey) currentStringCache.stringKey = urlData.stringKey;
            if (urlData.projectId) currentStringCache.projectId = urlData.projectId;
            if (urlData.languageId) currentStringCache.targetLanguageId = urlData.languageId;
            
            // Try to get data from parent window
            if (window.parent && window.parent !== window) {
                console.log('üéØ Trying to communicate with parent window...');
                try {
                    // Send message to parent asking for current context
                    window.parent.postMessage({
                        type: 'request_current_context',
                        source: 'audio_previewer',
                        timestamp: new Date().toISOString()
                    }, '*');
                    
                    // Wait a bit for potential response
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } catch (error) {
                    console.log('üéØ Error communicating with parent:', error);
                }
            }
            
            // Try to extract from document title or other DOM elements
            if (document.title) {
                console.log('üéØ Document title:', document.title);
                // Sometimes Crowdin includes useful info in the title
            }
            
            // Try to extract from referrer
            if (document.referrer) {
                console.log('üéØ Referrer:', document.referrer);
                try {
                    const referrerUrl = new URL(document.referrer);
                    const referrerParams = new URLSearchParams(referrerUrl.search);
                    console.log('üéØ Referrer params:', Object.fromEntries(referrerParams));
                } catch (error) {
                    console.log('üéØ Could not parse referrer URL');
                }
            }
            
            console.log('üéØ Final cache state after alternative extraction:', JSON.stringify(currentStringCache, null, 2));
        }

        // Try to extract string data from page context (DOM inspection)
        async function tryExtractFromPageContext() {
            console.log('üéØ Trying to extract string data from page context');
            
            try {
                // In comfortable/multilingual modes, try to find string data in the parent window
                if (window.parent && window.parent !== window) {
                    // Send a message to parent asking for current string data
                    window.parent.postMessage({
                        type: 'request_current_string',
                        source: 'audio_previewer'
                    }, '*');
                    
                    // Wait a bit for response
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                // Try to get data from localStorage or sessionStorage
                const storedStringData = localStorage.getItem('crowdin_current_string') || 
                                       sessionStorage.getItem('crowdin_current_string');
                
                if (storedStringData) {
                    try {
                        const parsedData = JSON.parse(storedStringData);
                        console.log('üéØ Found stored string data:', parsedData);
                        updateStringCacheFromCrowdinEvent(parsedData, 'localStorage.extraction');
                    } catch (e) {
                        console.log('üéØ Could not parse stored string data');
                    }
                }
                
            } catch (error) {
                console.log('üéØ Error extracting from page context:', error);
            }
        }

        // Get audio file metadata via server proxy (to bypass CORS)
        async function getAudioFileMetadataViaServer(audioUrl) {
            try {
                console.log('üìä Getting metadata via server proxy for:', audioUrl);
                
                const response = await fetch('/api/get-audio-metadata', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ audioUrl: audioUrl })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('üìä Server proxy metadata:', data);
                    return data.metadata;
                } else {
                    console.log('üìä Server proxy failed:', response.status);
                    return null;
                }
            } catch (error) {
                console.error('üìä Server proxy error:', error);
                return null;
            }
        }

        // Get audio file metadata (last modified date, size, etc.)
        async function getAudioFileMetadata(audioUrl) {
            try {
                console.log('üìä Getting metadata for audio file:', audioUrl);
                
                // First try direct access (might be blocked by CORS)
                const response = await fetch(audioUrl, {
                    method: 'HEAD',
                    cache: 'no-cache'
                });
                
                if (response.ok) {
                    // Log all available headers for debugging
                    console.log('üìä Available headers (direct):');
                    const headerCount = Array.from(response.headers.entries()).length;
                    console.log(`üìä Header count: ${headerCount}`);
                    
                    for (const [key, value] of response.headers.entries()) {
                        console.log(`  ${key}: ${value}`);
                    }
                    
                    const metadata = {
                        lastModified: response.headers.get('Last-Modified'),
                        date: response.headers.get('Date'),
                        contentLength: response.headers.get('Content-Length'),
                        contentType: response.headers.get('Content-Type'),
                        etag: response.headers.get('ETag'),
                        cacheControl: response.headers.get('Cache-Control'),
                        server: response.headers.get('Server'),
                        expires: response.headers.get('Expires'),
                        age: response.headers.get('Age'),
                        url: audioUrl,
                        status: response.status,
                        statusText: response.statusText,
                        method: 'direct'
                    };
                    
                    // Check if we got meaningful headers (CORS might allow request but block headers)
                    const hasUsefulHeaders = metadata.lastModified || metadata.contentLength || metadata.server;
                    
                    if (!hasUsefulHeaders) {
                        console.log('üìä Direct request succeeded but no useful headers (likely CORS blocked). Trying server proxy...');
                        const serverMetadata = await getAudioFileMetadataViaServer(audioUrl);
                        if (serverMetadata) {
                            return serverMetadata;
                        }
                    }
                    
                    // Try multiple date sources
                    let dateToUse = null;
                    let dateSource = null;
                    
                    if (metadata.lastModified) {
                        dateToUse = metadata.lastModified;
                        dateSource = 'Last-Modified header';
                    } else if (metadata.date) {
                        dateToUse = metadata.date;
                        dateSource = 'Date header (server response time)';
                    } else if (metadata.etag) {
                        // Sometimes ETags contain timestamps
                        const etagMatch = metadata.etag.match(/(\d{10,13})/);
                        if (etagMatch) {
                            const timestamp = parseInt(etagMatch[1]);
                            if (timestamp > 1000000000) { // Valid Unix timestamp
                                dateToUse = new Date(timestamp * (timestamp > 9999999999 ? 1 : 1000)).toUTCString();
                                dateSource = 'ETag timestamp';
                            }
                        }
                    }
                    
                    // Parse the date
                    if (dateToUse) {
                        const parsedDate = new Date(dateToUse);
                        if (!isNaN(parsedDate.getTime())) {
                            metadata.lastModifiedParsed = parsedDate;
                            metadata.lastModifiedFormatted = parsedDate.toLocaleString();
                            metadata.daysAgo = Math.floor((Date.now() - parsedDate.getTime()) / (1000 * 60 * 60 * 24));
                            metadata.dateSource = dateSource;
                        } else {
                            console.log('üìä Could not parse date:', dateToUse);
                        }
                    } else {
                        console.log('üìä No date information found in headers');
                        metadata.noDateInfo = true;
                        metadata.corsLimited = !hasUsefulHeaders;
                    }
                    
                    // Format file size
                    if (metadata.contentLength) {
                        const bytes = parseInt(metadata.contentLength);
                        if (bytes < 1024) {
                            metadata.fileSizeFormatted = bytes + ' bytes';
                        } else if (bytes < 1024 * 1024) {
                            metadata.fileSizeFormatted = (bytes / 1024).toFixed(1) + ' KB';
                        } else {
                            metadata.fileSizeFormatted = (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                        }
                    }
                    
                    console.log('üìä Audio file metadata:', metadata);
                    return metadata;
                } else {
                    console.log('üìä Direct request failed:', response.status, response.statusText);
                    console.log('üìä Trying server proxy...');
                    
                    const serverMetadata = await getAudioFileMetadataViaServer(audioUrl);
                    if (serverMetadata) {
                        return serverMetadata;
                    }
                    
                    return {
                        error: true,
                        status: response.status,
                        statusText: response.statusText,
                        url: audioUrl,
                        method: 'direct'
                    };
                }
            } catch (error) {
                console.error('üìä Error getting audio metadata:', error);
                console.log('üìä Trying server proxy as fallback...');
                
                const serverMetadata = await getAudioFileMetadataViaServer(audioUrl);
                if (serverMetadata) {
                    return serverMetadata;
                }
                
                return {
                    error: true,
                    errorMessage: error.message,
                    url: audioUrl,
                    corsBlocked: error.message.includes('CORS') || error.message.includes('fetch')
                };
            }
        }

        // Find and play audio for the current string
        async function findAndPlayAudio() {
            console.log('üéµ Looking for audio for string:', currentStringCache.stringId, currentStringCache.stringKey);
            console.log('üéµ Current string cache:', JSON.stringify(currentStringCache, null, 2));
            
            const attemptedUrls = [];
            const allTriedUrls = []; // Track all URLs attempted for debug display
            
            // Try multiple approaches to find audio
            const stringKey = currentStringCache.stringKey || currentStringCache.identifier;
            
            // Enhanced label detection - try multiple sources
            let labels = currentStringCache.labels;
            
            // If no labels in cache, try to extract from other sources
            if (!labels || !Array.isArray(labels) || labels.length === 0) {
                console.log('üéµ No labels in cache, trying to extract from other sources...');
                
                // Try to extract from file path or context
                if (currentStringCache.fileId || currentStringCache.filePath) {
                    console.log('üéµ Trying to extract label from file info:', { fileId: currentStringCache.fileId, filePath: currentStringCache.filePath });
                    // File path might contain the task name
                    const filePath = currentStringCache.filePath || '';
                    const pathSegments = filePath.split('/').filter(segment => segment.length > 0);
                    
                    // Look for task-related segments in the path
                    const taskKeywords = ['egma-math', 'matrix-reasoning', 'mental-rotation', 'same-different-selection', 'theory-of-mind', 'trog', 'vocab', 'survey'];
                    const foundTask = pathSegments.find(segment => 
                        taskKeywords.some(keyword => segment.toLowerCase().includes(keyword.toLowerCase()))
                    );
                    
                    if (foundTask) {
                        labels = [{ title: foundTask.toLowerCase() }];
                        console.log('üéµ Extracted label from file path:', foundTask);
                    }
                }
                
                // Try to extract from string key itself
                if ((!labels || labels.length === 0) && stringKey) {
                    console.log('üéµ Trying to extract label from string key:', stringKey);
                    const taskKeywords = {
                        'egma': 'egma-math',
                        'math': 'egma-math',
                        'matrix': 'matrix-reasoning',
                        'reasoning': 'matrix-reasoning',
                        'mental': 'mental-rotation',
                        'rotation': 'mental-rotation',
                        'same': 'same-different-selection',
                        'different': 'same-different-selection',
                        'selection': 'same-different-selection',
                        'theory': 'theory-of-mind',
                        'mind': 'theory-of-mind',
                        'trog': 'trog',
                        'vocab': 'vocab',
                        'vocabulary': 'vocab',
                        'survey': 'survey'
                    };
                    
                    const lowerKey = stringKey.toLowerCase();
                    for (const [keyword, taskName] of Object.entries(taskKeywords)) {
                        if (lowerKey.includes(keyword)) {
                            labels = [{ title: taskName }];
                            console.log('üéµ Extracted label from string key:', taskName);
                            break;
                        }
                    }
                }
                
                // Try to extract from project context
                if ((!labels || labels.length === 0) && currentStringCache.projectId) {
                    console.log('üéµ Trying to extract label from project context...');
                    // This could be enhanced with project-specific logic if needed
                }
                
                // Final fallback to 'general'
                if (!labels || labels.length === 0) {
                    labels = [{ title: 'general' }];
                    console.log('üéµ Using fallback label: general');
                }
            } else {
                console.log('üéµ Using labels from cache:', labels);
            }
            
            // Enhanced language detection - convert Crowdin language IDs to proper codes
            function mapLanguageCode(languageId) {
                if (!languageId) return null;
                
                // If it's already a proper language code, return it
                if (typeof languageId === 'string' && languageId.match(/^[a-z]{2}(-[A-Z]{2})?$/)) {
                    return languageId.toLowerCase().split('-')[0]; // Extract base language (e.g., 'es' from 'es-ES')
                }
                
                // Common Crowdin language ID mappings
                const languageMappings = {
                    // Spanish variations
                    '33': 'es',
                    'es': 'es',
                    'es-ES': 'es',
                    'es-MX': 'es',
                    'es-CO': 'es',
                    'spanish': 'es',
                    
                    // English variations
                    '1': 'en',
                    'en': 'en',
                    'en-US': 'en',
                    'en-GB': 'en',
                    'english': 'en',
                    
                    // French variations
                    '2': 'fr',
                    'fr': 'fr',
                    'fr-FR': 'fr',
                    'fr-CA': 'fr',
                    'french': 'fr',
                    
                    // German variations
                    '3': 'de',
                    'de': 'de',
                    'de-DE': 'de',
                    'german': 'de',
                    
                    // Portuguese variations
                    '4': 'pt',
                    'pt': 'pt',
                    'pt-BR': 'pt',
                    'pt-PT': 'pt',
                    'portuguese': 'pt',
                    
                    // Dutch variations
                    '5': 'nl',
                    '6': 'nl', // Sometimes Dutch has different IDs
                    'nl': 'nl',
                    'nl-NL': 'nl',
                    'nl-BE': 'nl',
                    'dutch': 'nl',
                    'nederlands': 'nl'
                };
                
                const langId = String(languageId).toLowerCase();
                const mapped = languageMappings[langId];
                
                console.log('üéµ Language mapping:', languageId, '->', mapped || 'unknown');
                
                // If no mapping found, log all available mappings for debugging
                if (!mapped) {
                    console.log('üéµ ‚ùå No mapping found for:', languageId);
                    console.log('üéµ Available mappings:', Object.keys(languageMappings));
                    console.log('üéµ Tried to match:', langId);
                }
                
                return mapped || null;
            }
            
            // Map the language codes from Crowdin
            const targetLang = mapLanguageCode(currentStringCache.targetLanguageId);
            const sourceLang = mapLanguageCode(currentStringCache.sourceLanguageId);
            
            // Helper function to get language variants
            function getLanguageVariants(lang) {
                const variants = {
                    'es': ['es', 'es-CO'], // Spanish: try both generic and Colombian
                    'en': ['en', 'en-US'],
                    'fr': ['fr', 'fr-CA'],
                    'pt': ['pt', 'pt-BR'],
                    'de': ['de', 'de-DE'], // German: try both generic and German-Germany
                    'nl': ['nl', 'nl-NL', 'nl-BE'] // Dutch: try generic, Netherlands, and Belgium
                };
                return variants[lang] || [lang];
            }
            
            console.log('üéµ Language detection results:', {
                originalTarget: currentStringCache.targetLanguageId,
                mappedTarget: targetLang,
                targetVariants: targetLang ? getLanguageVariants(targetLang) : [],
                originalSource: currentStringCache.sourceLanguageId,
                mappedSource: sourceLang,
                sourceVariants: sourceLang ? getLanguageVariants(sourceLang) : []
            });
            
            // Debug: Check if we're getting the expected language
            if (currentStringCache.targetLanguageId && !targetLang) {
                console.log('üéµ ‚ö†Ô∏è WARNING: Target language ID provided but not mapped!');
                console.log('üéµ Target language ID type:', typeof currentStringCache.targetLanguageId);
                console.log('üéµ Target language ID value:', JSON.stringify(currentStringCache.targetLanguageId));
            }
            
            // More comprehensive audio source attempts with proper language codes
            const audioSources = [];
            
            // Try target language first if we have it (including variants)
            if (targetLang) {
                const targetVariants = getLanguageVariants(targetLang);
                console.log('üéµ Will try target language variants:', targetVariants);
                for (const variant of targetVariants) {
                    audioSources.push(() => findLevanteAudio(variant, labels, stringKey));
                }
            } else {
                console.log('üéµ ‚ùå No target language mapped, will skip target language attempts');
            }
            
            // Try source language if different from target (including variants)
            if (sourceLang && sourceLang !== targetLang) {
                const sourceVariants = getLanguageVariants(sourceLang);
                for (const variant of sourceVariants) {
                    // Only add if not already added for target language
                    const targetVariants = targetLang ? getLanguageVariants(targetLang) : [];
                    if (!targetVariants.includes(variant)) {
                        audioSources.push(() => findLevanteAudio(variant, labels, stringKey));
                    }
                }
            }
            
            // Common fallback languages with variants
            const fallbackLanguages = ['en', 'es', 'fr'];
            for (const lang of fallbackLanguages) {
                if (lang !== targetLang && lang !== sourceLang) {
                    const variants = getLanguageVariants(lang);
                    for (const variant of variants) {
                        // Only add if not already added
                        const alreadyAdded = audioSources.some(source => {
                            // This is a rough check - we're checking if this variant might already be added
                            return false; // For now, allow duplicates since the function calls are wrapped
                        });
                        audioSources.push(() => findLevanteAudio(variant, labels, stringKey));
                    }
                }
            }
            
            // Finally, try text-to-speech
            audioSources.push(() => generateTextToSpeech(currentStringCache.text));
            
            console.log('üéµ Will try audio sources with:', {
                originalTargetLanguageId: currentStringCache.targetLanguageId,
                mappedTargetLanguage: targetLang,
                originalSourceLanguageId: currentStringCache.sourceLanguageId,
                mappedSourceLanguage: sourceLang,
                labels: currentStringCache.labels,
                stringKey: currentStringCache.stringKey || currentStringCache.identifier,
                text: currentStringCache.text ? currentStringCache.text.substring(0, 50) + '...' : 'N/A',
                editorMode: currentStringCache.editorMode
            });
            
            // Check if we have the minimum required data
            if (!stringKey) {
                console.log('üéµ ‚ùå No string key available, will skip Levante audio and go directly to TTS');
                return await generateTextToSpeech(currentStringCache.text);
            }
            
            for (const audioSource of audioSources) {
                try {
                    const result = await audioSource();
                    if (result.success) {
                        // Collect all URLs that will be attempted
                        const urlsToTry = [result.audioUrl, ...(result.alternativeUrls || [])];
                        allTriedUrls.push(...urlsToTry);
                        
                        // Get metadata for the audio file
                        const metadata = await getAudioFileMetadata(result.audioUrl);
                        
                        // Pass alternative URLs and target language if available
                        const alternativeUrls = result.alternativeUrls || [];
                        const targetLanguage = result.targetLanguage || currentStringCache.targetLanguageId;
                        
                        try {
                            await playAudio(result.audioUrl, result.source, result.text, alternativeUrls, targetLanguage);
                            
                            return {
                                success: true,
                                source: result.source,
                                audioUrl: result.audioUrl,
                                message: `Playing audio for "${currentStringCache.stringKey || currentStringCache.identifier}" from ${result.source}`,
                                details: result.details,
                                metadata: metadata,
                                attemptedUrls: attemptedUrls,
                                alternativeUrls: alternativeUrls,
                                allTriedUrls: allTriedUrls,
                                languageMapping: {
                                    originalTarget: currentStringCache.targetLanguageId,
                                    mappedTarget: targetLang,
                                    targetVariants: targetLang ? getLanguageVariants(targetLang) : [],
                                    originalSource: currentStringCache.sourceLanguageId,
                                    mappedSource: sourceLang,
                                    sourceVariants: sourceLang ? getLanguageVariants(sourceLang) : [],
                                    usedLanguage: result.targetLanguage || targetLang
                                }
                            };
                        } catch (playError) {
                            console.log('üéµ ‚ùå All audio URLs failed for this source:', playError.message);
                            // Continue to next audio source
                        }
                    }
                } catch (error) {
                    console.log('üéµ Audio source failed:', error.message);
                    if (error.attemptedUrl) {
                        attemptedUrls.push(error.attemptedUrl);
                        allTriedUrls.push(error.attemptedUrl);
                    }
                }
            }
            
            return {
                success: false,
                message: `No audio found for string "${currentStringCache.stringKey || currentStringCache.identifier}" (ID: ${currentStringCache.stringId}). Tried Levante audio repository and text-to-speech.`,
                attemptedUrls: attemptedUrls,
                allTriedUrls: allTriedUrls
            };
        }

        // Find audio using Levante URL pattern
        async function findLevanteAudio(languageCode, labels, stringKey) {
            console.log('üéµ findLevanteAudio called with:', { languageCode, labels, stringKey });
            
            if (!languageCode || !stringKey) {
                const error = new Error(`Missing required parameters - languageCode: ${languageCode}, stringKey: ${stringKey}`);
                console.log('üéµ Levante audio failed:', error.message);
                throw error;
            }
            
            console.log('üéµ Looking for Levante audio:', { languageCode, labels, stringKey });
            
            // Extract label name for the URL path with enhanced detection
            let labelName = 'general'; // Default fallback
            
            console.log('üéµ Raw labels received:', JSON.stringify(labels, null, 2));
            
            if (labels && Array.isArray(labels) && labels.length > 0) {
                // Try each label until we find a valid one
                for (const label of labels) {
                    let extractedName = null;
                    
                    if (typeof label === 'object') {
                        // Try different property names
                        extractedName = label.title || label.name || label.label || label.value || label.text;
                    } else if (typeof label === 'string') {
                        extractedName = label;
                    }
                    
                    if (extractedName) {
                        // Clean and validate the extracted name
                        const cleanName = extractedName.toLowerCase().trim();
                        
                        // Map common variations to standard directory names
                        const labelMappings = {
                            'egma': 'egma-math',
                            'math': 'egma-math',
                            'egma-math': 'egma-math',
                            'matrix': 'matrix-reasoning',
                            'matrix-reasoning': 'matrix-reasoning',
                            'mental': 'mental-rotation',
                            'mental-rotation': 'mental-rotation',
                            'same': 'same-different-selection',
                            'same-different': 'same-different-selection',
                            'same-different-selection': 'same-different-selection',
                            'theory': 'theory-of-mind',
                            'theory-of-mind': 'theory-of-mind',
                            'tom': 'theory-of-mind',
                            'trog': 'trog',
                            'vocab': 'vocab',
                            'vocabulary': 'vocab',
                            'survey': 'survey',
                            'general': 'general'
                        };
                        
                        // Check for exact match first
                        if (labelMappings[cleanName]) {
                            labelName = labelMappings[cleanName];
                            console.log('üéµ Found exact label mapping:', cleanName, '->', labelName);
                            break;
                        }
                        
                        // Check for partial matches
                        for (const [key, value] of Object.entries(labelMappings)) {
                            if (cleanName.includes(key) || key.includes(cleanName)) {
                                labelName = value;
                                console.log('üéµ Found partial label mapping:', cleanName, '->', labelName);
                                break;
                            }
                        }
                        
                        // If we found a mapping, break from the outer loop
                        if (labelName !== 'general') {
                            break;
                        }
                        
                        // If no mapping found but we have a clean name, use it directly
                        if (cleanName && cleanName !== 'general') {
                            labelName = cleanName;
                            console.log('üéµ Using direct label name:', labelName);
                            break;
                        }
                    }
                }
            }
            
            console.log('üéµ Final label name selected:', labelName);
            
            // Clean up the string key for URL (replace spaces, special chars with hyphens)
            const cleanStringKey = stringKey
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens
            
            // Try multiple URL patterns for better compatibility
            const baseUrl = 'https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files';
            const urlPatterns = [];
            
            // Primary patterns with detected label (highest priority)
            if (labelName && labelName !== 'general') {
                urlPatterns.push(`${baseUrl}/${labelName}/${languageCode}/shared/${cleanStringKey}.mp3`);
                urlPatterns.push(`${baseUrl}/${labelName}/${languageCode}/shared/${stringKey.toLowerCase().replace(/\s+/g, '-')}.mp3`);
                urlPatterns.push(`${baseUrl}/${labelName}/${languageCode}/shared/${stringKey.toLowerCase().replace(/[^a-z0-9]+/g, '_')}.mp3`);
            }
            
            // Fallback patterns with 'general' (lower priority)
            urlPatterns.push(`${baseUrl}/general/${languageCode}/shared/${cleanStringKey}.mp3`);
            urlPatterns.push(`${baseUrl}/general/${languageCode}/shared/${stringKey.toLowerCase().replace(/\s+/g, '-')}.mp3`);
            
            // Try without label subdirectory (even lower priority)
            urlPatterns.push(`${baseUrl}/${languageCode}/shared/${cleanStringKey}.mp3`);
            
            // Last resort patterns
            if (labelName && labelName !== 'general') {
                urlPatterns.push(`${baseUrl}/${labelName}/${languageCode}/shared/${stringKey}.mp3`);
            }
            urlPatterns.push(`${baseUrl}/general/${languageCode}/shared/${stringKey}.mp3`);
            
            console.log('üéµ Will try Levante audio URLs:', urlPatterns);
            console.log('üéµ URL components:', { labelName, languageCode, cleanStringKey, originalStringKey: stringKey });
            
            // Return the first URL to try (we'll handle multiple attempts in the calling function)
            return { 
                success: true, 
                audioUrl: urlPatterns[0],
                alternativeUrls: urlPatterns.slice(1),
                source: 'levante_repository',
                details: { labelName, languageCode, cleanStringKey, originalStringKey: stringKey },
                targetLanguage: languageCode
            };
        }

        // Generate text-to-speech as fallback
        async function generateTextToSpeech(text) {
            // Use the translated text if available, otherwise fall back to provided text
            const textToSpeak = currentStringCache.text || text;
            const languageToUse = currentStringCache.targetLanguageId || currentStringCache.sourceLanguageId || 'en';
            
            if (!textToSpeak) throw new Error('No text available for TTS');
            
            // Use Web Speech API for text-to-speech
            if ('speechSynthesis' in window) {
                console.log('üéµ TTS: Will use text-to-speech for:', textToSpeak.substring(0, 100) + '...');
                console.log('üéµ TTS: Target language:', currentStringCache.targetLanguageId);
                console.log('üéµ TTS: Source language:', currentStringCache.sourceLanguageId);
                console.log('üéµ TTS: Using language:', languageToUse);
                console.log('üéµ TTS: Translated text:', currentStringCache.text ? currentStringCache.text.substring(0, 50) + '...' : 'N/A');
                console.log('üéµ TTS: Source text:', currentStringCache.sourceText ? currentStringCache.sourceText.substring(0, 50) + '...' : 'N/A');
                
                return { 
                    success: true, 
                    audioUrl: null, // Will use TTS directly
                    source: 'text_to_speech',
                    text: textToSpeak,
                    targetLanguage: languageToUse
                };
            }
            
            throw new Error('Text-to-speech not supported');
        }

        // Check if audio file exists
        async function checkAudioExists(url) {
            try {
                const response = await fetch(url, { method: 'HEAD' });
                return response.ok;
            } catch (error) {
                return false;
            }
        }

        // Play audio from URL or use TTS
        async function playAudio(audioUrl, source, text, alternativeUrls = [], targetLanguage = null) {
            if (source === 'text_to_speech') {
                // Use Web Speech API with correct language
                const textToSpeak = text || currentStringCache.text;
                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                utterance.rate = 0.8;
                utterance.pitch = 1;
                utterance.volume = 1;
                
                // Determine the target language for TTS
                const languageForTTS = targetLanguage || 
                                     currentStringCache.targetLanguageId || 
                                     currentStringCache.sourceLanguageId || 
                                     'en';
                
                console.log('üéµ TTS: Looking for voice for language:', languageForTTS);
                
                // Get available voices
                let voices = speechSynthesis.getVoices();
                
                // If voices aren't loaded yet, wait for them
                if (voices.length === 0) {
                    await new Promise(resolve => {
                        speechSynthesis.addEventListener('voiceschanged', resolve, { once: true });
                        setTimeout(resolve, 1000); // Fallback timeout
                    });
                    voices = speechSynthesis.getVoices();
                }
                
                console.log('üéµ TTS: Available voices:', voices.map(v => `${v.name} (${v.lang})`));
                
                // Language mapping for better voice selection
                const languageMap = {
                    'es': ['es', 'es-ES', 'es-MX', 'es-US'],
                    'fr': ['fr', 'fr-FR', 'fr-CA'],
                    'de': ['de', 'de-DE'],
                    'it': ['it', 'it-IT'],
                    'pt': ['pt', 'pt-BR', 'pt-PT'],
                    'ru': ['ru', 'ru-RU'],
                    'ja': ['ja', 'ja-JP'],
                    'ko': ['ko', 'ko-KR'],
                    'zh': ['zh', 'zh-CN', 'zh-TW'],
                    'ar': ['ar', 'ar-SA'],
                    'hi': ['hi', 'hi-IN'],
                    'en': ['en', 'en-US', 'en-GB']
                };
                
                // Find the best voice for the target language
                let selectedVoice = null;
                const targetLangCodes = languageMap[languageForTTS] || [languageForTTS];
                
                // Try to find a voice that matches the target language
                for (const langCode of targetLangCodes) {
                    selectedVoice = voices.find(voice => 
                        voice.lang.toLowerCase().startsWith(langCode.toLowerCase())
                    );
                    if (selectedVoice) {
                        console.log('üéµ TTS: Found voice for', langCode, ':', selectedVoice.name);
                        break;
                    }
                }
                
                // If no specific voice found, try a broader search
                if (!selectedVoice) {
                    selectedVoice = voices.find(voice => 
                        voice.lang.toLowerCase().startsWith(languageForTTS.toLowerCase())
                    );
                }
                
                // Set the voice if found
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                    utterance.lang = selectedVoice.lang;
                    console.log('üéµ TTS: Using voice:', selectedVoice.name, 'for language:', selectedVoice.lang);
                } else {
                    // Fallback to setting just the language
                    utterance.lang = languageForTTS;
                    console.log('üéµ TTS: No specific voice found, using language:', languageForTTS);
                }
                
                // Speak the text
                speechSynthesis.cancel(); // Cancel any ongoing speech
                speechSynthesis.speak(utterance);
                console.log('üéµ TTS: Playing text-to-speech for:', textToSpeak, 'in language:', utterance.lang);
                
                return new Promise((resolve) => {
                    utterance.onend = resolve;
                    utterance.onerror = resolve;
                    setTimeout(resolve, 10000); // Timeout after 10 seconds
                });
            } else {
                // Try to play audio file with fallback URLs
                const urlsToTry = [audioUrl, ...alternativeUrls];
                const failedUrls = [];
                
                for (let i = 0; i < urlsToTry.length; i++) {
                    const currentUrl = urlsToTry[i];
                    console.log(`üéµ Trying audio URL ${i + 1}/${urlsToTry.length}:`, currentUrl);
                    
                    try {
                        await tryPlaySingleAudio(currentUrl);
                        console.log('üéµ ‚úÖ Successfully played audio from:', currentUrl);
                        return; // Success, exit the function
                    } catch (error) {
                        console.log(`üéµ ‚ùå Failed to play audio from URL ${i + 1}:`, currentUrl, error.message);
                        failedUrls.push({ url: currentUrl, error: error.message });
                        
                        // If this was the last URL, throw the error with all failed URLs
                        if (i === urlsToTry.length - 1) {
                            const errorMessage = `All ${urlsToTry.length} audio URLs failed. Last error: ${error.message}`;
                            const finalError = new Error(errorMessage);
                            finalError.failedUrls = failedUrls;
                            throw finalError;
                        }
                        // Otherwise, continue to the next URL
                    }
                }
            }
        }

        // Helper function to try playing a single audio URL
        async function tryPlaySingleAudio(audioUrl) {
            return new Promise((resolve, reject) => {
                const audio = new Audio(audioUrl);
                audio.volume = 0.8;
                
                audio.oncanplaythrough = () => {
                    console.log('üéµ ‚úÖ Audio loaded successfully, playing:', audioUrl);
                    audio.play().then(resolve).catch(reject);
                };
                
                audio.onerror = (error) => {
                    console.log('üéµ ‚ùå Audio failed to load:', audioUrl, error);
                    reject(new Error(`Audio file not found or failed to load: ${audioUrl}`));
                };
                
                audio.onloadstart = () => {
                    console.log('üéµ üì° Started loading audio:', audioUrl);
                };
                
                // Set a timeout to avoid hanging indefinitely
                const timeout = setTimeout(() => {
                    console.log('üéµ ‚è∞ Audio loading timeout:', audioUrl);
                    reject(new Error(`Audio loading timeout: ${audioUrl}`));
                }, 8000); // 8 second timeout (reduced for faster fallback)
                
                audio.addEventListener('canplaythrough', () => clearTimeout(timeout));
                audio.addEventListener('error', () => clearTimeout(timeout));
                
                audio.load();
            });
        }

        // Show success result
        function showSuccessResult(stringKey, method, data) {
            const resultSection = document.getElementById('resultSection');
            const resultTitle = document.getElementById('resultTitle');
            const resultContent = document.getElementById('resultContent');
            
            resultTitle.className = 'result-title success';
            resultTitle.innerHTML = `<span>‚úÖ</span> ${method}`;
            
            let content = `<div class="string-info">`;
            content += `<strong>String Key:</strong> ${stringKey}<br>`;
            if (data.id) content += `<strong>ID:</strong> ${data.id}<br>`;
            if (data.text) content += `<strong>Text:</strong> ${data.text.substring(0, 100)}${data.text.length > 100 ? '...' : ''}<br>`;
            if (data.audioSource) content += `<strong>Audio Source:</strong> ${data.audioSource}<br>`;
            if (data.audioUrl) content += `<strong>Audio URL:</strong> <a href="${data.audioUrl}" target="_blank" style="color: #155724; word-break: break-all;">${data.audioUrl}</a><br>`;
            
            // Add metadata information if available
            if (data.metadata) {
                content += `<br><strong>üìä File Information:</strong><br>`;
                
                if (data.metadata.error) {
                    content += `&nbsp;&nbsp;<span style="color: #dc3545;">‚ùå Could not get file metadata</span><br>`;
                    if (data.metadata.errorMessage) {
                        content += `&nbsp;&nbsp;<strong>Error:</strong> ${data.metadata.errorMessage}<br>`;
                    }
                    if (data.metadata.status) {
                        content += `&nbsp;&nbsp;<strong>HTTP Status:</strong> ${data.metadata.status} ${data.metadata.statusText}<br>`;
                    }
                } else {
                    // Date information with clear distinction
                    if (data.metadata.lastModifiedFormatted) {
                        const isActualFileDate = data.metadata.dateSource === 'Last-Modified header' || data.metadata.dateSource === 'ETag timestamp';
                        const dateLabel = isActualFileDate ? 'File Modified' : 'Server Response';
                        const dateColor = isActualFileDate ? '#28a745' : '#ffc107';
                        
                        content += `&nbsp;&nbsp;<strong>${dateLabel}:</strong> <span style="color: ${dateColor};">${data.metadata.lastModifiedFormatted}</span>`;
                        content += ` <small>(${data.metadata.dateSource})</small>`;
                        
                        if (data.metadata.daysAgo !== undefined && isActualFileDate) {
                            if (data.metadata.daysAgo === 0) {
                                content += ` <span style="color: #28a745;">(today)</span>`;
                            } else if (data.metadata.daysAgo === 1) {
                                content += ` <span style="color: #ffc107;">(1 day ago)</span>`;
                            } else if (data.metadata.daysAgo <= 7) {
                                content += ` <span style="color: #ffc107;">(${data.metadata.daysAgo} days ago)</span>`;
                            } else {
                                content += ` <span style="color: #6c757d;">(${data.metadata.daysAgo} days ago)</span>`;
                            }
                        } else if (!isActualFileDate) {
                            content += ` <span style="color: #dc3545;">‚ö†Ô∏è Not file creation date</span>`;
                        }
                        content += `<br>`;
                    } else if (data.metadata.noDateInfo) {
                        if (data.metadata.corsLimited) {
                            content += `&nbsp;&nbsp;<strong>File Modified:</strong> <span style="color: #dc3545;">Not available (CORS restrictions block header access)</span><br>`;
                        } else {
                            content += `&nbsp;&nbsp;<strong>File Modified:</strong> <span style="color: #dc3545;">Not available (server doesn't provide Last-Modified header)</span><br>`;
                        }
                    }
                    
                    // File size
                    if (data.metadata.fileSizeFormatted) {
                        content += `&nbsp;&nbsp;<strong>File Size:</strong> ${data.metadata.fileSizeFormatted}<br>`;
                    }
                    
                    // Content type
                    if (data.metadata.contentType) {
                        content += `&nbsp;&nbsp;<strong>Content Type:</strong> ${data.metadata.contentType}<br>`;
                    }
                    
                    // Server info
                    if (data.metadata.server) {
                        content += `&nbsp;&nbsp;<strong>Server:</strong> ${data.metadata.server}<br>`;
                    }
                    
                    // Method used to get metadata
                    if (data.metadata.method) {
                        const methodText = data.metadata.method === 'server-proxy' ? 
                            'Server proxy (bypassed CORS)' : 
                            'Direct browser request';
                        content += `&nbsp;&nbsp;<strong>Method:</strong> <small>${methodText}</small><br>`;
                    }
                    
                    // Additional debugging info
                    if (data.metadata.etag) {
                        content += `&nbsp;&nbsp;<strong>ETag:</strong> <small>${data.metadata.etag}</small>`;
                        // Show if ETag was attempted for date parsing
                        if (data.metadata.dateSource === 'ETag timestamp') {
                            content += ` <span style="color: #28a745;">‚úì Used for date</span>`;
                        } else if (data.metadata.etag.match(/\d{10,13}/)) {
                            content += ` <span style="color: #dc3545;">‚úó Contains numbers but invalid date</span>`;
                        }
                        content += `<br>`;
                    }
                    if (data.metadata.cacheControl) {
                        content += `&nbsp;&nbsp;<strong>Cache Control:</strong> <small>${data.metadata.cacheControl}</small><br>`;
                    }
                }
            }
            
            if (data.details) {
                content += `<br><strong>URL Components:</strong><br>`;
                content += `&nbsp;&nbsp;Language: ${data.details.languageCode}<br>`;
                content += `&nbsp;&nbsp;Label: ${data.details.labelName}<br>`;
                content += `&nbsp;&nbsp;String Key: ${data.details.cleanStringKey}<br>`;
            }
            
            // Show language mapping information if available
            if (data.languageMapping) {
                content += `<br><strong>üåê Language Detection:</strong><br>`;
                content += `&nbsp;&nbsp;Original Target: ${data.languageMapping.originalTarget || 'N/A'}<br>`;
                content += `&nbsp;&nbsp;Mapped Target: ${data.languageMapping.mappedTarget || 'N/A'}<br>`;
                if (data.languageMapping.targetVariants && data.languageMapping.targetVariants.length > 0) {
                    content += `&nbsp;&nbsp;Target Variants: ${data.languageMapping.targetVariants.join(', ')}<br>`;
                }
                content += `&nbsp;&nbsp;Original Source: ${data.languageMapping.originalSource || 'N/A'}<br>`;
                content += `&nbsp;&nbsp;Mapped Source: ${data.languageMapping.mappedSource || 'N/A'}<br>`;
                if (data.languageMapping.sourceVariants && data.languageMapping.sourceVariants.length > 0) {
                    content += `&nbsp;&nbsp;Source Variants: ${data.languageMapping.sourceVariants.join(', ')}<br>`;
                }
                content += `&nbsp;&nbsp;Used Language: ${data.languageMapping.usedLanguage || 'N/A'}<br>`;
            }
            
            // Show all attempted URLs if available
            if (data.allTriedUrls && data.allTriedUrls.length > 0) {
                content += `<br><strong>üîó All Attempted URLs (${data.allTriedUrls.length}):</strong><br>`;
                data.allTriedUrls.forEach((url, index) => {
                    const isSuccessful = url === data.audioUrl;
                    const statusIcon = isSuccessful ? '‚úÖ' : '‚ùå';
                    const linkColor = isSuccessful ? '#28a745' : '#dc3545';
                    content += `<span style="color: #6c757d; font-size: 0.9em;">${index + 1}. ${statusIcon}</span> <a href="${url}" target="_blank" style="color: ${linkColor}; word-break: break-all; font-size: 0.9em;">${url}</a><br>`;
                });
            }
            
            if (data.message) content += `<br><strong>Status:</strong> ${data.message}`;
            content += `</div>`;
            
            resultContent.innerHTML = content;
            resultSection.className = 'result-section success';
            resultSection.style.display = 'block';
        }

        // Show error result
        function showErrorResult(message, attemptedUrls = [], allTriedUrls = []) {
            const resultSection = document.getElementById('resultSection');
            const resultTitle = document.getElementById('resultTitle');
            const resultContent = document.getElementById('resultContent');
            
            resultTitle.className = 'result-title error';
            resultTitle.innerHTML = `<span>‚ùå</span> Audio Not Found`;
            
            let content = `<div class="string-info">${message}</div>`;
            
            // Show all URLs that were actually attempted
            const urlsToShow = allTriedUrls.length > 0 ? allTriedUrls : attemptedUrls;
            
            if (urlsToShow && urlsToShow.length > 0) {
                content += `<div class="string-info"><strong>üîó All Attempted URLs (${urlsToShow.length}):</strong><br>`;
                urlsToShow.forEach((urlItem, index) => {
                    if (typeof urlItem === 'string') {
                        content += `<span style="color: #6c757d; font-size: 0.9em;">${index + 1}.</span> <a href="${urlItem}" target="_blank" style="color: #dc3545; word-break: break-all; font-size: 0.9em;">${urlItem}</a><br>`;
                    } else if (urlItem.url) {
                        content += `<span style="color: #6c757d; font-size: 0.9em;">${index + 1}.</span> <a href="${urlItem.url}" target="_blank" style="color: #dc3545; word-break: break-all; font-size: 0.9em;">${urlItem.url}</a>`;
                        if (urlItem.error) {
                            content += ` <span style="color: #dc3545; font-size: 0.8em;">(${urlItem.error})</span>`;
                        }
                        content += `<br>`;
                    }
                });
                content += `</div>`;
                
                // Add explanation of URL construction
                content += `<div class="string-info" style="margin-top: 10px; padding: 10px; background-color: #f8f9fa; border-left: 3px solid #6c757d;">`;
                content += `<strong>üí° URL Construction Logic:</strong><br>`;
                content += `The audio previewer constructs GitHub URLs by:<br>`;
                content += `1. Taking the Crowdin string key: <code>"${currentStringCache.stringKey || 'Unknown'}"</code><br>`;
                content += `2. Converting to filename: <code>"${(currentStringCache.stringKey || '').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '')}.mp3"</code><br>`;
                content += `3. Building URL: <code>https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/[label]/[language]/shared/[filename]</code><br>`;
                content += `<br><strong>üîß Possible Solutions:</strong><br>`;
                content += `‚Ä¢ Check if the audio file exists with the expected filename<br>`;
                content += `‚Ä¢ Verify the string key matches the actual audio filename<br>`;
                content += `‚Ä¢ Ensure the file is in the correct language/label directory<br>`;
                content += `</div>`;
            }
            
            resultContent.innerHTML = content;
            resultSection.className = 'result-section error';
            resultSection.style.display = 'block';
        }

        // Hide result section
        function hideResultSection() {
            document.getElementById('resultSection').style.display = 'none';
        }

        // Initialize Crowdin API
        function initializeCrowdinAPI() {
            // Add a delay to ensure the API is fully loaded
            setTimeout(() => {
                if (typeof AP !== 'undefined') {
                    console.log('üéØ Crowdin Apps JS API available');
                    
                    // Detect current editor mode for better handling
                    detectEditorMode();
                    
                    // Register for string events with error handling
                    try {
                        // Wrap event handlers to prevent errors from breaking the app
                        AP.events.on('string.change', function(stringData) {
                            try {
                                console.log('üéØ String changed:', stringData);
                                updateStringCacheFromCrowdinEvent(stringData, 'string.change');
                            } catch (error) {
                                console.error('üéØ Error handling string.change event:', error);
                            }
                        });
                        
                        AP.events.on('string.selected', function(stringData) {
                            try {
                                console.log('üéØ String selected:', stringData);
                                updateStringCacheFromCrowdinEvent(stringData, 'string.selected');
                            } catch (error) {
                                console.error('üéØ Error handling string.selected event:', error);
                            }
                        });
                        
                        // Add additional event listeners for better coverage across all modes
                        if (AP.events.on) {
                            try {
                                // Translation events (work better in comfortable/multilingual modes)
                                AP.events.on('translation.change', function(translationData) {
                                    try {
                                        console.log('üéØ Translation changed:', translationData);
                                        updateStringCacheFromCrowdinEvent(translationData, 'translation.change');
                                    } catch (error) {
                                        console.error('üéØ Error handling translation.change event:', error);
                                    }
                                });
                                
                                AP.events.on('translation.selected', function(translationData) {
                                    try {
                                        console.log('üéØ Translation selected:', translationData);
                                        updateStringCacheFromCrowdinEvent(translationData, 'translation.selected');
                                    } catch (error) {
                                        console.error('üéØ Error handling translation.selected event:', error);
                                    }
                                });
                                
                                // Editor events (better for comfortable/multilingual modes)
                                AP.events.on('editor.string.selected', function(stringData) {
                                    try {
                                        console.log('üéØ Editor string selected:', stringData);
                                        updateStringCacheFromCrowdinEvent(stringData, 'editor.string.selected');
                                    } catch (error) {
                                        console.error('üéØ Error handling editor.string.selected event:', error);
                                    }
                                });
                                
                                AP.events.on('editor.translation.selected', function(translationData) {
                                    try {
                                        console.log('üéØ Editor translation selected:', translationData);
                                        updateStringCacheFromCrowdinEvent(translationData, 'editor.translation.selected');
                                    } catch (error) {
                                        console.error('üéØ Error handling editor.translation.selected event:', error);
                                    }
                                });
                                
                                // Context events (work in all modes)
                                AP.events.on('context.change', function(contextData) {
                                    try {
                                        console.log('üéØ Context changed:', contextData);
                                        updateStringCacheFromCrowdinEvent(contextData, 'context.change');
                                    } catch (error) {
                                        console.error('üéØ Error handling context.change event:', error);
                                    }
                                });
                                
                                // Translations panel specific events
                                AP.events.on('translation.save', function(translationData) {
                                    try {
                                        console.log('üíæ Translation saved:', translationData);
                                        updateStringCacheFromCrowdinEvent(translationData, 'translation.save');
                                    } catch (error) {
                                        console.error('üéØ Error handling translation.save event:', error);
                                    }
                                });
                                
                                AP.events.on('translation.approve', function(translationData) {
                                    try {
                                        console.log('‚úÖ Translation approved:', translationData);
                                        updateStringCacheFromCrowdinEvent(translationData, 'translation.approve');
                                    } catch (error) {
                                        console.error('üéØ Error handling translation.approve event:', error);
                                    }
                                });
                                
                                console.log('‚úÖ Registered for all available Crowdin API events');
                            } catch (error) {
                                console.log('‚ö†Ô∏è Some events not available:', error);
                            }
                        }
                        
                        // Try to get current context immediately for comfortable/multilingual modes
                        setTimeout(() => {
                            tryGetCurrentContext();
                        }, 1000);
                        
                        console.log('‚úÖ Registered for Crowdin API events');
                    } catch (error) {
                        console.log('‚ö†Ô∏è Failed to register for Crowdin API events:', error);
                    }
                } else {
                    console.log('‚ö†Ô∏è Crowdin Apps JS API not available, retrying...');
                    // Retry after another delay
                    setTimeout(() => {
                        if (typeof AP !== 'undefined') {
                            console.log('üéØ Crowdin Apps JS API available on retry');
                            initializeCrowdinAPI();
                        } else {
                            console.log('‚ö†Ô∏è Crowdin Apps JS API still not available after retry');
                        }
                    }, 2000);
                }
            }, 1000);
        }

        // Detect current editor mode
        function detectEditorMode() {
            try {
                // Try to detect mode from URL or API
                const urlParams = new URLSearchParams(window.location.search);
                const mode = urlParams.get('mode');
                
                if (mode) {
                    console.log('üéØ Detected editor mode from URL:', mode);
                    currentStringCache.editorMode = mode;
                } else {
                    // Try to detect from API
                    if (typeof AP !== 'undefined' && AP.context) {
                        AP.context.getContext(function(context) {
                            if (context && context.mode) {
                                console.log('üéØ Detected editor mode from API:', context.mode);
                                currentStringCache.editorMode = context.mode;
                            }
                        });
                    }
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Could not detect editor mode:', error);
            }
        }

        // Try to get current context (useful for comfortable/multilingual modes)
        function tryGetCurrentContext() {
            try {
                if (typeof AP !== 'undefined' && AP.context) {
                    AP.context.getContext(function(context) {
                        console.log('üéØ Current context:', context);
                        
                        if (context) {
                            // Extract useful information from context
                            const contextData = {
                                projectId: context.projectId,
                                fileId: context.fileId,
                                stringId: context.stringId,
                                languageId: context.languageId,
                                userId: context.userId,
                                mode: context.mode
                            };
                            
                            // Update cache with context data
                            if (contextData.stringId || contextData.projectId) {
                                updateStringCacheFromCrowdinEvent(contextData, 'context.getContext');
                            }
                        }
                    });
                }
                
                // Also try to get current string if available
                if (typeof AP !== 'undefined' && AP.editor && AP.editor.getCurrentString) {
                    AP.editor.getCurrentString(function(stringData) {
                        console.log('üéØ Current string from editor:', stringData);
                        if (stringData) {
                            updateStringCacheFromCrowdinEvent(stringData, 'editor.getCurrentString');
                        }
                    });
                }
                
                // Try to get current translation if available
                if (typeof AP !== 'undefined' && AP.editor && AP.editor.getCurrentTranslation) {
                    AP.editor.getCurrentTranslation(function(translationData) {
                        console.log('üéØ Current translation from editor:', translationData);
                        if (translationData) {
                            updateStringCacheFromCrowdinEvent(translationData, 'editor.getCurrentTranslation');
                        }
                    });
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Error getting current context:', error);
            }
        }

        // Enhanced message handler that includes API events and mode-specific handling
        function enhancedMessageHandler(event) {
            // Prevent any default behavior that might cause navigation
            if (event.preventDefault) {
                event.preventDefault();
            }
            
            // Only process messages from Crowdin origins
            if (!event.origin || !event.origin.includes('crowdin.com')) {
                return;
            }
            
            // Throttle message processing to prevent overload
            if (window.lastMessageTime && Date.now() - window.lastMessageTime < 50) {
                return; // Reduced throttling for better responsiveness
            }
            window.lastMessageTime = Date.now();
            
            try {
                // Always log messages in comfortable/multilingual modes for debugging
                const debugMode = document.getElementById('debugMode')?.checked;
                const isComfortableOrMultilingual = currentStringCache.editorMode === 'comfortable' || 
                                                   currentStringCache.editorMode === 'multilingual';
                
                if (debugMode || isComfortableOrMultilingual) {
                    console.log('üì® Received message from Crowdin (mode: ' + currentStringCache.editorMode + '):', JSON.stringify({
                        origin: event.origin,
                        type: event.data?.type,
                        data: event.data
                    }, null, 2));
                }
                
                // Only process messages that contain actual data
                if (!event.data || typeof event.data !== 'object') {
                    return;
                }
                
                // Enhanced string data extraction for different modes
                const possibleStringData = extractStringDataFromMessage(event.data);
                if (possibleStringData.found) {
                    console.log('üéØ Found potential string data in message (mode: ' + currentStringCache.editorMode + '):', JSON.stringify(possibleStringData, null, 2));
                    
                    // Smart string ID handling for message extraction
                    let messageStringId = currentStringCache.stringId;
                    if (possibleStringData.stringId && possibleStringData.stringId > 1000) {
                        messageStringId = possibleStringData.stringId;
                        console.log('üì® ‚úÖ Using extracted string ID:', messageStringId);
                    } else if (!currentStringCache.stringId && possibleStringData.stringId) {
                        messageStringId = possibleStringData.stringId;
                        console.log('üì® ‚ö†Ô∏è Using potential extracted string ID (no existing):', messageStringId);
                    } else if (possibleStringData.stringId && possibleStringData.stringId <= 1000) {
                        console.log('üì® ‚ùå Ignoring small extracted ID (likely file ID):', possibleStringData.stringId, 'keeping existing:', currentStringCache.stringId);
                    }
                    
                    // Update cache with found data, preserving existing language info
                    // If we have a target language, treat the text as translated text
                    let textToUse = possibleStringData.text || currentStringCache.text;
                    let sourceTextToUse = currentStringCache.sourceText;
                    
                    if (possibleStringData.targetLanguageId && possibleStringData.text) {
                        // This is translated text
                        textToUse = possibleStringData.text;
                        console.log('üì® ‚úÖ Using translated text from message:', textToUse.substring(0, 50) + '...');
                    } else if (possibleStringData.text && !possibleStringData.targetLanguageId) {
                        // This might be source text
                        sourceTextToUse = possibleStringData.text;
                        console.log('üì® ‚úÖ Using source text from message:', sourceTextToUse.substring(0, 50) + '...');
                    }
                    
                    currentStringCache = {
                        stringId: messageStringId,
                        stringKey: possibleStringData.stringKey || currentStringCache.stringKey,
                        identifier: possibleStringData.identifier || currentStringCache.identifier,
                        text: textToUse,
                        sourceText: sourceTextToUse,
                        context: possibleStringData.context || currentStringCache.context,
                        fileId: possibleStringData.fileId || currentStringCache.fileId,
                        projectId: possibleStringData.projectId || currentStringCache.projectId,
                        sourceLanguageId: possibleStringData.sourceLanguageId || currentStringCache.sourceLanguageId,
                        targetLanguageId: possibleStringData.targetLanguageId || currentStringCache.targetLanguageId,
                        sourceLanguageName: currentStringCache.sourceLanguageName,
                        targetLanguageName: currentStringCache.targetLanguageName,
                        labels: possibleStringData.labels || currentStringCache.labels,
                        editorMode: currentStringCache.editorMode,
                        lastUpdated: new Date().toISOString(),
                        source: 'message_extraction'
                    };
                    
                    console.log('üéØ Updated string cache from message:', {
                        stringId: currentStringCache.stringId,
                        stringKey: currentStringCache.stringKey,
                        text: currentStringCache.text ? currentStringCache.text.substring(0, 50) + '...' : 'N/A',
                        targetLanguageId: currentStringCache.targetLanguageId,
                        sourceLanguageId: currentStringCache.sourceLanguageId,
                        editorMode: currentStringCache.editorMode
                    });
                    
                    // Update UI in a non-blocking way
                    setTimeout(() => {
                        updateStringCacheStatus();
                    }, 0);
                    
                    // Automatically fetch labels if we have a string ID (and it's not a file ID)
                    if (possibleStringData.stringId && possibleStringData.stringId > 1000) {
                        console.log('üè∑Ô∏è Auto-fetching labels for extracted string ID:', possibleStringData.stringId);
                        // Delay label fetching to prevent blocking
                        setTimeout(() => {
                            updateStringLabelsInCache();
                        }, 100);
                    } else if (possibleStringData.stringId && possibleStringData.stringId <= 1000) {
                        console.log('üè∑Ô∏è Skipping auto-fetch for small extracted ID (likely file ID):', possibleStringData.stringId);
                    }
                }
                
                // Special handling for different editor modes
                handleModeSpecificMessages(event.data);
                
            } catch (error) {
                console.error('üì® Error in message handler:', error);
                // Don't let message handling errors break the app
            }
        }

        // Handle mode-specific messages
        function handleModeSpecificMessages(data) {
            try {
                // In comfortable/multilingual modes, look for different message patterns
                if (data.type === 'editor.translation.selected' || 
                    data.type === 'translation.selected' ||
                    data.type === 'comfortable.string.selected' ||
                    data.type === 'multilingual.string.selected') {
                    
                    console.log('üéØ Mode-specific message detected:', data.type);
                    
                    // Extract data specific to these modes
                    if (data.payload || data.data) {
                        const payload = data.payload || data.data;
                        updateStringCacheFromCrowdinEvent(payload, data.type);
                    }
                }
                
                // Handle iframe communication patterns common in comfortable/multilingual modes
                if (data.action === 'string.select' || data.action === 'translation.select') {
                    console.log('üéØ Action-based message detected:', data.action);
                    updateStringCacheFromCrowdinEvent(data, data.action);
                }
                
                // Handle language switching events
                if (data.type === 'language.changed' || data.type === 'target.language.changed' || 
                    data.action === 'language.switch' || data.action === 'target.language.switch') {
                    console.log('üåê Language switch detected:', data.type || data.action);
                    
                    // Extract new language information
                    if (data.languageId || data.targetLanguageId) {
                        currentStringCache.targetLanguageId = data.languageId || data.targetLanguageId;
                        console.log('üåê Updated target language to:', currentStringCache.targetLanguageId);
                    }
                    
                    // Clear cached text when language changes to force refresh
                    if (data.type === 'language.changed' || data.type === 'target.language.changed') {
                        console.log('üåê Clearing cached text due to language change');
                        currentStringCache.text = null;
                        currentStringCache.lastUpdated = new Date().toISOString();
                        currentStringCache.source = 'language_switch';
                    }
                    
                    // Try to get fresh context after language switch
                    setTimeout(() => {
                        console.log('üåê Refreshing context after language switch...');
                        tryGetCurrentStringData();
                    }, 500);
                }
                
            } catch (error) {
                console.log('‚ö†Ô∏è Error in mode-specific message handling:', error);
            }
        }

        // Update string cache from Crowdin event data
        function updateStringCacheFromCrowdinEvent(stringData, eventType) {
            if (!stringData) return;
            
            try {
                console.log('üìù Processing string data from event:', eventType, JSON.stringify(stringData, null, 2));
            
            // Extract language information from string data
            let sourceLanguageId = currentStringCache.sourceLanguageId;
            let targetLanguageId = currentStringCache.targetLanguageId;
            let translatedText = currentStringCache.text;
            let sourceText = currentStringCache.sourceText;
            
            // Look for target language in translations
            if (stringData.translations) {
                const targetLangs = Object.keys(stringData.translations);
                if (targetLangs.length > 0) {
                    targetLanguageId = targetLangs[0]; // Get the first (and usually only) target language
                }
                
                // Extract the translated text from translations
                for (const lang in stringData.translations) {
                    const translations = stringData.translations[lang];
                    if (Array.isArray(translations) && translations.length > 0) {
                        const firstTranslation = translations[0];
                        if (firstTranslation.target_language_id) {
                            targetLanguageId = firstTranslation.target_language_id;
                        }
                        if (firstTranslation.text) {
                            translatedText = firstTranslation.text;
                            console.log('üìù ‚úÖ Found translated text:', translatedText.substring(0, 50) + '...');
                        }
                    }
                }
            }

            // Extract potential string ID, being careful not to confuse with file ID
            const potentialStringId = stringData.string?.id || stringData.id;
            const potentialFileId = stringData.string?.file?.id || stringData.file?.id;
            
            // Only update stringId if we get a large number (actual string ID) or if we don't have one yet
            let newStringId = currentStringCache.stringId;
            if (potentialStringId && potentialStringId > 1000) {
                newStringId = potentialStringId;
                console.log('üìù ‚úÖ Using new string ID:', newStringId);
            } else if (!currentStringCache.stringId && potentialStringId) {
                newStringId = potentialStringId;
                console.log('üìù ‚ö†Ô∏è Using potential string ID (no existing ID):', newStringId);
            } else if (potentialStringId && potentialStringId <= 1000) {
                console.log('üìù ‚ùå Ignoring small ID (likely file ID):', potentialStringId, 'keeping existing:', currentStringCache.stringId);
            }
            
            // Store source text (English) separately from translated text
            const currentSourceText = stringData.string?.text || stringData.text;
            if (currentSourceText && currentSourceText !== translatedText) {
                sourceText = currentSourceText;
                console.log('üìù ‚úÖ Found source text:', sourceText.substring(0, 50) + '...');
            }
            
            // Update cache with new information
            currentStringCache = {
                stringId: newStringId,
                stringKey: stringData.string?.identifier || stringData.identifier || stringData.key || currentStringCache.stringKey,
                identifier: stringData.string?.identifier || stringData.identifier || stringData.key || currentStringCache.identifier,
                text: translatedText || currentStringCache.text, // Use translated text for TTS
                sourceText: sourceText || currentStringCache.sourceText, // Keep source text separate
                context: stringData.string?.context || stringData.context || currentStringCache.context,
                label: stringData.string?.label || stringData.label || currentStringCache.label,
                labels: stringData.string?.labels || stringData.labels || currentStringCache.labels,
                maxLength: stringData.string?.max_length !== undefined ? stringData.string.max_length : (stringData.max_length !== undefined ? stringData.max_length : currentStringCache.maxLength),
                fileId: potentialFileId || currentStringCache.fileId,
                fileName: stringData.string?.file?.name || stringData.file?.name || currentStringCache.fileName,
                projectId: stringData.string?.project?.id || stringData.project?.id || currentStringCache.projectId,
                sourceLanguageId: sourceLanguageId,
                targetLanguageId: targetLanguageId,
                sourceLanguageName: currentStringCache.sourceLanguageName,
                targetLanguageName: currentStringCache.targetLanguageName,
                lastUpdated: new Date().toISOString(),
                source: eventType
            };
            
            console.log('üìù ‚úÖ Updated cache - translated text:', currentStringCache.text ? currentStringCache.text.substring(0, 50) + '...' : 'N/A');
            console.log('üìù ‚úÖ Updated cache - source text:', currentStringCache.sourceText ? currentStringCache.sourceText.substring(0, 50) + '...' : 'N/A');
            console.log('üìù ‚úÖ Updated cache - target language:', currentStringCache.targetLanguageId);
            
            // Update language names if we have the language list
            updateLanguageNamesInCache();
            
            // Fetch string labels if we have a string ID (and it's not a file ID)
            if (currentStringCache.stringId && !currentStringCache.labels && currentStringCache.stringId > 1000) {
                console.log('üè∑Ô∏è Auto-fetching labels for string ID:', currentStringCache.stringId);
                updateStringLabelsInCache();
            } else if (currentStringCache.stringId && currentStringCache.stringId <= 1000) {
                console.log('üè∑Ô∏è Skipping auto-fetch for small ID (likely file ID):', currentStringCache.stringId);
            }
            
            // Update the UI to show we have cached string data
            updateStringCacheStatus();
            } catch (error) {
                console.error('üìù Error in updateStringCacheFromCrowdinEvent:', error);
                // Don't let errors break the app
            }
        }

        // Helper function to update language names in cache
        function updateLanguageNamesInCache() {
            // Try to get language names from the available languages list
            if (typeof AP !== 'undefined' && AP.editor && AP.editor.getProjectTargetLanguages) {
                AP.editor.getProjectTargetLanguages(function(languages) {
                    if (languages && Array.isArray(languages)) {
                        // Find source and target language names
                        languages.forEach(lang => {
                            if (lang.code === currentStringCache.sourceLanguageId || lang.internal_code === currentStringCache.sourceLanguageId) {
                                currentStringCache.sourceLanguageName = lang.name;
                            }
                            if (lang.code === currentStringCache.targetLanguageId || lang.internal_code === currentStringCache.targetLanguageId) {
                                currentStringCache.targetLanguageName = lang.name;
                            }
                        });
                        
                        // Update UI with language information
                        updateStringCacheStatus();
                        console.log('üåç Updated language names in cache:', {
                            sourceLanguageId: currentStringCache.sourceLanguageId,
                            targetLanguageId: currentStringCache.targetLanguageId,
                            sourceLanguageName: currentStringCache.sourceLanguageName,
                            targetLanguageName: currentStringCache.targetLanguageName
                        });
                    }
                });
            }
        }

        // Fetch label names from label IDs
        async function fetchLabelNames(projectId, labelIds, token) {
            if (!projectId || !labelIds || labelIds.length === 0 || !token) {
                console.log('üè∑Ô∏è Missing required parameters for label name fetching');
                return [];
            }

            try {
                console.log('üè∑Ô∏è Fetching label names for IDs:', JSON.stringify(labelIds, null, 2));
                
                const labelPromises = labelIds.map(async (labelId) => {
                    const url = `https://api.crowdin.com/api/v2/projects/${projectId}/labels/${labelId}`;
                    console.log('üè∑Ô∏è Fetching label:', url);
                    
                    const response = await fetch(url, {
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (response.ok) {
                        const labelData = await response.json();
                        console.log('üè∑Ô∏è Label API response:', JSON.stringify(labelData, null, 2));
                        
                        if (labelData && labelData.data) {
                            return {
                                id: labelData.data.id,
                                title: labelData.data.title
                            };
                        }
                    } else {
                        console.error('üè∑Ô∏è Failed to fetch label', labelId, ':', response.status);
                    }
                    return null;
                });

                const labelResults = await Promise.all(labelPromises);
                const validLabels = labelResults.filter(label => label !== null);
                
                console.log('üè∑Ô∏è Successfully fetched labels:', JSON.stringify(validLabels, null, 2));
                return validLabels;
            } catch (error) {
                console.error('üè∑Ô∏è Error fetching label names:', error);
                return [];
            }
        }

        // Fetch string labels from Crowdin API
        async function fetchStringLabels(projectId, stringId, token) {
            if (!projectId || !stringId || !token) {
                console.log('üè∑Ô∏è Missing required parameters for label fetching');
                return [];
            }

            // Try direct string endpoint first
            const directUrl = `https://api.crowdin.com/api/v2/projects/${projectId}/strings/${stringId}`;
            
            try {
                console.log('üè∑Ô∏è Fetching labels for string ID:', stringId);
                console.log('üè∑Ô∏è Trying direct endpoint:', directUrl);
                
                const response = await fetch(directUrl, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('üè∑Ô∏è Direct API response:', JSON.stringify(data, null, 2));
                    
                    if (data && data.data) {
                        // Check multiple possible locations for labels
                        const stringData = data.data;
                        console.log('üè∑Ô∏è String data structure:', JSON.stringify(stringData, null, 2));
                        
                        // Check if we have labelIds that need to be resolved
                        if (stringData.labelIds && stringData.labelIds.length > 0) {
                            console.log('üè∑Ô∏è Found labelIds:', JSON.stringify(stringData.labelIds, null, 2));
                            const labelNames = await fetchLabelNames(projectId, stringData.labelIds, token);
                            console.log('üè∑Ô∏è Resolved label names:', JSON.stringify(labelNames, null, 2));
                            return labelNames;
                        }
                        
                        const labels = stringData.labels || stringData.label || [];
                        console.log('üè∑Ô∏è Labels found:', JSON.stringify(labels, null, 2));
                        return labels;
                    }
                }

                console.log('üè∑Ô∏è No string found with ID:', stringId);
                return [];
            } catch (error) {
                console.error('üè∑Ô∏è Error fetching string labels:', error);
                return [];
            }
        }

        // Update string cache with fetched labels
        async function updateStringLabelsInCache() {
            if (!currentStringCache.stringId) {
                console.log('üè∑Ô∏è No string ID available for label fetching');
                return;
            }

            const projectId = '756721';
            const token = '161834fde81833a72996c125d9c1a1c801ae99ef15eb1d3889dfe9fbc55077aaea02b62f1e24278e';

            // Validate that we have a proper string ID (should be a large number, not a small file ID)
            const stringId = currentStringCache.stringId;
            console.log('üè∑Ô∏è Attempting to fetch labels for string ID:', stringId, '(type:', typeof stringId, ')');
            
            // String IDs are typically much larger than file IDs (which are usually < 1000)
            if (typeof stringId === 'number' && stringId < 1000) {
                console.log('üè∑Ô∏è Warning: String ID', stringId, 'seems too small, might be a file ID. Skipping label fetch.');
                return;
            }

            try {
                const labels = await fetchStringLabels(projectId, stringId, token);
                
                if (labels && labels.length > 0) {
                    currentStringCache.labels = labels;
                    console.log('üè∑Ô∏è Updated cache with labels:', JSON.stringify(labels, null, 2));
                    
                    // Update UI to show the new labels
                    updateStringCacheStatus();
                } else {
                    console.log('üè∑Ô∏è No labels found for this string');
                }
            } catch (error) {
                console.error('üè∑Ô∏è Failed to update labels in cache:', error);
            }
        }

        // Update UI to show string cache status
        function updateStringCacheStatus() {
            const cacheStatus = document.getElementById('stringCacheStatus');
            
            if (currentStringCache.stringKey || currentStringCache.stringId) {
                const languageInfo = [];
                if (currentStringCache.sourceLanguageId) {
                    const sourceName = currentStringCache.sourceLanguageName || currentStringCache.sourceLanguageId;
                    languageInfo.push(`<strong>Source:</strong> ${sourceName} (${currentStringCache.sourceLanguageId})`);
                }
                if (currentStringCache.targetLanguageId) {
                    const targetName = currentStringCache.targetLanguageName || currentStringCache.targetLanguageId;
                    languageInfo.push(`<strong>Target:</strong> ${targetName} (${currentStringCache.targetLanguageId})`);
                }
                
                // Build additional info array
                const additionalInfo = [];
                if (currentStringCache.label) {
                    additionalInfo.push(`<strong>Label:</strong> ${currentStringCache.label}`);
                }
                if (currentStringCache.labels && Array.isArray(currentStringCache.labels) && currentStringCache.labels.length > 0) {
                    const labelTags = currentStringCache.labels.map(label => 
                        `<span class="label-tag">${label.title || label.name || label}</span>`
                    ).join('');
                    additionalInfo.push(`<strong>Labels:</strong><br>${labelTags}`);
                }
                if (currentStringCache.maxLength !== null && currentStringCache.maxLength !== undefined) {
                    additionalInfo.push(`<strong>Max Length:</strong> ${currentStringCache.maxLength === 0 ? 'No limit' : currentStringCache.maxLength}`);
                }
                if (currentStringCache.fileName) {
                    additionalInfo.push(`<strong>File:</strong> ${currentStringCache.fileName}`);
                }
                
                cacheStatus.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <span style="font-size: 1.2rem;">üéØ</span>
                        <strong>Current String Cached</strong>
                        <span style="font-size: 0.8rem; opacity: 0.7;">(${currentStringCache.lastUpdated})</span>
                        ${currentStringCache.editorMode ? `<span style="font-size: 0.8rem; background: #e3f2fd; color: #1976d2; padding: 2px 6px; border-radius: 12px; margin-left: 5px;">${currentStringCache.editorMode}</span>` : ''}
                    </div>
                    <div style="font-family: monospace; background: white; padding: 8px; border-radius: 4px; margin: 5px 0;">
                        <strong>Key:</strong> ${currentStringCache.stringKey || currentStringCache.identifier || 'N/A'}<br>
                        <strong>ID:</strong> ${currentStringCache.stringId || 'N/A'}<br>
                        <strong>Text:</strong> ${currentStringCache.text ? currentStringCache.text.substring(0, 100) + (currentStringCache.text.length > 100 ? '...' : '') : 'N/A'}
                        ${languageInfo.length > 0 ? '<br>' + languageInfo.join('<br>') : ''}
                        ${additionalInfo.length > 0 ? '<br>' + additionalInfo.join('<br>') : ''}
                    </div>
                    <div style="font-size: 0.9rem; opacity: 0.8;">
                        Source: ${currentStringCache.source || 'Unknown'}
                    </div>
                `;
                cacheStatus.style.display = 'block';
            } else {
                cacheStatus.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.2rem;">‚è≥</span>
                        <span>Waiting for string selection... Select a string in the editor to cache its information.</span>
                    </div>
                `;
                cacheStatus.style.display = 'block';
            }
        }

        // Helper function to extract string data from any message
        function extractStringDataFromMessage(data) {
            const result = {
                found: false,
                stringId: null,
                stringKey: null,
                identifier: null,
                text: null,
                context: null,
                label: null,
                labels: null,
                maxLength: null,
                fileId: null,
                fileName: null,
                projectId: null,
                sourceLanguageId: null,
                targetLanguageId: null
            };
            
            // Recursively search for string-related properties
            function searchObject(obj, path = '') {
                if (!obj || typeof obj !== 'object') return;
                
                for (const [key, value] of Object.entries(obj)) {
                    const currentPath = path ? `${path}.${key}` : key;
                    
                    // Check for string ID patterns - be more specific to avoid file IDs
                    if ((key.toLowerCase().includes('stringid') || key.toLowerCase().includes('string_id')) && value) {
                        result.stringId = value;
                        result.found = true;
                    } else if (key === 'id' && path.toLowerCase().includes('string') && !path.toLowerCase().includes('file') && value > 1000) {
                        // Only accept 'id' if it's in a string context, not a file context, and is a large number
                        result.stringId = value;
                        result.found = true;
                    }
                    
                    // Check for string key patterns
                    if ((key.toLowerCase().includes('stringkey') || key.toLowerCase().includes('string_key') ||
                         key.toLowerCase().includes('identifier') || key.toLowerCase().includes('key')) && 
                         typeof value === 'string' && value.length > 0 && value.length < 200) {
                        result.stringKey = value;
                        result.identifier = value;
                        result.found = true;
                    }
                    
                    // Check for text patterns
                    if ((key.toLowerCase().includes('text') || key.toLowerCase().includes('source') ||
                         key.toLowerCase().includes('content')) && typeof value === 'string' && value.length > 0) {
                        result.text = value;
                        result.found = true;
                    }
                    
                    // Check for context patterns
                    if (key.toLowerCase().includes('context') && value) {
                        result.context = value;
                        result.found = true;
                    }
                    
                    // Check for label patterns
                    if (key.toLowerCase().includes('label') && value) {
                        if (Array.isArray(value)) {
                            result.labels = value;
                        } else {
                            result.label = value;
                        }
                        result.found = true;
                    }
                    
                    // Check for max length patterns
                    if ((key.toLowerCase().includes('maxlength') || key.toLowerCase().includes('max_length')) && value) {
                        result.maxLength = value;
                        result.found = true;
                    }
                    
                    // Check for file ID patterns
                    if ((key.toLowerCase().includes('fileid') || key.toLowerCase().includes('file_id')) && value) {
                        result.fileId = value;
                        result.found = true;
                    }
                    
                    // Check for file name patterns
                    if ((key.toLowerCase().includes('filename') || key.toLowerCase().includes('file_name') || 
                         (key === 'name' && path.toLowerCase().includes('file'))) && typeof value === 'string') {
                        result.fileName = value;
                        result.found = true;
                    }
                    
                    // Check for project ID patterns
                    if ((key.toLowerCase().includes('projectid') || key.toLowerCase().includes('project_id')) && value) {
                        result.projectId = value;
                        result.found = true;
                    }
                    
                    // Check for language ID patterns (important for comfortable/multilingual modes)
                    if ((key.toLowerCase().includes('sourcelanguageid') || key.toLowerCase().includes('source_language_id') ||
                         (key === 'languageId' && path.toLowerCase().includes('source'))) && value) {
                        result.sourceLanguageId = value;
                        result.found = true;
                    }
                    
                    if ((key.toLowerCase().includes('targetlanguageid') || key.toLowerCase().includes('target_language_id') ||
                         key.toLowerCase().includes('languageid') || key.toLowerCase().includes('language_id')) && value) {
                        result.targetLanguageId = value;
                        result.found = true;
                    }
                    
                    // Recursively search nested objects
                    if (typeof value === 'object' && value !== null) {
                        searchObject(value, currentPath);
                    }
                }
            }
            
            searchObject(data);
            
            // Additional extraction patterns for comfortable/multilingual modes
            if (data.payload) {
                searchObject(data.payload, 'payload');
            }
            
            if (data.data) {
                searchObject(data.data, 'data');
            }
            
            // Handle translation-specific data structures
            if (data.translation) {
                searchObject(data.translation, 'translation');
            }
            
            if (data.translations) {
                // In multilingual mode, we might have multiple translations
                if (typeof data.translations === 'object') {
                    for (const [langCode, translations] of Object.entries(data.translations)) {
                        if (Array.isArray(translations) && translations.length > 0) {
                            // Use the target language from the first translation
                            result.targetLanguageId = langCode;
                            result.found = true;
                            
                            // Extract data from the first translation
                            searchObject(translations[0], `translations.${langCode}.0`);
                        }
                    }
                }
            }
            
            return result;
        }

        // Debug mode toggle
        function toggleDebugMode() {
            const debugMode = document.getElementById('debugMode').checked;
            const debugSection = document.getElementById('debugSection');
            
            debugSection.style.display = debugMode ? 'block' : 'none';
            
            // Store debug mode preference
            localStorage.setItem('crowdinAudioPreviewerDebugMode', debugMode);
            
            // Update debug info
            updateDebugInfo();
        }

        // Update debug information
        function updateDebugInfo() {
            const debugInfo = document.getElementById('debugInfo');
            if (debugInfo) {
                debugInfo.textContent = JSON.stringify({
                    currentStringCache,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    location: window.location.href
                }, null, 2);
            }
        }

        // Prevent app from disappearing due to navigation events
        function preventAppDisappearance() {
            // Prevent any unintended navigation
            window.addEventListener('beforeunload', function(e) {
                console.log('üö´ Preventing unintended navigation');
                // Don't actually prevent navigation, just log it
            });
            
            // Prevent form submissions that might cause navigation
            document.addEventListener('submit', function(e) {
                console.log('üö´ Preventing form submission');
                e.preventDefault();
                return false;
            });
            
            // Prevent clicks on links that might cause navigation
            document.addEventListener('click', function(e) {
                if (e.target.tagName === 'A' && e.target.href && !e.target.target) {
                    console.log('üö´ Preventing link navigation, opening in new tab instead');
                    e.preventDefault();
                    window.open(e.target.href, '_blank');
                    return false;
                }
            });
            
            // Keep the app alive with periodic heartbeat
            setInterval(() => {
                console.log('üíì App heartbeat - still alive');
            }, 30000); // Every 30 seconds
        }

        // Periodic context polling for comfortable/multilingual modes
        function startContextPolling() {
            // Poll for context changes every 2 seconds in comfortable/multilingual modes
            setInterval(() => {
                if (currentStringCache.editorMode === 'comfortable' || 
                    currentStringCache.editorMode === 'multilingual' ||
                    !currentStringCache.stringId) {
                    
                    // Only poll if we don't have recent string data
                    const lastUpdate = currentStringCache.lastUpdated ? new Date(currentStringCache.lastUpdated) : null;
                    const now = new Date();
                    const timeSinceUpdate = lastUpdate ? (now - lastUpdate) / 1000 : Infinity;
                    
                    if (timeSinceUpdate > 5) { // Only poll if no update in last 5 seconds
                        console.log('üîÑ Polling for current context (mode:', currentStringCache.editorMode, ')');
                        tryGetCurrentContext();
                    }
                }
            }, 2000);
        }

        // Add click handler to retry getting context when play button is clicked without string data
        function enhancePlayButton() {
            const originalPlayFunction = window.playCurrentAudio;
            
            window.playCurrentAudio = async function() {
                // If we don't have string data, try to get current context first
                if (!currentStringCache.stringId && !currentStringCache.stringKey) {
                    console.log('üéØ No string data cached, trying to get current context...');
                    
                    // Show loading state
                    const playBtn = document.getElementById('playBtn');
                    const playIcon = document.getElementById('playIcon');
                    const playText = document.getElementById('playText');
                    
                    playBtn.disabled = true;
                    playIcon.innerHTML = '<div class="loading-spinner"></div>';
                    playText.textContent = 'Getting Current String...';
                    
                    // Try to get current context
                    await new Promise(resolve => {
                        tryGetCurrentContext();
                        // Give it a moment to process
                        setTimeout(resolve, 1000);
                    });
                    
                    // Reset button state
                    playBtn.disabled = false;
                    playIcon.textContent = 'üéµ';
                    playText.textContent = 'Play Current Audio';
                }
                
                // Call original function
                return originalPlayFunction.call(this);
            };
        }

        // Function to manually refresh context
        async function refreshContext() {
            const refreshBtn = document.getElementById('refreshBtn');
            const refreshIcon = refreshBtn.querySelector('span:first-child');
            const refreshText = refreshBtn.querySelector('span:last-child');
            
            try {
                // Disable button and show loading state
                refreshBtn.disabled = true;
                refreshIcon.textContent = '‚è≥';
                refreshText.textContent = 'Refreshing...';
                
                console.log('üîÑ Manual context refresh requested');
                console.log('üîÑ Current cache state before refresh:', JSON.stringify(currentStringCache, null, 2));
                
                // Clear current cache to force fresh data
                const editorMode = currentStringCache.editorMode; // Preserve editor mode
                currentStringCache = {
                    stringId: null,
                    stringKey: null,
                    identifier: null,
                    text: null,
                    sourceText: null,
                    context: null,
                    labels: null,
                    maxLength: null,
                    fileId: null,
                    fileName: null,
                    projectId: null,
                    sourceLanguageId: null,
                    targetLanguageId: null,
                    sourceLanguageName: null,
                    targetLanguageName: null,
                    lastUpdated: null,
                    source: null,
                    editorMode: editorMode
                };
                
                // Try to get fresh context
                await tryGetCurrentStringData();
                
                // Update UI
                updateStringCacheStatus();
                updateDebugInfo();
                
                console.log('üîÑ Context refresh completed');
                console.log('üîÑ Updated cache state:', JSON.stringify(currentStringCache, null, 2));
                
                // Show success message
                refreshIcon.textContent = '‚úÖ';
                refreshText.textContent = 'Refreshed!';
                
                // Reset button after a delay
                setTimeout(() => {
                    refreshIcon.textContent = 'üîÑ';
                    refreshText.textContent = 'Refresh Context';
                    refreshBtn.disabled = false;
                }, 2000);
                
            } catch (error) {
                console.error('üîÑ Error during context refresh:', error);
                
                // Show error state
                refreshIcon.textContent = '‚ùå';
                refreshText.textContent = 'Error';
                
                // Reset button after a delay
                setTimeout(() => {
                    refreshIcon.textContent = 'üîÑ';
                    refreshText.textContent = 'Refresh Context';
                    refreshBtn.disabled = false;
                }, 2000);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üéµ Audio Previewer loaded and ready as TRANSLATIONS PANEL module');
            
            // Prevent app disappearance
            preventAppDisappearance();
            
            // Initialize Crowdin API with translations panel specific setup
            initializeCrowdinAPI();
            
            // Set up enhanced message handler with error protection
            try {
                window.addEventListener('message', enhancedMessageHandler);
                console.log('‚úÖ Message handler registered');
            } catch (error) {
                console.error('‚ùå Failed to register message handler:', error);
            }
            
            // Initialize string cache status
            updateStringCacheStatus();
            
            // Set up debug mode toggle
            const debugModeCheckbox = document.getElementById('debugMode');
            if (debugModeCheckbox) {
                debugModeCheckbox.addEventListener('change', toggleDebugMode);
                
                // Restore debug mode preference
                const savedDebugMode = localStorage.getItem('crowdinAudioPreviewerDebugMode');
                if (savedDebugMode === 'true') {
                    debugModeCheckbox.checked = true;
                    toggleDebugMode();
                }
            }
            
            // Start context polling for comfortable/multilingual modes
            setTimeout(() => {
                startContextPolling();
            }, 3000);
            
            // Enhance play button with context retry
            enhancePlayButton();
            
            updateDebugInfo();
            
            console.log('üéµ Audio Previewer initialization complete');
        });
    </script>
</body>
</html> 